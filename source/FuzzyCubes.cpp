#include "FuzzyCubes.h"

/*

- Lite version (2 hours)
	- iAd
		- place in Menu and In-Game
		- Not in Tutorial
	- Link to game
	
- Final Beta testing (a few days)
	- testing on iPod 1, iPod 2, iPod 4
	- testing on iPhone 3G
	- testing on iPad

- FINAL Quality Control and Review (a few days) 
- App Submission
- Promotion
	- Facebook
	- Webpage
	- Video
	- Reddit
- Submit to app review sites

Version Number: Major.minor.build
1.1.0 - 2/19/12
1.0.0 - 2/6/12

General Changes:
	- Added all HD graphics
	- increased timer in ep3 levels by 20 seconds.
	- Tutorials no longer play unless new game is pressed.
	- GameOver now restarts player to level 1
		- FIX: Restart at score screen now keeps them at same Episode, but resets score and points
		- 
	- Android version should now stay lit during loading times


3/20/12
General Changes:
	- Continued Resolution correction

3/14/12
General Changes:
	- Start Resolution correction for any screensize with old assets

2/20/12
General Changes:
	- trying to call s3eVideoStop() in update() portion of code to see if it stops crashes and junk.
	- Fixed restart to make game state not lose score

2/19/12
General Changes:
	- Updated Tutorial perfect clear message and when it pops up
		- Now always appears periodically and disappears on any perfect clear
		- Keeps appearing until 1-3 ?
	- Added a Match Colors message to beginning of game, also affects when game starts
	- Shortened time of show/hide donotstack and donotdie 
	- Update Submitted.

2/17/12
General Changes:
	- Fixed opacity and occurance behavior of plane-shift tutorial message
	- Add a do-not-die message every time a fuzzy explodes up to and including 1-3
	- Score screen now renders over tutorial messages
	- Tutorial message Rotate now larger
	- Shortened the Rotate message time coming up
	- Restarting game now does NOT replay cinema
		- both from paused, and from score screen
		- and fixed more stuff
	- Added tutorial message that lets them know they killed fuzzies if on wrong color
	- Other misc. tweaks in tutorial message timings
	- Tweaked Rotate button to not spawn single cube until it's pressed in episode 1
	- Fixed tutorial bomb messages not showing after adding the last tutorial message
	- Added New Story Confirmation screen if there is a continue available.
	- SaveFile now saves Episode 1 Checkpoint at 1-4
		- now saves score
	- version 1 apps now default bomb and warning tutorials to false on first startup from update
	- Shortened the disappear time for plane shift tutorial message
	- Quit now does not kill your score

2/16/12
General Changes:
	- Added tutorial messages for bombs.
	- Replaced 500 points image
	- Changed qfiDifficultyCap from 3 to 2 in first level, ensuring that player does not hit double_random before level 1-3
	- Added GameOver voice to when a bomb explodes by detonation
	- Enable tutorial skip during story mode
	- Perfected Showing tutorial shift planes message
	- Edited tutorial drag space message
	- Changed the ways things disappear and reappear
	- lots of changes.

	- Added checkpoint to 1-4
		- Level can now load at episode 1-4
	- Tweaked Game Over stamp coming in faster
	- disabled certain tutorial sprites from rendering if past episode 1-3
	- Fixed weird glitch of bomb exploding function not reached by adding some "print statements"
	- Changed the way volume adjusts.
		- now based on state rather than function
	- Change drag space to find cube to point to active cube

2/15/12
General Changes:
	- Added tutorial messages for first couple of levels for gameplay	

2/06/12
General Changes:
	- Downgrade back to 5.1.0! 
		- 5.2.2 still has s3eAudio glitch

	- Added shadow to text in High Score, and in-game, and score screen
	- removed more assets in mkb that were unused
	- Change color of ep3 timer from yellow -> red
	- Changed episode 1-4 to random spawning instead of incolor spawning.
		- basically swapped spawning type with 1-5. 1-5 is now incolor
	- Added boolean to dictate when ep3 timer starts rendering
	- Edited ep3 timer when at zero seconds to display 0:00 instead of 0:00:00
	- Decreased GameOver Sprite trigger from 3 seconds to 2 seconds
	- Make GameOver sprite Transparent so player can see score
	- Added Quit Confirmation to ScoreScreen as well as Paused screen for quit button
		- updated flurry button press to distinguish between quits, both yes and no
	- Added Timer ping sound for ep3 ticking down
	- Added info dialog for question mark
	- updated all cinema to .mp4 codec
	- updated tutorial menu screen buttons
	- Fixed: saveHighStats() always saving if highscore was above N. Should not save if trophy was achieved.
	- Fixed: score requirement for viewing rap video on game-end
		- now must have ACTIVE score of 1,000,000+ points
	- Change the way livesGained affects lives.
		livesGained changed to scoreLifeBonusBucket
	- Moved Render PlusOneFuzzy on top of squares
	- Added adjustment so that Fuzzy Rap plays at end regardless of highscore + win game combo.
	- MAJOR GLITCH Fixed: Episode 6-5 freezes. Turn planespawning from quintuple to sextuple.
	- Updated Trophy Hero.
	- Updated Save() in ReleaseQuitconfirmation()
		- Now only saves highstats, not level or lives or anything
	- FIXED: Menu Cube buttons and Menuscreen buttons now affected by Limbo variable to prevent glitched responses

2/05/12
General Changes:
	- Added Quit confirmation screen for Paused-Quit button	
	- updated assets in mkb to be NOT included in final version
	- Repositioned spacebus in progress bar, so it's more centered at the height level
	- Took out unecessary assets in mkb.	
 
Fixes:
	- Added Resume Button in paused screen to require limbo = true to resume
	- Continue menu button now resets levelNumber = 1 to prevent glitched loading. (I thought I did this before..)

2/04/12
- After staying up from previous starting day, it is done.
- Beta testing. Then submission.

General Changes:
	- Quit button now resets score and lives
	- Rap Video now plays at game over! Phew close one.
	- Flurry now logs when rap video is played via menu

2/03/12
Fixes:
	- Fixed a glitch where quitting from at-end score screen, going to menu, then going back to continue crashes the game.
	- levelNumber and targetEpisode were not properly updated
	- levelNumber now updated, targetEpisode now always loaded from saveFile
General Changes:
	- Moved the last 2 tutorials to come one-after-another at end of episode 1-3
		- fixed. Moved warnings back to 1-7. Makes more sense.
	- reduced the .png sizes of episode 4, 5, and 6
	- added gameover and sound to trigger at gameover score screen
	- Added all trophy messages
	- Added Question Mark button to play Fuzzy Rap if enabled
	- Replaced progress bar fuzzy with spacebus
	- Added and fixed a whole buncha junk. 

2/01/12
General Changes:
	- version 1.14 on 5.2.2 SDK, to allow for GameCenter support
		- free version will use 1.13 if using iOS iAd
	- version 1.13 is going back on 5.1.0 SDK
		- iAd banner still not scaling correctly on 5.2.2
		- Make sure Ads load on loadleveldata and stop on terminate level data
		- Remember to turn off for Paid version
		- added variable iAdOn to control turning on and off of iAds
	- version 1.12 is iAd back on 5.2.2 SDK
		- not working wtf
		- removed adwhirl
			- FINALLY THIS FIXED ITTT!!1!@#$2323
			- Having adwhirl included in the project but NOT USING it jacked it up!! dunno whyyyy
			- Do not have adwhirl and iAd enabled at the same time.
			- Also be careful of the extra deployment option adwhirl requires. turned it off, that caused scaling problem I think.
				- no I think this was the SDK 5.2.2.
			- I think it might've been Certificates not being installed that cause to not deploy.
				- b/c adwhirl worked fine with ios deployments before. no reason code should mess it up just from compiling
	- version 1.11 is iad
	- version 1.10 is adwhirl
		- Added adwhirl
	- version 1.09 is marmalade 5.2.2
	- version 1.08 is marmalade 5.1.0
	- Installed tutorial for 3rd cutscene
		- Adding boolean to save file does not seem to affect loading of file, thus no data was lost
	- Add additional flurry event logs:
		- pressed Play
		- pressed Tutorial
		- pressed HighScore
		- pressed Credits
		- Pressed Continue
		- pressed Rate Button
		- pressed tutorial1
		- pressed tutorial2
		- pressed tutorial3
		- pressed trophy1
		...
		- pressed trophy5
		- pressed Pause - Restart
		- pressed Pause - Resume
		- pressed Pause - Quit
		- pressed ScoreScreen - Next
		- pressed ScoreScreen - Restart
		- pressed Scorescreen - quit
	- Moved LoadSaveFile() from LoadingBackground() to LoadingMenuData()


1/31/12
- General Changes:
	 - added button assets to tutorial menu screen

1/30/12
- General Changes:
	- Added assets and data structures for Tutorial Menu Screen
	- Added Tutorial video transitions to in-game, disabling cinema skip only for first time in-game tutorials
	- Added tutorial videos to tutorial menu screen

1/29/12
- Fixes:
	- Fixed score screen coming up at end of episode 4, 5, and 6 from GAMEPLAY.
	- cleaned up some code here and there that weren't doing anything

- General Changes:
	- Added Final Cutscene and Credit scene to data structures
		- all that's left is to put in the data.	

1/28/12
- Fixes:
	- Fixed a bug where Next button comes up after a death of high-stacking and/or out-of-lives after ep 1-3, 2-3, etc.
	- Fixed flurry tracking of death by high stack

- General Changes
	- Added Flurry tracking for:
		- time spent on each episode
		- which episode-level player died on
		- how the player died:
			- out of lives
			- high stacking
			- out of time on ep3-7 to 3-9
		- skill level for each time score is displayed
		- FIX: REMOVED Logging of Death and Skill
			- only levelstart is necessary!!
	- Tweaked episode 3, made more variable falling in level 3-7, 3-8, and 3-9
	- Tweaked how bombs spawn at levelNumber 4, ensuring a bomb spawns first after cutscene
	- multiple bomb spawning after 1-4
		- only up to episode 3. episode 4, 5, and 6 do not have wuzzy cutscenes so no bomb variance here except for each level

1/27/12
- General Changes:
	- Game now loads to main menu every time it starts up.
	- There is an option for Continue if there is an ongoing game
	- Reduced the amount of places the game saves.
	- The game should only save at the score screen if it's going to next episode, or if a restart is clicked at any time
	- Added VERSION CONTROL for save files. Now can save and load all data with scalable versions and content.
	- Added separate save functions for high stats, separate from game states
	- Added message for Rate button if there is no internet connection
	- Added Flurry setting unique ID to device


1/26/12
- Major Changes:
	- Upgraded from Airplay 4.3.3 to Marmalade 5.1.0
	- Transparency of NullMaterial now has larger alpha value
	- Flurry extention now added, and works

1/25/12
- General Changes:
	- Added pixie dust
		- Added its own callback functions to offset timing with score
		- Retimed the sound effects
	- Add trophy sprite

1/23/12
- Story Mode Changes:
	- Inserted Score Screen right before every cinematic.
	- Episode 3 timer now reduced, and resets after each level up

1/18/12
- Episode 3 Changes:
	- level now slowly descends and hits a clamping value depending on the level
	- timer is now initiated at level 7
	- game over states included.
	- Game at testing stage, so moves fast up to 3-7

1/17/12
- General Changes:
	- Bombs now spawn as wtf or f-bomb with 
		- 50/50 in ep 4
		- 60/40 in ep 5
		- 70/30 in ep 6
	- fixed fuzziness not calculating correctly on scoreboard

- Visual Changes:
	- Next Button now same size as other buttons
	- Buttons in Score screen were shrunk and moved down slightly
	- Menu Cubes now bobble extra on release (in addition to pressed)


1/16/12
- General Changes:
	- Added new sprite animations for WTF_bombs
	- Added new bomb alert animation for WTF bombs
	- The Swipe image in main menu now glows when swiping

1/14/12
- General Changes:
	- Game now is restricted on devices after iphone 3GS, only that has opengl-es2

1/12/12
- General Changes:
	- Added formula for calculating fuzziness based from 0% - 100%
	- Formula affected by increasing of scoredDrops on warps and bomb defuses
	- also decreasing on fuzzy exploding and bomb exploding
	- Tweaked speed of ep 6 level 4 and 5 from 800 to 850

- Fixes:
	- Tweaked highestlayerlevel check for general height, not planes.
	- not affected by cube exploding state

1/09/12
- General Changes
	- Added wtf bombs!!
- Fixes
	- Added levelNumber=1 to releasing menu button play/new. 
	- This correctly starts the game after the player has died on a level other than 1 on any episode
	- Deleted fuzzyPlanet
	- Deleted blurEffect
	- Deleted and freed splash and title assets on loadleveldata and loadmenudata based on boolean
	- Fixed menuDataTerminated = true (was false before) on startup, since game starts with no data loaded


1/05/12
- General Changes
	- Add new swipe image to replace arrows, b/c asset too expensive
	- Trophies in High Score screen now have descriptions for how-to-get and when already rewarded.
		- Very rough draft. Need to replace with images to look "nice."

1/03/12
- General Changes
	- Trophies are now obtainable

12/23/11
- General Changes
	- Added new swipe arrows
	- Added new menu cube button texts
	- Added Splash and new menu transitions

12/22/11
- Menu Changes:
	- Added new menu title

12/21/11
- General Changes:
	- High Score Screen now has touchable trophies
	- Trophy states now save
	- Tweaked episodes 4, 5, 6
	- Story mode has now first 2 interim cinematics
		- the way levels initialize also affected by levelNumber

12/19/11
- Story Mode Changes:
	- Added more levels to episodes 4, 5, 6
	- Levels increased from 3 to 5.
	- Levels also tweaked

12/15/11
- General Changes:
	- Score screen now animates 1 score at time with accompanying sound

12/14/11
- General Changes:
	- Created High Score Menu

12/12/11
- General Changes:
	- Now saves the LivesGained variable to represent accurate fuzzy count
	- sound is also now reduced on the Pause callback

12/09/11
- Story Mode Changes:
	- Episode 5:
		- now has particles like episode 4
	- Episode 4:
		- There are now 4 different particles
		- particles are updated.
		- Now are waving with rumbleMatrix
	- Episode 3:
		- Windstreaks are now transparent and more "air-like" by turning on alpha-half
	- Episodes now initialize at mid-transition, making it more natural when loading to next episode.

- General Changes:
	- When in paused screen, volume gets lowered.
	- Bombs' frequency was tweaked to make spawning more frequent.

12/08/11
- General Changes:
	- Added data storage.
	- Games now Save at:
		- Save();
		- After an episode is initialized, but outside of the method. Must put this in manually.
		- When at score screen. 'gameOver' state affects the playStory = true or false, and playStory affects whether or not the stuff is loaded
		- when Quit button is pressed, save state to make playStory = false. 
			- Quit button in pause screen and also score screen, place separately
	- Games load at LoadBackgroundAndOtherInit();
		- LoadSaveFile();

- Game Play Changes:
	- When getting perfect warps, the storyModeTotalDropsCurrent now increases exponentially, as with the points

- Story Mode Changes:
	- Episode 3:
		- now has more windstreaks
		- background vibrates more frequently but less amplitude	
		
- Visual Changes:
	- change transition from quitting to fade to black to fade to white


12/07/11
- Story Mode Changes:
	- Added WindStreaks and Wind System for Ep 3.
	- Episode 3 now has rumbling in background to simulate turbulence effect
- Visual Changes:
	- Square Indicators now show all squares for episodes 1-3, but utilize conservative blinking for episodes 4-6
- Menu/Transition Changes:
	- 'limbo' variable now prevent buttons from being double-activated if pressed twice during a transition

- General Changes:
	- Level backgroundSpheres are now split up in the loading.

- Bug Fixes:
	- Added removeMovingCubeAndTerminate() to remove more memory leaks
	- Fixed memory leak of WindSystem being initialized when not necessary in 2 places.
	- spheres are now deleted first before IwResManager group gets destroyed. Not sure if this does anything.
		- EDIT: this does cause it to crash on iphone. Do not do this.

12/04/11
- Visual Changes:
	- Re-implemented full fadein/fadeout transition system
- General Changes:
	- Fixed game ending glitch where losing all lives does not end the game
	- Fixed Next Level transition beyond max episode glitch
	- Hopefully fixed memory leak for game Shutdown

12/01/11
- Visual Changes:
	- added score/efficiency/skill to score screen layout

11/30/11
- Story Mode Changes:
	- Added episodes 5 and 6
	- Added new music and background

- Gameplay Changes:
	- Sensitivity of cubes are now dynamic based on the layer level of the shadow
	- More accurate in terms of intuition and shadow movement

11/19/11
- Added more sounds and voices.
- Lots of sounds and voices.
- General Changes:
	- Fixed Great perk not popping up if directly completed after Level Up
	- Fixed Level Up not being disabled properly after rendering
	- Added celebration sound for a non-perfect warp

11/18/11
-

11/17/11
- Added first cinematics.

11/15/11
- Gameplay Changes:
	- The 'closestCube' for the falling cubes are now always the top-most cube on the grid
	- When cubes are exploding, they are no longer considered in the collision detection
	- Rotation and tap-drop have been enabled for when cubes are exploding

11/10/11
- General Changes:
	- FuzzyExplodeMaterial for Cube object now initialized when fuzzy is created
		and also destroyed when removing static cubes from array
	- took out the two lines of code where it initialized them
- Story Mode Changes:
	- The Yellow Fade Out for Game Over by Win-condition now changed to White, by way of loading white.png instead of yellow.png
	- The methods setyellowFadeOut and other yellow variables still remain

11/09/11
- Story Mode Changes:
	- Added swaying for episode 3
	- Made cubes faster for episode 4

11/08/11
- Story Mode Changes:
	- After episode 1, every level except level 1 now have bombs
	- There is now a Speed Increase at Level 4 and Level 7 after episode 1
		- The speed increases are 600 and 800 respectively
		- Cubes now slow down to 400, and 500 when reaching panic threshold distance, respectively
		- Cubes with Initial speeds of 400 now reduce to 200 when in panic zone
	- Bombs no longer register points or play the pointperk sound when landing on same color side
	- Number of cubes required for completion has been decreased for after episode 1
	
- General Gameplay Changes:
	- Perfect Warp combos are now 5000, 10,000, and 10,000 points respectively. 25k will be added when sprite is available
	- Score no longer accumulates when progress bar is filled
	- Cubes now slow down to speeds 400 and 500 when reaching panic distance, if initial speeds were under 600 and 800
		- Cubes with Initial speeds of 400 now reduce to 200 when in panic zone
	- Blink speeds now reduced and capped with the 600 mark.
		- The reasoning for this is that the cubes will drop down fast anyway, and the transition from one
			speed to the next will automatically become faster.
		- Also the speed is reduced now when cube reaching panic distance. 

11/07/11
- Story Mode Changes:
	- Added lighting adjustment for episode 3 to differentiate from other levels to provide global illumination
	- Added Episode 3 Background
	- One life is now gained for every 25,000 points earned
	
11/06/11
- Story Mode Changes:
	- Levels have now been updated to new difficulty specifications

- General Gameplay Changes:
	- Score and lives reset only happens when Episode 1 Level 1 is initialized
	- Falling Cube Indicators on upper right corner now only blink when falling cubes are close to the surface
		- They also blink at a static, slower pace
	- F-Bomb now repositioned near the square indicators


11/01/11
- Story Mode Changes: - story mode v. 1.05
	- increased speeds on earlier levels for episode 4
	- Added background 2D object for planet. but it did not turn out well
		- may need to use 3D object and place inside
	- Episode 2 now has blue stars
	- Episode 2 now has original, blue galaxy

10/31/11
- General Gameplay Changes:
	- Players now rewareded with Combo Perks, gaining 1000, 5000, and 10000 points respectively
		for consecutive perfect Warps 
	- the order of perks displayed are Nice, Great, and Super, with Super being looped indefinitely
	- Added new music to each episode. Order of music is subject to change.

- Story Mode Changes: - story mode v. 1.04
	- Tweaked episode 1 - lvl 4 and 5
		Bombs now introduced at level 5
	- Tweaked episode 3 - lvl 5
	- Episode 4 is now complete.


10/26/11
- Story Mode Changes: - story mode v. 1.03
	- Play Game button from menu screen now always defaults to episode 1
	- Episode 2 now has speed variations.
	- Episode 3 is now complete.

10/25/11
- Story Mode Changes: - story mode v. 1.01
	- Warps now increase totalDrops and add to the progression bar
	- Defusing a bomb now adds 1 life to offset 1 life lost during defusal
	- Fuzzy sprite is now displayed at the end of the progress bar
	- Episodes now end on Level 9 instead of 10
	- Length of levels are now incremented by 9 drops every level starting at 18 from first level

	Story Mode v. 1.02
	- Added episode 2 levels
	- Made changes to episode 1 levels, bombs now do not spawn in level 8, but in level 7
	- Types of fuzzies now spawn in episodes 1, 2, 3, and in episode 4 all 3 kinds spawn.

10/24/11
- Story Mode Changes: - story mode v. 1.00
	- completed Episode 1, levels 1-10
	- integrated bombs and spawning bombs

10/19/11
- QFI Changes:
	- add a LevelCap variable to prevent QFI from advancing levels

- Story Mode Changes:
	- Add levels 1-10

10/18/11
- Gameplay Changes:
	- Add level up to story mode
	- Add the level up requirements in array

10/12/11
- HUD Changes:
	- Added Next Button to story mode, appear ONLY if advancing to next level
	- Resized and relocated the Buttons to make them more centered

	- Added level up sprite, not yet showing

- Need:
	- Implement a requiredDrops[levelnum] data structure for story mode similar to challenge mode
	- whenever a levelnum increases, show the showCongratsSpriteLevelUp = true;


10/11/11
- GamePlay Changes:
	- Allow Level1 of QFI to increase if no perfect clear after the first 15 drops.
	- Still increases on a non-perfect clear
- General Changes:
	- Added Bomb Defused perk
	- Added Minus One Fuzzy perk
	- Should probably fix the pointSprites and minusOneFuzzySprite data structures.
	- since they all have their own positions, I can just fill it up like a bucket and it doesn't
	 matter what array position they are in. I just render until they aren't there anymore.

	- Added FadeIn/FadeOut for ending a game on Victory
	- Reorganized the data structures and consolidated GameStart and GameEnd states into just TransitionStates


10/10/11
- GamePlay Changes:
	- Added Bomb Alert
		- still needs adjustment in terms of animation
	- Tweaked bomb speeds
		- Slowest bomb blinking speed now blinks for 5 seconds
		- Second bomb blinking speed now blinks for 4 seconds
		- fastest bomb blinking speed now blinks for 3 seconds
- General Changes:
	- Added FadeIn/FadeOut transitions for Starting from loading screen, Restarting at paused and score, and GameOver
	- Added Opacity interpolation for Sprite class using the Alpha variable


10/08/11
- Added 3 bomb speeds (animations)

10/05/11
- Begin Story Mode coding
	- First level is activated with QFI, with no bombs
	- 

10/04/11
- Bug Fixes:
	- Fixed all bomb issues
	- Game no longer crashes when bomb starts exploding in the middle of another cube explosion of same side
	

10/02/11
- MenuCube Changes:
	- MenuCubes now Bobble internally
	- Menu Cubes are now stored in an array. The only things needed to add for the creation of MenuCubes 
		are incrementing the numOfActiveMenuCubes variable and Initialize method.

10/01/11
- Gameplay Changes:
	- If a bomb has landed, spawning now only spawns SINGLE types for defusal
	- Bombs now cannot be defused once activated / is Heating_Up
	- Bombs now have a boolean 'defused' variable that determines if it was defused or not
		- this prevents memory errors from happening so that it does not get defused in between the lag time of drop and explosion
	- Increase the bomb times

9/26/11
- Gameplay Changes:
	- Made bombs defuseable. 

9/25/11
- Gameplay Changes:
	- Added Bomb class.
	- Bombs explode.

- Fixes:
	- fixed ALL memory leaks.
	- memory leaks happen when removing cubes incorrectly. Call Reset() every time cubes are removed

9/24/11
- Adding Bombs

9/21/11
- Main Menu Changes:
	- successfully implemented Challenge Menu Screen translation in and out, along with buttons. Works perfectly.

- Challenge Mode Changes:
	- Added Challenge mode for all 20 levels

- General Changes:
	- Updated Blinking Speeds for all speeds 200 to 1000

- Memory Leak Fixes:
	- fixed Terminating Challenge Menu Screen termination on menu termination

9/19/11
- HUD Changes:
	- Added level progression bar

- Sound Fixes:
	- Fixed pointperk sound where it played no matter what side it landed on.
	- Point perk sound now plays only when scored points

- General Changes:
	- Added a developerLevels mode/toggle to allow for testing of individual difficulty levels
		- Many attributes are affected by this, such as level progression bar, score screen display, and how soon game ends
	- Can be toggled by touching High Scores button in Main Menu
	- Added blinking for increased speed at Initial Speed of 800. 

- Memory Leak Check:
	- Fixed memory leak for sounds

9/18/11
- Sound Changes:
	- Added new sounds for landing, point perk, clearing, and perfect clearing

9/12/11
- Sprite Class Changes:
	- Added Sprite interpolation methods and variables
	- Added Challenge Menu Screen variables to make it interpolate
		- This causes Mac Deployment to crash on Play for some reason...

9/09/11
- Audio Changes:
	- Added fuzzy theme music
	- moved level 1 music to level loading
- HUD Changes:
	- Fixed alignment of progress bar by 2 pixels
- Score Screen Changes:
	- Moved the Restart and Quit button down by 100 pixels to prevent accidental touch on ending
- MenuCubes:
	- Added Challenge menu cube
	- Added Challenge Menu Screen
- Created MenuScreen class

9/06/11
- iAd Changes:
	- added if Banner_Loaded == true condition to determine if iAd banner should be shown
	- in the future, will need to implement periodic ping checking to activate iAd
- Sound Effects:
	- Add methods to load and play sounds
		- LoadSoundData()
		- playLandSound();
		- playWarpSound();
- QFI Changes:
	- Tweaked the rules for flow intervals
		- now the highest flow intervals only valid if apm is less than 30
		- decreased the flow interval by .07 for the first two skillset intervals

9/05/11
- QFI Changes:
	- Adjusted plane and targetPlane defaults in checkandwarp and moved it out of conditional statement for only if
		difficulty != targetDifficulty
	- Fixed Glitch where decreasing a side when targetDifficulty == 1 created deadlock
		- forgot to add targetDifficulty == 1 condition under decreasing side when reducing
	- Fixed ANDROID Glitch. uint64 bits cannot be zero when merging with double.
	
 

9/04/11
- Added bool to determine if the program has iAd exention everywhere an iAd method is called
- Tutorial Changes:
	- Nice! for tutorial only shows when a cube hits the plane on the CORRECT side, i.e., the blue side
	- Cubes do NOT spawn for tutorial part 5, Rotate Camera
	- Inactive sides are now more transparent like main game

9/03/11
- Start iAd testing
- IAd works.
	- Use s3eSocket to ping a website to test for internet connectivity
	- if connected, initiate iAd
	- ping website periodically to check to see if iAd should continue to display
- Adjusted Skill calculation by increasing APM by 4/3 when calculing skill index
- Added a else-condition for if skillLevel is over the skill ceiling of 165
- Removed Slowing cube speed if passing panic level.
	- When slowed down, it wasn't creating enough panic to cause it to be a valid panic level
- With added increase of APM, skill level / comfort-level determination is much more accurate.

9/02/11
- QFI Changes:
	- Increased the numOfDropsRequired for performanceChecking for INC cubeSpawn levels when INCREASING difficulty
	- Decreased the numOfDropsRequired for performanceChecking for INC cubeSpawn levels when DECREASING difficulty
	- Changed the other numOfDropsRequired, slightly longer increase
	- Increased the flow Interval requirements to maintain or reach flow for INC cubeSpawn levels
	- Added QFI Variable reset for performanceChecking if in Flow State for too long.
		- This prevents player from not being able to increase or decrease difficulty levels if in Flow State for too long
	- When increasing difficulty on a 1-plane increase, planes now add 1 if NON-PERFECT clear, and subtracts 1 adds 2 on PERFECT clear
	- Fixed increasing planeside from quintuple to sextuple glitch with new implementation

- Tutorial Changes:
	- Added new Nice! and Complete! graphics
	- Cut the empty space to Nice! and Complete graphics, reducing from 1024x1024 to 1024x512
	- Nice! now displays whenever a cube lands on planeSide for tutorial levels 4 and 7 to signal player they are doing it right.
	- Reduced the tutorialSprites by 40% so that actual size and display size are 1:1
- PlayGame Changes
	- Great! congrats sprite was increased from 192x192 to 250x250
	- Great! congrats sprite is now centered on screen
	- +1000 points sprite was moved from middle to above Great! on perfect clear
	- 50, 100, 500, 1000 point sprites reduced from 512x512 to 512x256 by deleting empty spaces in lower portion of sprite
	


9/01/11
- QFI Changes:
	- During Difficulty increase, if planes are only increasing (by 1), planes now increase on non-perfect warps instead of perfect warps 
		- This is designed to prevent gameplay from moving too slowly if 
			player does not get perfect warps due to bad cube spawns
		- Should make level/difficulty-increasing less predictable and more subtle
	- QFI variables for checking now reset on a perfect OR non-perfect warp AND if totalDropsCurrent meets numOfDropsRequired
		- Previously they reset if only the first condition was met
		- This should provide more accurate statistics measurement and comparison
	- Decreasing TargetDifficulty:
		- TargetDifficulty is still reduced only once, cubeSpawning regressed by 1 each time
			- After new statistics reset tweak, this performs the performanceChecking at more accurate intervals
		- cubeSpawning now also reduces at every performanceCheck, without reducing targetDifficulty
		- This allows player to have higher chance of performing perfect warps until targetPlaneSpawning, and thus targetDifficulty, is reached
		

9/01/11
- Begin QFI first prototype
- Algorithm in notebook, start implmentation
- The old SkillIndex is now the PerformanceIndex
- New skillIndex now takes into consideration uAPM
- Added second set of variables for average and current effic./multi./comfort
	- split up instantaneousAPM from currentAPM

- QFI Prototype Finished for Speed = 400
	- Handles increasing and decreasing of difficulty level
	- upperFlowBound and lowerFlowBound are determined by APM/skill
	- handles increasing level by decreasing plane count
	- also decreasing levels by decreasing plane count
	- took like 8 hours! Started at 12:45 am, finished at 8:30 am
- For Reduction: CubeSpawning now keeps reducing indefinitely while targetDifficulty maintains one level below
	- Once targetDifficulty is reached, cubeSpawning resumes targetSpawn

8/30/11
- Added Speed adjustment to choose-difficulty screen
	- TestButton, now a rotateicon on lower right corner, starts the game instead of upper right button
- Plane Sides now disappear and respawn on a perfect clear.

8/29/11
- Added Skill, Efficiency, multitasking, comfort level Indexes
- Added Resetting of QFI functions
- Fixed a memory leak where fuzzy material and explode material were not being deleted.
	- Also during Remove, not deleted
	- should have absolutely NO memory leaks now...
- Added option/difficulty choosing screen for both developer testing and in-game difficulty selection
- Resized Rotate Button
- This was a long day...took like 16 hours to implment entire QFI statistic measurements. Still not done, need to map level combinations to skill/apm/eff.
- Fixed Average APM Resetting


8/28/11
- Start Implementing Quantum Flow Intelligence


8/27/11
- Fixed Credits Menu Cube button motion touching
- Testing new look to make cubes transparent
- Added a Yellow Color scheme
	- Text appeared off because they did not match the background stars.
	- With the text being the same hue as the background objects, they seem more "in-place"
	- Text must also match the plus points graphics so that it also makes sense
		- Because the plus points are yellow, text must also be yellow, and thus stars must also be yellow, and background space also is yellow
- ResumeCallbackReceived is now PauseCallbackReceived. 
	- It works much better to pause the game on program sleep and come back paused than 
		to pause after coming back.
- Worked on Implementing more Levels
- Started Level Design Spreadsheet

8/26/11
- Implemented new Pause Screen
	- Pause Screen has dim image filter
	- Added Resume button
	- Added Quit button
	- Added Restart button
	- Removed PAUSE button and functionality
- TestButton was moved from in-game into Paused Screen for isolated method testing
- Changed SwipeVelocity sensitivty lower limit back down from 5 to 2.
	- Updated a savedAngle variable in MenuCubes so hopefully they should not glitch out anymore
		and rotation should stay pretty uniform
- Updated the updating of savedAngle in MenuCube that affects the theta variable of position of cubes in circle
- Discovered the importance of IwResourceManager and how it is linked to serialisation and its callbacks.
	- Need to load textures with the resource manager for the serialisation callback to work!
	- Then convert the textures to CIw2Dimages. Render as usual.
- Edited MenuCube swiping conditions. Took out equal signs

8/25/11
- Added New Pause button
- Increased size of Nice 
- Increased Loading icon spinning

8/24/11
- Added Congrats Sprites
	- Great! displays when a side clears perfectly
	- Added Nice Sprite to Tutorial clearing
- Updated Game HUD:
	- Moved position of Square indicators from bottom left to top right
	- Moved Lives down one
	- Moved Score to a more-snug corner
	- Text color changed from white to light yellow to match Plus Points animations
	- Orange side is slighty darker
	- Deactivated Plane Sides are now much darker
- Updated the Tutorial HUD:
	- Formatted the text to wrap around screen objects
	- Text now displays Completed! status when action is complete
	- Tutorial now displays Nice! sprite when action is complete
	- Moved the Test button from lower left to lower right.
	- Moved position of Tutorial Arrows from lower right to lower left
- Increased certain tutorial cstring datasizes due to increase-in-length
- Tutorial Descriptions are now more descriptive.
- Fixed Glitch where if a static piece exists in Play_Game, it transfers to tutorial
- Updated MainMenu:	
	- SwipeVelocity upper limit increased from 15 to 20, making each swipe more sensitive
	- SwipeVelocity lower limit decreased from 5 to 2, making the swipes and autosnap seem softer
		- Edit: Changed back from 2 to 5. There was glitch of cubes being overlapped with that value.
- Fixed Tap Glitch of swiping
- Added >= to > in Swiping conditions to prevent deadlock in middle
- Fixed Great! glitch showing at startup of Game if played through Tutorial

8/23/11
- Started to implement new Level designs
	- Finished Levels 1 - 4 with about 1-3 phases each
	- Implemented option of activating only Adjacent Sides
	- Implemented option of spawning only within active sides
- Fixed spawning adjacent sides Bug
- Fixed Menu transitioning display glitch where it flickers a zoomed-in version of everything for a split second
	- This was accomplished by moving the Loading states from Render() to Update()

8/21/11
- Added TerminateMenuData() and TerminateTutorialData() functions
	- Apparently having data in cache slows down performance, so if not in menu, release the cache with the big textures
	- Same if leaving tutorial.
- Loading of Background Sphere and stars are now separate from menu data loading
- Perhaps consider keeping Menu Data loaded if it does not affect performance unless going into tutorial
- This will speed up Game to Menu to Game process

- Removed Unecessary Initializations:
	- IwUI controller, view, and other IwUI stuff

- Figured out how to create loading screen and animations
	- Use the serialisation callbacks to display animations
	- register other callbacks for other uses
	- Use Iw2DSurfaceShow to immediately display image before loading
 
- Massively Reduced initial loading time by not Loading Star Texture a billion times!!!!

8/20/11
- Switched out shadowTextures for cubeTextures on cubes
- Updated Menu Title, now renders using 2 sprites to create 1 sprite animation.
	- Animation is handled outside

8/19/11
- Added new point system for cubes
	- still need to delete the old point system and stop texture from loading
	- do not need booleans for increasing score. obsolete.
- Updated the Sprite class to fix some glitch of not looping just once if set to loop once
- Updated where the points add to the score
- Added new textures for all the points from 50 to 10,000
- Tested out new textures for the main menu

8/18/11
- Added individual Bobbling for every Menu Cube item
- FIXED: bobbling for all cubes. 
	- Bobbling behavior was not correct due to Z rotation variables being set as X rotation variables
- Added fuzzy in center
	- Implemented with a Fuzzy3D object


8/16/11
- Fixed HUD Glitch for main game not displaying buttons properly.
- Work on Redesign of Main Menu
	- MenuCubes are now placed on the X-Z plane
	- MenuCubes auto-lock into position depending on how many cubes there are.
		- the variable circleDivisionNumber must be set in the MenuCube cpp file to match the amount of cubes
		- Boundary Tests for Autosnapping is now automated depending on how many cubes are created!!
	- The theta angle that is used to perform tests is also wrapped, but the calculated values do not.
		- this is OK because it is a double value and will never encounter overflow
	- MenuCubes can now be SWIPED
	- Added Deceleration for Swiping
	- Deleceleration is now speed-sensitive and autosnaps when reaches lower velocity limit, making it more 'crisp'
	- Worked out glitches with MultiTouch functions
		- Re-casted the isTouched1 variable for multitouch to make it work
		- Two-finger taps now do not affect the SWIPE rotations


8/15/11
- Re-implement touch buttons
	- TouchButtons are now more object-oriented
	- TouchButtons now use Sprites to display, and can also be animated
	- The display size and touch size are now independent of each other
	- TouchButtons can now be enabled = true or false
		- enabled controls whether or not isPressed() returns true or false
		- enabled controls whether or not Render() displays the Sprite

- Sprite animations can now be reset for resyncing purposes 

- Tutorial Updated:
	- Rotate Cube and Tap to Drop tutorial levels are now switched
	- Tutorial Sprites are now restarted every time they are activated for button highlight syncing purposes
	- Added a button Highlight for the rotate button
	- Added highlight for Arrows upon tutorial phase completion
	- Triggering of Tutorial Phase Completion is now in place for all tutorial levels

8/14/11
- Fixed Sprites. Added:
	- Sprites can now animate with (but not limited to) gridded textures
	- Sprites now have function to assign ending frame for each animation loop
	- Sprites now can have a maximum repeat count number to be set.
	- Added loopCount variable to determine what loop number the animation is on.

- Tutorial Updated:
	- the Complete Side tutorial sprite now displays 7 frames in a 3x3 png.
	- Now, no more data loss when rendering sprite!

8/13/11
- Finished all tutorial pages
- Traversing through tutorial pages resets spawning of moving cubes according to what each mechanic is.
- Problem:
	- some animation sprites still show vertical line artifact on the first frame
	- not sure how to correct this. Some sprites exhibit this behavior, some don't.
- Discovered/Realized what the Glitch with cubes not warping/off-count was.
	- plane's count was being incremented when it wasn't active: if a red cube touched a red side that was deactivated, but still exploded
	- Actually I am not sure. If a plane's direction and colors are requirements, a cube should not spawn for a plane if it's deactivated.
		- anyway, the safecheck in update should prevent any glitches. It is the most reasonable course of count-checking.
	

8/12/11
- There were some glitches that made planes not warp. Could not repeat.
	- Added a plane.count recalculation in Update() just in case
	- should render all plane.count checking useless, since it's count now depends on how many cubes are at layer level 1
- Fixed lack of rotation for ipod in tutorial
- Tutorial:
	- Added Sprites to tutorial mode to show what to do
	- Added description for each tutorial page
	- Added arrows to traverse through pages

8/11/11
- Started implementing Tutorial mode
- Came up with Animation Sprite ideas to convey Tutorial concepts and mechanics
	- need to mix with text instructions

8/08/11
- Adding pause button
	- freezes all movement
- Just figured out callbacks. This registers functions to be executed whenever a system process is executed.
	- use this to perform things like 
- Took out the Mode Button



8/05/11
- Fixed a highest Layer Level glitch where after stacking up to 3 levels, it warps out after only 2 levels
- Fixed spawning of single cube if one side left to prevent abuse
	- spawn a single cube once. 
	- after that, go back to randomization
	- until a side gets completed
- Fixed glitch of cube falling with droptap speed slows down to slowdrop speed

8/04/11
- Completely re-implemented touch-dragging of shadows
	- extended shadow boundaries
	- When a shadow is touched, it only moves per unit if a deltaX/Y threshold is reached
	- Take into consideration all possiblities of camera rotation for every face and every axis inversion. 
- Disabled zooming.
	- During testing, people tended to accidentally touch screen with two fingers
- Forgot to disable droptap when a cube is moved. Actually, this 
  makes for a better mechanic because it lets for a quick drop if you move fast enough!
	- Nah, change my mind. better fix it.

8/03/11
- Started planning of Tutorial Mode

7/31/11
- new idea with UV animation: make all animations 8x8, and not fill up entirely so to keep same working UVs
- updated MenuCube, TouchButton3D, ActiveSquare object classes to include a Terminate() function and make sure there are no memory leaks
	- the destructor only deletes things if it is a pointer. If an object is not a pointer, it must use Terminate to clear its data.
- added Active Square indicators
	- indicators need to indicate falling cubes, not active sides
	- UPDATE: Now blinking is dynamic, based on whether or not plane is active, and whether or not cube is falling
		- if a plane is Not Active, it will be grayed
		- If a plane is Active, with falling cubes, the square will be blinking
		- If a plane is Active, with NO falling cubes, the square will be colored with darker value
		- Colors fade in and out, from active to non active, vice versa
	- Added color blinking increments to sync with shadow blinking
	- Made blinking colors opaque. Blinking is affected by RGB values, not the alpha value.
- FINALLY FIXED SPAMMING ROTATE BUTTON DURING SPAWN GLITCH. Took like 5 hours. Jeez.
- FIXED the Simultaneous Multi Warp glitch.
	- Multiple cubes can explode, warp, explode and warp with no problems I THINK.
	- Woo hOO!
- FIXED glitch of needing to recalculate layer level for planes when a cube explodes and takes some off a side
- UPDATED slowest blink speed of cubes for levels 3+
	- from 12 to 6
- Added Animation, tweaked a lot of the animation widths downsizing from 128 to 64 pixels
- Edited the Texture directories to access texture folder. 
	- Reduced size of app by 1/2
	- When running in Visual Studio, must have the textures in the data directory, a copy of every file in the texture folder outside in data



7/30/11
- successfully split up loading of MenuData and LevelData
	- game now loads about 5-10 seconds faster
- fixed LifeImage blinking glitch when cubes warp
- need to create loading screen


7/29/11
- screen is now set to Landscape orientation. This is to stop floating objects from going offscreen if screen rotates

7/28/11
- added tapping to make floating objects go poof
- updated increase in drop speed of cubes if they've landed without by tap dropping
- added completion of level only on perfect sideI 

7/25/11
- added 8x8 texture to test in MenuCube. Works, but needed to increase memory

7/13/11
- added spawning of floating object/initialization method.
	- now hits sides and bounces correctly
- added expiration time for EXTRA_LIFE floating object. just need to add in variable in initialize

7/12/11
- worked on implementing FloatingObject

7/02/11
- tried to prevent simul-warp bug, but caused it instead. Also error in closest-cube access when doing single-simul-level warps afterwards...messed up
- reverted to old warping system. Kept the new exploding data structures b/c it seemed to be ok..
- tested:
	- two sides exploding
	- two sides warping // still NOT ok
	- one side exploding, one side warping
	- tested with single level as well as entire

7/01/11
- increase the shadow's touching depth towards the camera to make touching easier
- fix static cubes to be removed only when they are done exploding and there are no other cubes exploding
- also applied this to cubes being warped
	- this applies to cubes warping single level at a time
	- and also to cubes warping a whole side if the win count was reached 
- added smart zoom for if level layer is too high

6/30/11
- Added buttons with images to the Menu Cube
- Added actions to allow them to rotate the cube, and back.
- fixed bug where rotating static cube briefly displays planes that aren't active
- fixed resetting of levels. Now must call Reset() and then InitializeLevel( 1 ) to restart to level 1.
	- this changes the levelNumber variable to 1 for the spawning algorithms
	- added some other variables inside the Reset() and InitializeLevel() method as well.
	- moved all "new" functions from InitializeLevel to Init() so that memory gets allocated only one time.
	- make sure all "new" functions in future only get called during Init() so as to not create memory leak
		- exception are shadow group objects. This was taken care of.
- Further tweaked look of Menu Cube
- Fixed buttons being messed up by zooming. Now should be glitch-free when zooming with fingers moving over buttons

6/29/11
- Created TouchButton3D object to act as buttons on the Menu Cube

6/28/11
- fixed texture transparency. set alpha_mode to default, or use chromakey, and it does work...
- created the Menu Cube

6/27/11
- implemented floating objects 

6/26/11
- desync'd fuzzy animations
- fixed memory leak of fuzzyMaterial attribute of Cube

6/24/11
- Added number of lives to screen. Lives subtract when cubes explode with a fuzzy inside

6/21/11
- Added score to upper left hand corner

6/16/11
- fixed major bugs regarding touching shadow while another cube lands

6/03/11
- Programmed up to Level 3
	- fixed display of transparent shadows. Was missing data structure transfer in removeshadow method

6/02/11
- Updated code in Update() to have subroutines take form of a function activated by boolean.
- Added warping of ALL cubes on same *side of plane if it was the plane's last iteration of completion

5/27/11
- start implementing InitializeLevel() and ResetLevel() methods
	- finished the InitializeLevel() method
	- not created ResetLevel() yet

4/17/11
- start implenting sprites
	- finished. Works great!

4/15/11
- created particle system
	- fixed particle rotation integer division bug by using initialPosition

4/13/11
- start implementation of background objects
	- done
- created background map

4/12/11
- Planned implementation of background objects

4/11/11
- added Plus Point image to cubes when a side is completed / warping out
- added dynamic blinking shadows when they are touched
	- shadows blink brighter and twice as fast when touched

4/10/11
- fixed rotating cubes' interpolation with fuzzies, both static and moving cubes
- fixed autosnapping stalling at corner

4/09/11
- Added fuzzies to cubes

4/08/11
- Made cubes disappear when a plane side is filled with the correct colors
- Fixed other misc. bugsF
	- shadows can not be manipulated if the cubes are dropping or if one cube out of a set has landed
	- cubes cannot be rotated as long as a set of moving cubes is in process of landing
	- fixed bug where plane side did not fill correctly when rotating the static cubes
	- plane side filling should be completely bug-free

4/06/11
- Working on rotating pieces
- Figured out how to load a video
	- this might be easier method to use for menu transitions

3/27/11
- Implemented AutoSnap for cameras

3/25/11
- Implemented registering cubes filling up a plane

3/20/11
- Implementing RotateMovingCubesLeft(), Up(), down()
	- for all axis, and directions, and screen orientation
	- Fixed some camera rotation correction with reversedIndex for camera looking at facesides 5 and 6
- Fixed Boundary limits. PHEW!! took like 2 hours. 
	- Problem: After rotating moving cubes right, boundaries were still a little messed up
		even after creating UpdateBoundary()
	- Solution: Boundaries are actually recalculated when a shadow is let go b/c they 
		are calculated with the shadows' initial position, and the initial position changes after being moved.
		However, in the recalculation when the shadow is let go, it uses the ShadowGroup's direction.
		The Shadow Group's direction was NOT recalculated/reset to new orientation before.
		Fixed this in the Shadow's setDirection() method to include it for its shadow group.

3/19/11
- Implementing RotateMovingCubesRight()
	- Done!
	- Needed to update a lot of things, cubes' directions, shadow's directions, etc.
	- Created UpdateShadowGroupBounds() for boundary testing
	- 

3/18/11
- Added Buttons to rotate things
- Started to implement rotation of static cubes plus the sides
- Implemented RotateStaticCubesRight()
	- Created data structures to rotate the static sides
	- Tweaking of normals so that they behave properly when rotating and after rotated
- Reworked Shadows so that it displays a flat 3d object instead of a 2d plane
- Shadows now blink
- Shadows now have textures
- 

3/15/11
- Added new array to render JUST the cubes that are visible.
	Increased FPS by about 20! Awesome!!!
- Implemented Rendering-by-color-and-material for cubes and shadows. 
	- Needed a ton of new vertex arrays and indexes

3/14/11
- Added Side properties to Cubes, and the vertex data structures so that 
	Cube itself is not rendered but Sides are rendered independently with diff. colors

3/13/11
- Added tap-drop
- fixed shadows moving out of bounds problem
- fixed multiple-shadow select error

2/17/11
- Been planning for Shadows
- Worked on:
	- Set Cube::neighbor1-6 pointers to NULL in destructor
	- Implemented shadows
		Remember that whenever dealing with Linking pointers, if an array gets reassigned
		or pointer gets reassigned, always must re-link. 
		After the removeShadow( index ) method gets called, a re-Link of each cube and shadow
		 is done inside the method of all remaining moving cubes and shadows
	

2/12/11
- Worked on:
	- Fixed the Move()
		- Incoming cubes from All Sides now clamp position correctly on collision.
	- Successfully dynamically removed cubes from moving array to static array on collision.
	- Link() still works, as long as it is being used within the same Array. 
	- Updated the Move() so that the speed has acceleration
		- the speed is now in terms of units per second
		- uses the RATE variable, which is equivalent to FPS - frames per second
		- speed divides by RATE to get units per frame. Set to 30 fps gives units per second
		- Units must be a multiple of RATE b/c of integer division
		- Just increase the side length of objects to get more variance in speeds
		- Works awesome

2/11/11
- Worked on:
	- Linked two cubes as neighbors with linked-list type structure
	- created Cube::updateNetwork() to traverse through every cube
	- created Cube::linkAsNeighbor()
		- made other helper methods
	- Created Link( cube1, cube2 ) to link them


2/10/11
- Worked on:
	- Started planning for Move(), and Link()

2/09/11
- Worked on:
	- Created Pseudo Code for spawning cubes
	- Implemented spawning cubes
	- Cubes spawn according to faceSide, height, and TYPE. - Just awesome.
		- adds to vertex array for moving cubes
		- requires separate draw function right now.
		- later add all the cubes into vertex arrays by material type
		- types to spawn:
			SINGLE, DOUBLE, TRIPLE_CORNER, TRIPLE_LINE, QUAD_T, QUAD_SQUARE
	sweet.

2/08/11
- Worked on:
	- Created the Cube data structure
	- Created initialization of static cubes

- Need:
	- implement shadows
	- implement 3d drop location
	- Picking, move shadow with touch-drag
	- Render cubes by material
	- Spawn Cubes in motion
	- Move, drop, explode Cubes in motion

02/06/11
- Worked on:
	- imported CIwUIElement from UI Builder
	- Applied animations
	- Added Background menu image and Button
	- Button changes images on press
		- make sure to include these in the Assets:
		(data)
		UI.group
		UI.group.bin
		main.ui
		iwui_style/style.group.bin
		./textures

02/04/11
- Worked on:
	- Researched topics:
		- Push Notifications - this is a service used to send data to your device, such as updating something when it's not running
			- Handling from Client Side: Receiving the Push Notification with your device
			- Handling from Provider Side: Sending a Push Notification to update something...need to know how to do this possibly
		- Opening a URL: use s3eExtOSExecAvailable() and s3eExtOSExecExecute()
		- Callbacks: Function pointers used to return a value regardless of where you're calling from or what you're doing
		- iAd - Installing advertisements
		- Consider the Screen Orientation...have option for landscape or portrait.
			- What is the Default?
			- Edit ICP file, or edit with IwGxSetScreenOrient( screenorient i )
- Need:
	- Loading Screens

02/03/11
- Worked on:
	- Fixed everything with rotate and zoom, glitch-free
	- Zoom now has dynamic sensitivity, based on:
		minimum zoom sensitivity
		maximum zoom sensitivity
		Lower Limit of camera depth
		Upper Limit of camera depth
	- Sensitivity is interpolated and applied depending on camera depth

02/02/11
- Worked on:
	- Re-align axis on camera snap
		- camera snap happens on swipe
		and also when autosnaps
	- If no camera snap, do not re-align axis
	- More Zoom fixing, ensuring that it:

		- zooms on 2 touches with drags
		- zooms on 2 touches with single drag
		- zooms on 2 touches with single drag, then single drag with other finger
		- zooms on 2 touches, drag, one touch release, retouch and drag
			- also does rotate on retouch with other finger
		
		- does NOT zoom on 2 touches with no drag
		- does NOT zoom on rotate, release, 2 touches with no drag 
		- does NOT zoom on rotate, 2nd touch with no drag
		- and any other touches where it should NOT zoom
		- has zoom IN/OUT, based on net distance dragged between pinch,
			not sum of dragged X's and Y's

*/

// PROTOTYPE functions
void Init();
bool Update();
void Render();
void ShutDown();
void SpawnMovingCubes( int16 faceSide, int16 cubeSetType, int16 startingHeight );
void SpawnShadows( int16 faceSide, int16 cubeSetType );
void LinkShadowToCube( int16 index );

void UpdateShadow( Shadow *shadow, int16 index);
void UpdateShadowGroupBounds();
void Move( Cube* cube, int16 index );
void MoveShadows( int16 dx, int16 dy ); // move shadows returns a boolean to determine if a shadow was moved: for Tutorial purposes
void Link( Cube* dock, Cube* docker ); // helper method used in Move() This should be obsolete.
int16 min( int16 a, int16 b ); // finds the minimum value. used to calculate the distanceToLanding. helper method in Move(). Not used right now.
int16 max( int16 a, int16 b );
void removeShadow( int16 index );
void removeMovingCube( int16 index );
void removeMovingCubeAndTerminate( int16 index );
void removeStaticCube( int16 index ); // not yet implemented

void dropCubes();
void dropCubesSlow();
void UntouchShadows();
void CreateVertexStream();
void CreateShadowVertexStream();
void CreateSideVertexStream();

// ROTATE MOVING cubes
// with respect to faceside 1 facing camera
void RotateMovingCubesRight(); // positive y axis
void RotateMovingCubesLeft(); // negative y axis
void RotateMovingCubesUp(); // positive x axis
void RotateMovingCubesDown(); // negative x axis
void RotateMovingCubesClockwise(); // positive z axis
void RotateMovingCubesCounterClockwise(); // negative z axis

void ReleaseButtons(); // used in the touch release to activate the correct method
void ReleaseChallengeMenuScreenButtons();
void ReleaseHighScoreMenuScreenButtons();
void ReleaseCreditsMenuScreenButtons();
void ReleaseTutorialMenuScreenButtons();
void ReleaseScoreScreenButtons();
void ReleasePausedButtons();
void ReleaseQuitConfirmationButtons();
void ReleaseNewStoryConfirmationButtons();

void ReleaseDifficultyButtons();
void ReleaseMenuButtons(); // used for menu
void ResetMenuButtonBobble();

// PLANE SIDE SPAWNING
void ActivateOneSide();
void ActivateTwoSides();
void DeactivateSide( int16 i );
void ActivateOneAdjacentSide( int16 b );
int16 getAdjacentDirection( int16 dir );

// ROTATE STATIC cubes
void RotateStaticCubesRight(); // directions are in relation to faceside 1
void RotateStaticCubesLeft();
void RotateStaticCubesUp();
void RotateStaticCubesDown();
void RotateStaticCubesClockwise();
void RotateStaticCubesCounterClockwise();

void ReleaseRotateStaticButtons();

// ROTATE CUBES NO ANIMATION - helper functions of AUTOSNAP functions
void RotateStaticCubesRightNoAnim(); // directions are in relation to faceside 1
void RotateStaticCubesLeftNoAnim();
void RotateStaticCubesUpNoAnim();
void RotateStaticCubesDownNoAnim();
void RotateStaticCubesClockwiseNoAnim();
void RotateStaticCubesCounterClockwiseNoAnim();

void RotateMovingCubesRightNoAnim(); // positive y axis
void RotateMovingCubesLeftNoAnim(); // negative y axis
void RotateMovingCubesUpNoAnim(); // positive x axis
void RotateMovingCubesDownNoAnim(); // negative x axis
void RotateMovingCubesClockwiseNoAnim(); // positive z axis
void RotateMovingCubesCounterClockwiseNoAnim(); // negative z axis

// Initialize Levels
void InitializeLevel( int16 level, int16 phase );
void InitializeMenu();
void InitializeTutorial( int16 tNumber );
void InitializeDifficulty( int16 d );
void TerminateEpisode( int16 e );
void ResetLevel( int16 levelNumber ); // this is obsolete I think

// GameOver functions
void setWhiteFadeIn( uint64 t );
void setWhiteFadeOut( uint64 t );
void setYellowFadeIn( uint64 t );
void setYellowFadeOut( uint64 t );

// Sound Functions
void LoadSoundData();
void TerminateSoundData();
void playLandSound();
int32 resetLandSound(void *systemData, void *userData) ; // reset land sound callback fn
void playWarpSound();
int32 resetWarpSound(void *systemData, void *userData) ; // reset land sound callback fn
void playNotSoGoodWarpSound();
void playPointPerkSound();
void playBoomSound();
void playTestSound();
void playLevelUpSound();
void playLevelCompleteSound();
void playRotateSound();
void playRedButtonSound();
void playBombVoice(); // takes up 4 sound files
void playDeathVoice();bool playedDeathVoiceOnce;
void playLayerLevel3Warning();bool playedLayerLevel3WarningOnce = false;
void playGameOverVoice();bool playedGameOverVoiceOnce;
void playCelebration1();
void playCelebration2();
void playDefusedVoice();
void playGameOverSound();
void playClickSound();
void playPingSound();

int32 checkOutOfLivesGameOver(void *systemData, void *userData);

void lowerVolume();
void raiseVolume();

int32 resetPointPerkSound(void *systemData, void *userData) ; // reset land sound callback fn


// iAd functions
int32 ShowIAD(void *systemData, void *userData);
int32 HideIAD(void *systemData, void *userData);

// QFI Functions
void ResetMultitaskingCurrent();
void ResetMultitasking();
void AddOneAPM();
void ResetCurrentAPM();
void ResetAverageAPM();
void ResetEfficiency();
void ResetEfficiencyCurrent();
void ResetQFIVariables();
void ResetQFIVariablesCurrent();

void ReduceDifficulty();
void IncreaseDifficulty();

void SetTargetPlaneSpawning();
void SetTargetCubeSpawning();

// load functions
void DisplayLoading();
void DisplayLoadingWithoutRefresh();
int32 DisplayLoading( void* systemData, void* userData ); // for timer callback. Not used right now I think.
CIwTexture* DisplayLoading( int16 a );

void LoadSaveFile();
void Save();
void SaveHighStats();
void SaveTutorialPlayed();
void SaveTargetEpisode(); // for restarting an episode
void LoadBackgroundAndOtherInit();
void LoadMenuData();
void TerminateMenuData();
void LoadLevelData();
void TerminateLevelData();
void LoadTutorialData();
void TerminateTutorialData();

int32 triggerTitle( void* systemData, void* userData ); // trigger title callback
bool triggeredTitleCallback = false;

int32 triggerLoading( void* systemData, void* userData ); // trigger title callback
bool triggeredLoadingCallback = false;

int32 loadingMenuCallback( void* systemData, void *userData );
bool triggeredLoadingMenuCallback = false;

// tutorial functions
int32 triggerShowTutorialTouchDrag( void *systemData, void *userData );
bool triggeredShowTutorialTouchDrag = false;
int32 triggerHideTutorialTouchDrag( void *systemData, void *userData );
bool triggeredHideTutorialTouchDrag = false;

int32 triggerShowTutorialTapDrop( void *systemData, void *userData );
bool triggeredShowTutorialTapDrop = false;
int32 triggerHideTutorialTapDrop( void *systemData, void *userData );
bool triggeredHideTutorialTapDrop = false;

int32 triggerShowTutorialRotate( void *systemData, void *userData );
bool triggeredShowTutorialRotate = false;
int32 triggerHideTutorialRotate( void *systemData, void *userData );
bool triggeredHideTutorialRotate = false;

int32 triggerShowTutorialShift( void *systemData, void *userData );
bool triggeredShowTutorialShift = false;
int32 triggerHideTutorialShift( void *systemData, void *userData );
bool triggeredHideTutorialShift = false;
int32 triggerTutorialShiftEnable( void *systemData, void *userData );


int32 triggerShowTutorialDragSpace( void *systemData, void *userData );
bool triggeredShowTutorialDragSpace = false;
int32 triggerHideTutorialDragSpace( void *systemData, void *userData );
bool triggeredHideTutorialDragSpace = false;

int32 triggerShowTutorialCompleteSide( void *systemData, void *userData );
bool triggeredShowTutorialCompleteSide = false;
int32 triggerHideTutorialCompleteSide( void *systemData, void *userData );
bool triggeredHideTutorialCompleteSide = false;

int32 triggerShowTutorialPerfectClear( void *systemData, void *userData );
bool triggeredShowTutorialPerfectClear = false;
int32 triggerHideTutorialPerfectClear( void *systemData, void *userData );
bool triggeredHideTutorialPerfectClear = false;
int32 triggerTutorialPerfectClearEnable( void *systemData, void *userData );
bool enableTutorialPerfectClear;


int32 triggerShowTutorialDefuseBomb1( void *systemData, void *userData );
bool triggeredShowTutorialDefuseBomb1 = false;
int32 triggerHideTutorialDefuseBomb1( void *systemData, void *userData );
bool triggeredHideTutorialDefuseBomb1 = false;

int32 triggerShowTutorialDefuseBomb2( void *systemData, void *userData );
bool triggeredShowTutorialDefuseBomb2 = false;
int32 triggerHideTutorialDefuseBomb2( void *systemData, void *userData );
bool triggeredHideTutorialDefuseBomb2 = false;

int32 triggerShowTutorialDoNotDie( void *systemData, void *userData );
bool triggeredShowTutorialDoNotDie = false;
int32 triggerHideTutorialDoNotDie( void *systemData, void *userData );
bool triggeredHideTutorialDoNotDie = false;

int32 triggerShowTutorialMatchColors( void *systemData, void *userData );
bool triggeredShowTutorialMatchColors = false;
int32 triggerHideTutorialMatchColors( void *systemData, void *userData );
bool triggeredHideTutorialMatchColors = false;

int32 triggerShowTutorialDoNotStack( void *systemData, void *userData );
bool triggeredShowTutorialDoNotStack = false;
int32 triggerHideTutorialDoNotStack( void *systemData, void *userData );
bool triggeredHideTutorialDoNotStack = false;
int32 triggerTutorialDoNotStackEnable( void *systemData, void *userData );
bool enableTutorialDoNotStack = false;

// convert integer to cstring
char* intToChar( int n );
char* levelToCstring( int ep, int lvl );

// for splash screen
bool triggeredSplash = false;

void LoadBigImages();
void LoadSmallImages();

// Condition for axis rotation methods
int16 getActiveFaceSide();
// Generate adjacent side
int16 generateAdjacentDirection( int16 dir );

CIwVec3 CrossProduct( CIwVec3 a, CIwVec3 b ); // used to find the normal

// GAME MODE AND GAMEPLAY METHODS
void SpawnMovingSets(); // will use enum{ PLAY_GAME} and {DIFF_LEVEL1}
void SpawnCubesAndShadows( int16 faceSide, int16 height, int16 type, int16 material, int16 speed, int16 oneInXChance ); // helper method



void ShakeCamera();
void ShakeCameraMedium();
void ShakeCameraGigantic();
void SwayCamera(); // for losing a cube

// AUTOSNAP functions
void AutoSnap();
void ResetAutoSnapVariables();
void SnapToFaceSide1();
void SnapToFaceSide2();
void SnapToFaceSide3();
void SnapToFaceSide4();
void SnapToFaceSide5();
void SnapToFaceSide6();

void CorrectAutoSnap();

void SwipeToFaceSide1();
void SwipeToFaceSide2();
void SwipeToFaceSide3();
void SwipeToFaceSide4();
void SwipeToFaceSide5();
void SwipeToFaceSide6();

void CheckAndWarpCubes();
void CheckAndExplodeCubes();

// Reversed Index correction
void CorrectReversedIndex();



// TOUCH1 functions
void MultiTouchButton( s3ePointerTouchEvent* );
void SingleTouchButton( s3ePointerTouchEvent* );
void MultiTouchMotion( s3ePointerTouchMotionEvent* );
void SingleTouchMotion( s3ePointerMotionEvent* ); // this input is DIFFERENT


// RESET functions
void ResetScoreAndLives();
void Reset();

// ROTATE CUBES ON SURFACE functions
void RotateActiveShadows();

void TouchShadow();

// Shadow Blinking
void UpdateShadowBlinking();

// SCORE
void UpdateScore();
void addScore( int n );
void showAndPlayScore();
void showAndPlayFuzziness();
void showAndPlaySkillTitle();

int32 setShowScore( void* systemData, void* userData );
int32 setShowFuzziness( void* systemData, void* userData );
int32 setShowSkillTitle( void* systemData, void* userData );
int32 triggerGameOver( void *systemData, void *userData );

// callback functions to trigger displaying of pixie dust in score screen
int32 setShowPixie1( void* systemData, void* userData );
int32 setShowPixie2( void* systemData, void* userData );
int32 setShowPixie3( void* systemData, void* userData );

// CALLBACKS
int32 PauseCallbackReceived( void* systemData, void* userData );

// Timer
int32 AllowCinemaSkip(void *systemData, void *userData);




// VARIABLES------------

int32 width;
int32 height;

CIw2DImage *splashImage;
Sprite splashSprite;

CIw2DImage *titleImage;
Sprite titleSprite;

// developer variables
bool musicOn = false;

SaveFile saveFile;
string savedData;
string currentData;
int versionNumber;

bool loweredVolume = false;

// Story Mode variables
bool storyMode = false;
bool advanceToNextLevel = false;
const int16 MAX_LEVELS = 10;
int16 storyModeRequiredDrops[MAX_LEVELS];
int16 storyLevelNumOfCompletionDrops = 150;
int16 storyModeTotalDropsCurrent = 0;
int16 episode = 1;
int16 targetEpisode = 1;
int16 ep4RotateCounter = 0;
bool gameOver;
bool playingStory = false;
bool savedAtScoreScreen;
bool playedFirstInterimCinematic;
bool playedSecondInterimCinematic;
bool startAtCheckpoint;

Sprite pixieSprite[3];
CIw2DImage *pixieImage;
bool showPixieDust[3];

double percentComplete;

// Tutorial Messages
const int NUM_OF_TUTORIAL_MESSAGES = 12;
Sprite tutorialSprites[NUM_OF_TUTORIAL_MESSAGES];
CIw2DImage *tutorialImages[NUM_OF_TUTORIAL_MESSAGES];
bool showTutorialSprites[NUM_OF_TUTORIAL_MESSAGES];
bool setShowTutorialSprites[NUM_OF_TUTORIAL_MESSAGES];

int numOfTutorialDropsCurrent;
int numOfTutorialRotates;
int tutorialBombDefuseCount; // for tutorial
int tutorialDragSpaceCount;
bool tutorialDragSpaceShown; // this is restriction to only increment dragSpaceCount if message was shown at least once
int tutorialPlaneShiftCount;
bool tutorialShiftEnable;
bool enableFirstSpawning;

int tutorialZeroAlpha = 0;
int tutorialMaxAlpha = 190;
int tutorialInterpolationTime = 1000;

// episode 3 particle system
WindSystem windSystem;
double rumbleX = 0.0;
double rumbleY = 0.0;
double rumbleZ = 0.0;
double rumbleAngleX = 0.0;
double rumbleAngleY = 0.0;
double rumbleAngleZ = 0.0;
int16 rumbleAmplitude = 4; // old was 10 and 5  
double rumbleSpeed = 2; // smaller is faster, bigger is slower
CIwMat rumbleMatrix; // for the main cube

// Combo Perk variables
bool perfectWarped = false; // this helps determine whether or not the perfectWarpCounter should increase
bool checkPerfectWarped = false; // this determines whether or not perfectWarped should be checked
int16 perfectWarpCount = 0;


// font
CIwGxFont *hobo16;
CIwGxFont *hobo32;
CIwGxFont *ocr20;

// score screen
Sprite scoreScreenSprite;
CIw2DImage *scoreScreenImage;
bool showScore = false;
bool showFuzziness = false;
bool showSkillTitle = false;

Sprite gameOverSprite;
CIw2DImage *gameOverImage;

bool showGameOver = false;

// Transition object
TransitionObject transitionObject;
bool allowCinemaSkip;
bool stopCinema = false;

// white overlay for gameover
Sprite whiteOverlaySprite;
CIw2DImage *whiteOverlayImage;
Sprite yellowOverlaySprite;
CIw2DImage *yellowOverlayImage;

int16 TransitionState = 0;
enum{ LIMBO, 
	START_GAME, END_GAME_LOSE, END_GAME_WIN, LOAD_LEVEL, LOAD_MENU};


// Challenge Mode variables
bool challengeMode = false;
int16 cmNumOfRequiredDrops[20];
int16 cmSpeedLevel = 1;
int16 cmDifficultyLevel = 1;

// Developer variables
bool developerLevels = false;

// Sound variables
const int16 numOfSoundElements = 22;
int16* soundBuffer[numOfSoundElements+1]; // this is pointer to the location of sound data
int32 soundFileSize[numOfSoundElements+1]; // this is variable that holds the size info of each sound file
int soundChannel[numOfSoundElements+1]; // this is ID of the free channel, found with getFreeChannel
bool soundIsPlaying[numOfSoundElements+1]; // bool to let us know if sound is playing? may not be used

// iAd variables
bool iAdOn = false;
bool hasIAd = false;
bool showingIAd = false;
bool hasAdWhirl = false;
bool hasFlurry = false;
char timedEvent[50]="";

// QFI variables
bool qfiMode = false;
int16 qfiDifficultyCap; // this caps the max difficulty of QFI. initialized at loadlevel

double efficiencyIndex; // eI = scoredDrops / totalDrops. 
int16 scoredDrops;		// Convert both to double on calculation
int16 totalDrops;

double efficiencyIndexCurrent;
int16 scoredDropsCurrent;
int16 totalDropsCurrent;

// the cumulative variables are used for end-game statistics to calculate skill level
double multitaskingIndex;
double totalDTL;
double averageDTL;  // the DTL's are actually values of the DTL divided by s to prevent overflow of totalDTL
int16 totalDroppedCubeSets;

// the current variables are used for level progression/regression
double multitaskingIndexCurrent;
double totalDTLCurrent;
double averageDTLCurrent;  // the DTL's are actually values of the DTL divided by s to prevent overflow of totalDTLCurrent
int16 totalDroppedCubeSetsCurrent;

int16 startingHeight;

double skillIndex; // (performanceIndex + apm) / 2
double performanceIndex; // performanceIndex is now the old skill index
double skillIndexRatio;

double skillIndexCurrent;
double performanceIndexCurrent;

double panicLimit;
double comfortIndex;
double comfortIndexCurrent;

// these are not used
int16 idleCounter = 0;
double averageAPMCurrent = 0;
int16 totalActionsCurrentForAverage = 0;


// time intervals are used for instantaneous/current APM
uint64 apmInterval = 1; // for some reason, starting at 0 crashes on android device
uint64 apmIntervalTime0 = 1;
uint64 apmIntervalTime1 = 1;

// average apm
double uAPMInstantaneous = 0;
uint64 apmInstantaneousTime = 1;
uint64 apmMilliInstantaneous = 1; // if 0 crashes

double uAPMCurrent;
double uAPMMilliCurrent;
int16 totalActionsCurrent = 0;
uint64 apmTime1Current = 0; // this is the actual current time stamp, 
uint64 apmTime0Current = 0; // this is the starting time
uint64 apmTotalTimeCurrent = 0; // this is more like the current time interval, or delta T, used in apm calculation
uint64 apmTotalTimeSavedCurrent = 0;

double uAPM;
double uAPMMilli;
uint64 totalActions = 0;
uint64 apmTime1 = 0;
uint64 apmTime0 = 0;
uint64 apmTotalTime = 0;
uint64 apmTotalTimeSaved = 0;

// variables for the algorithm
int16 numOfDrops; // records how many drops in between each difficulty transition. May not be used. use TotalDropsCurrent instead
int16 totalDropsInFlowState;
int16 numOfDropsRequired = 5;
double upperFlowBound;
double lowerFlowBound;
bool inFlowState = false;
int16 difficulty = 1;
int16 targetDifficulty = difficulty;
int16 targetPlaneSpawning;
int16 targetCubeSpawning;
bool checkPerformance = false;
bool targetDifficultyReached = true;
bool increasedASide = false; // used to make sure algorithm for normal plane spawning in checkandwarp is not run if QFI spawned a planeside
bool decreasedASide = false;

/*
difficulty  planeSpawn  cubeSpawn
1			SINGLE_RAN	SINGLE_RAN
2			DOUBLE_ADJ	SINGLE_RAN
3			DOUBLE_ADJ	DOUBLE_INC
4			DOUBLE_RAN	DOUBLE_RAN
5			TRIPLE_RAN	DOUBLE_RAN
6			QUAD_RAN	DOUBLE_RAN
7			TRIPLE_RAN	TRIPLE_INC
8			TRIPLE_RAN	TRIPLE_RAN
9			QUAD_RAN	TRIPLE_RAN
10			QUIN_RAN	TRIPLE_RAN
11			SEXTUP_RAN	TRIPLE_RAN
12			QUAD_RAN	QUAD_INC
13			QUAD_RAN	QUAD_RAN
14			QUIN_RAN	QUAD_RAN
15			SEXTUP_RAN	QUAD_RAN
16			QUIN_RAN	QUIN_INC
17			QUIN_RAN	QUIN_RAN
18			SEXTUP		QUIN_RAN
19			SEXTUP		SEXTUP_INC
20			SEXTUP		SEXTUP_RAN
*/

// the enumerations for cube Spawning and Planeside Spawning
enum{
	// for just cubes
	DOUBLE_INCOLOR, TRIPLE_INCOLOR, QUADRUPLE_INCOLOR, QUINTUPLE_INCOLOR, SEXTUPLE_INCOLOR, SEXTUPLE_RANDOM,
	// for just planes
	DOUBLE_ADJACENT, SEXTUPLE,
	// for both planes and cubes
	SINGLE_RANDOM, DOUBLE_RANDOM, TRIPLE_RANDOM, QUADRUPLE_RANDOM, QUINTUPLE_RANDOM};

int16 planeSpawning = TRIPLE_RANDOM;
int16 cubeSpawning = DOUBLE_RANDOM;


// GAME PLAY
enum{ DIFF_LEVEL1, DIFF_LEVEL2, DIFF_LEVEL3, DIFF_LEVEL4, DIFF_LEVEL5 };
uint64 SpawnTime0 = 0;
uint64 SpawnTime1 = 0;

// SCORE variables
Sprite minusOneFuzzySprite[6][9]; // double array, 6 sides, 9 sprites total for each side
CIw2DImage *minusOneFuzzyImage;
bool minusOneFuzzy[6][9];

Sprite plusOneFuzzySprite;
CIw2DImage *plusOneFuzzyImage;
bool showPlusOneFuzzy = false;

int timeFrames = 0;
int timeSeconds;
int timeMinutes;
int timeHours;

int ep3Frames;
int ep3Seconds;
int ep3Minutes;
bool ep3TimerStart;

long score = 0;
long highScore = 0;
long scoreLivesBonusBucket = 0;
PointSprite pointSprites[7][4]; // double array, 6 sides, 4 sprites total for each side
CIw2DImage* pointImage50;
CIw2DImage* pointImage500;
CIw2DImage* pointImage5000;
CIw2DImage* pointImage100;
CIw2DImage* pointImage1000;
CIw2DImage* pointImage10000;
bool addPoints[6][4] = { {false, false, false, false}, 
						{false, false, false, false}, 
						{false, false, false, false}, 
						{false, false, false, false}, 
						{false, false, false, false}, 
						{false, false, false, false} };

// Congratulations Variables

bool levelUp;
Sprite congratsSpriteLevelUp;
CIw2DImage *congratsImageLevelUp;
bool showCongratsSpriteLevelUp = false;

Sprite congratsSpriteSuper;
CIw2DImage* congratsImageSuper;
bool showCongratsSpriteSuper = false;
Sprite congratsSpriteGreat;
CIw2DImage* congratsImageGreat;
bool showCongratsSpriteGreat = false;
Sprite congratsSpriteNice;
CIw2DImage* congratsImageNice;
bool showCongratsSpriteNice = false;
Sprite congratsSpriteComplete;
CIw2DImage* congratsImageComplete;
bool showCongratsSpriteComplete = false;

// reset plane count variable
bool resetPlaneCount = false;

// telling when a cube is spawning
bool isSpawning = false;
bool allCubesHaveMovedOnce = false;
int16 spawningSetCounter = 0;
bool completeComplete = false;

// MENU CUBES
const int NUM_OF_MENU_CUBES = 6;
MenuCube menuCubes[NUM_OF_MENU_CUBES];
int numOfActiveMenuCubes;

MenuScreen questionMarkScreen;
bool showQuestionMarkScreen = false;

MenuScreen challengeMenuScreen;
const int NUM_OF_MENU_SCREENS = 4;
MenuScreen menuScreen[NUM_OF_MENU_SCREENS];
const int NUM_OF_TROPHIES = 5;
bool trophies[NUM_OF_TROPHIES];
char trophyCString[200]; // this is the description of how to get the trophies
Sprite trophyMessageSprite;

const int NUM_OF_TROPHY_MESSAGE_IMAGES = 11;
CIw2DImage *trophyMessageImage[NUM_OF_TROPHY_MESSAGE_IMAGES];

bool showTrophyMessage;
Sprite trophyMessageBackgroundSprite;
CIw2DImage *trophyMessageBackgroundImage;

Sprite trophySprite;
CIw2DImage *trophySpriteImage;
bool showTrophySprite = false;

Fuzzy3D Bubbly;
Sprite menuTitleSprite;
CIw2DImage* menuTitleImage;
Sprite menuTitleSprite2;
CIw2DImage* menuTitleImage2;
CIw2DImage *menuTitleImage3;
Sprite menuTitleSprite3;

CIw2DImage *menuTitleImage4;
Sprite menuTitleSprite4;

CIwResGroup* menuDataGroup;

CIw2DImage* swipeArrowsImage;
Sprite swipeArrowsSprite;
CIw2DImage *swipeGlowImage;

CIw2DImage *swipeArrowsImages[4];
Sprite swipeArrowsSprites[4];

bool multiTouchDisableMenu = false;

// LOAD MENU DATA
bool levelDataLoaded = false; // this used to keep track of texture loading for level 1
bool tutorialDataLoaded = false; // this is not used I think
bool menuDataTerminated = true;
bool splashAndTitleTerminated = false;
bool levelDataTerminated = false;

bool playedHowToTutorialOnce;
bool playingHowToTutorial;

bool playedBombTutorialOnce;
bool playingBombTutorial;

bool playedWarningTutorialOnce;
bool playingWarningTutorial;

bool playingRapVideoFromMenu = false;

bool playingTutorialHowToFromMenu = false;
bool playingTutorialWarningsFromMenu = false;
bool playingTutorialBombFromMenu = false;
bool playedTutorialAtMenu = false;

// Background sphere
CIwModel* sphere;
CIwModel*	s_Model;
CIwModel *sphere2;
CIwModel *sphere3;
CIwModel *sphere4;
CIwModel *sphere5;
CIwModel *sphere6;

bool sphereLoaded[6] = {false, false, false, false, false, false};

//CIwModel* redCube;

// Active square indicators
ActiveSquare blueSquare, redSquare, purpleSquare, orangeSquare, greenSquare, yellowSquare;

// Layer levels
bool recalculateLayerLevels = false; // for calculating planes' layer levels after explode


// Background Stars
vector<BackgroundObject> stars;
const int NUM_STAR_TEXTURES = 7;
CIwMaterial *starMaterial[NUM_STAR_TEXTURES];
CIwTexture *starTexture[NUM_STAR_TEXTURES];

int16 starsIndex;
const int16 numStars = 200;
CIwSVec3 starsVertexStream[numStars * 4] = {};
CIwSVec3 starsEp4VertexStream1[numStars / 4 * 4] = {};
CIwSVec3 starsEp4VertexStream2[numStars / 4 * 4] = {};
CIwSVec3 starsEp4VertexStream3[numStars / 4 * 4] = {};
CIwSVec3 starsEp4VertexStream4[numStars / 4 * 4] = {};

CIwSVec2 starsEp4UVStream[ numStars / 4 * 4] = {};

CIwSVec3 starsNormalStream[numStars * 4] = {};
CIwSVec2 starsUVStream[numStars * 4] = {};
int16 starRotationDelayTime = 0;
int16 starRotationCounter = 0;

// shaking camera
bool shakeCamera = false;
int16 shakeCounter = 0;

bool shakeCameraMedium = false;
int16 shakeCounterMedium = 0;

bool shakeCameraGigantic = false;
int16 shakeCounterGigantic = 0;

bool swayCamera = false;
int16 swayCounter = 0;


// autosnap feature
bool autosnap = false;
bool autosnap_firstIterationFinishedX = false;
bool autosnap_subtractingX = false;
bool autosnap_firstIterationFinishedY = false;
bool autosnap_subtractingY = false;
bool autosnap_finishedX;
bool autosnap_finishedY;
int16 dof = 0; // degree of freedom for camera autosnapping
int16 autosnap_firstSnapIncrement = 80; // for F 25, this is 40, original 80
int16 autosnap_secondSnapIncrement = 60; // for RATE = 25, this is 30, original 60
int16 autosnap_thirdSnapIncrement = 40; // for RATE = 25, this is 20, original 40
bool correctAutoSnap = false; 
bool enableCorrectAutoSnap = false;
int16 autoSnapCounter = 0;
bool useRegularTT1 = true;

// lighting
bool lighting = true;
CIwSVec3 lightDir( 1, 1, 1 );

// TIME
uint64 GameTime = 0;
uint64 GameTime1 = 0;
uint64 RenderTime = 0;
uint64 RenderTime1 = 0;
uint64 RealTime = 0;
uint64 RealTime1 = 0;

// UI1 variables

enum { 
	AT_BLACK_SCREEN,
	AT_SPLASH,
	AT_TITLE,
	AT_SCORE_SCREEN,
	AT_CHALLENGE_MENU_SCREEN,
	AT_HIGH_SCORE_MENU_SCREEN,
	AT_CREDITS_MENU_SCREEN,
	AT_TUTORIAL_MENU_SCREEN,
	CHOOSE_DIFFICULTY,
	AT_DISPLAY_LOADING_BACKGROUND,
	AT_LOADING_BACKGROUND,
	AT_DISPLAY_MENU_TRANSITION, 
	AT_DISPLAY_LOADING_MENU,
	AT_LOADING_MENU,
	AT_MENU, 
	AT_LOADING_LEVEL, 
	PLAY_GAME, 
	PLAY_CINEMATIC,
	GAME_OVER, 
	PAUSED,
	PAUSED_TUTORIAL,
	AT_DISPLAY_LOADING_TUTORIAL,
	AT_LOADING_TUTORIAL,
	PLAY_TUTORIAL };
int16 GameState = AT_DISPLAY_MENU_TRANSITION;
int16 TargetState = GameState;
bool limbo = false;
bool transition;
bool transitionIsSet = false;
bool renderTransition = false;

int16 levelNumber = 1;
int16 phaseNumber = 3;

// Tutorial Variables
bool atTutorial = false; // this is for game pausing
int16 tutorialNumber = 1;
int16 tutorialSpawnNumber = 1;
Sprite tutorialTouchDragSprite; // TOUCH DRAG
CIw2DImage* tutorialTouchDragImage; 
Sprite tutorialTapDropSprite;  // TAP DROP
CIw2DImage* tutorialTapDropImage;
Sprite tutorialRotateCubeSprite; // ROTATE CUBE
CIw2DImage* tutorialRotateCubeImage;
Sprite tutorialCompleteSideSprite; // COMPLETE SIDE
CIw2DImage* tutorialCompleteSideImage;
Sprite tutorialRotateCameraSprite; // ROTATE CAMERA
CIw2DImage* tutorialRotateCameraImage;
Sprite tutorialFlipCubeSprite; // FLIP CUBE
CIw2DImage* tutorialFlipCubeImage;

Sprite tutorialRotateButtonHighlightSprite; // ROTATE BUTTON HIGHLIGHT
CIw2DImage* tutorialRotateButtonHighlightImage;
bool tutorialRotateButtonHighlightEnabled = false;

Sprite tutorialRightButtonHighlightSprite; // TUTORIAL RIGHT BUTTON HIGHLIGHT (upon completion of phase)
CIw2DImage* tutorialRightButtonHighlightImage;
bool tutorialRightButtonHighlightEnabled = false;

// tutorial variables for determining if a level is passed.
// This triggers ONLY the arrow highlight for next tutorial, and also interjection display
bool tutorialTouchDragPassed = false;
bool tutorialRotateCubePassed = false;
bool tutorialTapDropPassed = false;
bool tutorialCompleteSidePassed = false;
bool tutorialRotateCameraPassed = false;
bool tutorialFlipCubePassed = false;
bool tutorialCompleteSide2Passed = false;

//int16 GameState = SHOW_UI;

// Debug variables
int16 seconds = 0;

// TRANSFORM1 variables
CIwMat tt1; // the world transform matrix. Name came from first prototype app, somehow...
CIwMat modelMatrix1;
CIwMat rotX, rotY;
CIwMat bobbleMatrix; // the bobble rotation transformation matrix of static cubes
CIwMat bobbleMatrixStars; // bobble rotation transformation for stars. This and background is just a scaled down rotation of bobbleMatrix
CIwMat bobbleMatrixBackground; // bobble rotation for background

CIwMat bobbleRotX, bobbleRotXStars, bobbleRotXBackground, bobbleRotXMenu; // the horizontal rotation of bobble for cubes, stars, and background
CIwMat bobbleRotY, bobbleRotYStars, bobbleRotYBackground, bobbleRotYMenu; // the vertical rotation of bobble
CIwMat bobbleRotZ, bobbleRotZStars, bobbleRotZBackground, bobbleRotZMenu;
double bobbleX = 0.0; // controls the rotation value of bobbling
double bobbleY = 0.0; // initial offsets of angles used to simulate random rotation while bobbling since they hit the same limits
double bobbleZ = 0.0;
double bobbleAngleY = 0;
double bobbleAngleX = 0.0;
double bobbleAngleZ = 0.0;
int16 bobbleRateX = 1; // controls whether the bobbling is increasing or decreasing
int16 bobbleRateY = 1;
int16 bobbleRateZ = 1;
int16 highestLayerLevel = 0; // this is the highest layer level of cubes stacked on
bool zoomDownCheck = false; // this is used to check to adjust camera zoom only if highest level layer goes from 3 to 2 or 2 to 3
int16 bobbleLimit = 40;
double bobbleSpeed = 96;// smaller is faster, bigger is slower. This is being used to divide PI to get the angle

// these are the sway variables for main cube translation, or "swaying", in episode 3
double swayX = 0.0;
double swayY = 0.0;
double swayZ = 0.0;
double swayAngleX = 0.0;
double swayAngleY = 0.0;
double swayAngleZ = 0.0;
int16 swayAmplitude = 400;
double swaySpeed = 96; // smaller is faster, bigger is slower
CIwMat swayMatrix; // for the main cube
CIwMat fallMatrix;// y-coordinate translation matrix for the background, giving illusion of "falling"

// CUBE ROTATION variables
CIwMat srm; // static rotation matrix
int16 deltaYStaticRotation = 256;
int16 deltaYMovingRotation = 256;
int16 cumulativeDeltaYRotation = 0;

bool movingCubesAreRotating = false;
bool staticCubesAreRotating = false;

// used to determine what rotation mode is active
bool rotateMovingCubes = true;

bool rotateMovingVerticesRight = false;
bool rotateMovingVerticesRight_firstIterationFinished = false;

bool rotateMovingVerticesLeft = false;
bool rotateMovingVerticesLeft_firstIterationFinished = false;

bool rotateMovingVerticesUp = false;
bool rotateMovingVerticesUp_firstIterationFinished = false;

bool rotateMovingVerticesDown = false;
bool rotateMovingVerticesDown_firstIterationFinished = false;

bool rotateMovingVerticesClockwise = false;
bool rotateMovingVerticesClockwise_firstIterationFinished = false;

bool rotateMovingVerticesCounterClockwise = false;
bool rotateMovingVerticesCounterClockwise_firstIterationFinished = false;

bool rotateStaticVerticesRight = false;
bool rotateStaticVerticesRight_firstIterationFinished = false;

bool rotateStaticVerticesLeft = false;
bool rotateStaticVerticesLeft_firstIterationFinished = false;

bool rotateStaticVerticesUp = false;
bool rotateStaticVerticesUp_firstIterationFinished = false;

bool rotateStaticVerticesDown = false;
bool rotateStaticVerticesDown_firstIterationFinished = false;

bool rotateStaticVerticesClockwise = false;
bool rotateStaticVerticesClockwise_firstIterationFinished = false;

bool rotateStaticVerticesCounterClockwise = false;
bool rotateStaticVerticesCounterClockwise_firstIterationFinished = false;

// CUBE1 variables
// vertex cache limit is 2048 vertices
// that accounts to about 85 cubes per vertex stream
// length * width * height must not surpass 85
const int16 numCubesLength = 3; // these determine how many cubes spawn to generate static rubix in center
const int16 numCubesWidth = 3;
const int16 numCubesHeight = 3;
const int16 numShadows = 200;
int16 numShadowsIndex = 0;
const int16 numMovingCubes = 900; // total memory to allocate for moving cubes
int16 numMovingCubesIndex = 0; // the current counter of number of moving cubes createdplaneTemp[i].direction = plane[i].direction; // assignment operator does not copy direction
int16 numMovingSets = 0;
const int16 numCubes = numCubesLength * numCubesWidth * numCubesHeight + numMovingCubes; // number of cubes total
int16 numStaticCubes = numCubesLength * numCubesWidth * numCubesHeight;
int16 numOriginalCubes = numCubesLength * numCubesWidth * numCubesHeight;
int16 numLandedCubes = 0;
const int16 numStaticSides = (numCubesWidth * numCubesLength) + (numCubesWidth * numCubesHeight) + (numCubesLength * numCubesHeight);
int16 numStaticSides1Index;
int16 numStaticSides2Index;
int16 numStaticSides3Index;
int16 numStaticSides4Index;
int16 numStaticSides5Index;
int16 numStaticSides6Index;

// TOUCH1 variables
bool hasMultiTouch = false;
bool isTouched; // for single touch
bool isTouched1; // for multi touches 1 and 2
bool isTouched2;
bool isSimulTouched = false;
bool rotateEnabled = false;;
bool zoomEnabled = false;
bool zooming = false;
bool touchMusic;
bool dropTap = false;
bool cubeIsDropping = false;
uint64 initialTapMS;
uint64 deltaTapMS;
int16 x1, y1; // multi touch x and y's. For single touch, use x1
int16 x2, y2;
int16 deltaX1, deltaY1; // delta X's and Y's. Once again, for single touch use x1
int16 deltaX2, deltaY2;
int16 motionX1, motionY1;
// used to determine swipeVelocity for deceleration on swipe
int16 deltaX1Two;
int16 swipeVelocity;
int16 swipeVelocityDelayCounter = 0;

// Shadow Blinking
// Shadows
int16 lowerLimit = 20;
int16 upperLimit = 100;
int16 upperLimitAddon = 105;

// Loading Screens
Sprite loadingScreen;
CIw2DImage* loadingImage;
Sprite loadingIconSprite;
CIw2DImage* loadingIconImage;

Sprite fuzzyFactsSprites[3];
CIw2DImage *fuzzyFactsImages[3];

Sprite loadingMenuTransition;
CIw2DImage* loadingMenuImage;
int16 menuCounter = 0;

// SPRITES
Sprite testSprite;
CIw2DImage* testSpriteImage;

Sprite livesSprite;
CIw2DImage* livesImage;
int16 numOfLives;

Sprite progressBarFuzzySprite;
Sprite progressBarGlowSprite;
CIw2DImage *progressBarGlowImage;

CIw2DImage *spacebusImage;

Sprite progressBarSprite;
CIw2DImage* progressBarImage;

Sprite progressBarFrameSprite;
CIw2DImage* progressBarFrameImage;

// FLOATING OBJECTS
FloatingObject testFO;
CIw2DImage* testFOImage;

// BUTTON IMAGES
TouchButton tutorialRightButton;
Sprite tutorialRightButtonSprite;
Sprite tutorialRightButtonSprite_pressed;
CIw2DImage* tutorialRightButtonImage;
CIw2DImage* tutorialRightButtonImage_pressed;

TouchButton tutorialLeftButton;
Sprite tutorialLeftButtonSprite;
Sprite tutorialLeftButtonSprite_pressed;
CIw2DImage* tutorialLeftButtonImage;
CIw2DImage* tutorialLeftButtonImage_pressed;

// Pause and Menu Screen buttons
Sprite pausedBackgroundSprite;
CIw2DImage* pausedBackgroundImage;

// Pause Screen buttons
TouchButton pauseButton;
Sprite pauseButtonSprite;
Sprite pauseButtonSprite_pressed;
CIw2DImage* pauseButtonImage;
CIw2DImage* pauseButtonImage_pressed;

TouchButton resumeButton;
Sprite resumeButtonSprite;
Sprite resumeButtonSprite_pressed;
CIw2DImage* resumeButtonImage;
CIw2DImage* resumeButtonImage_pressed;

TouchButton quitButton;
Sprite quitButtonSprite;
Sprite quitButtonSprite_pressed;
CIw2DImage* quitButtonImage;
CIw2DImage* quitButtonImage_pressed;

TouchButton restartButton;
Sprite restartButtonSprite;
Sprite restartButtonSprite_pressed;
CIw2DImage* restartButtonImage;
CIw2DImage* restartButtonImage_pressed;

// Quit confirmation menu screen
MenuScreen quitConfirmationScreen;
bool enableQuitConfirmationScreen = false;

// newStory confirmation
MenuScreen newStoryConfirmationScreen;
bool enableNewStoryConfirmationScreen = false;

//TouchButton nextButton;
TouchButton nextButton;
Sprite nextButtonSprite;
Sprite nextButtonSprite_pressed;
CIw2DImage* nextButtonImage;
CIw2DImage* nextButtonImage_pressed;

// Difficulty Selection Buttons
TouchButton difficultyStartButton;
Sprite difficultyStartSprite;
Sprite difficultyStartSprite_pressed;
CIw2DImage* difficultyStartImage;
CIw2DImage* difficultyStartImage_pressed;

TouchButton difficultyEasyButton;
Sprite difficultyEasySprite;
Sprite difficultyEasySprite_pressed;
CIw2DImage* difficultyEasyImage;
CIw2DImage* difficultyEasyImage_pressed;

TouchButton difficultyMediumButton;
Sprite difficultyMediumSprite;
Sprite difficultyMediumSprite_pressed;
CIw2DImage* difficultyMediumImage;
CIw2DImage* difficultyMediumImage_pressed;

TouchButton difficultyHardButton;
Sprite difficultyHardSprite;
Sprite difficultyHardSprite_pressed;
CIw2DImage* difficultyHardImage;
CIw2DImage* difficultyHardImage_pressed;

TouchButton testButton;
Sprite testButtonSprite;
Sprite testButtonSprite_pressed;
CIw2DImage* testButtonImage;
CIw2DImage* testButtonImage_pressed;

// In-game Buttons
TouchButton rotateButton;
Sprite rotateButtonSprite;
Sprite rotateButtonSprite_pressed;
CIw2DImage* rotateButtonImage;
CIw2DImage* rotateButtonImage_pressed;

TouchButton rightButton;
Sprite rightButtonSprite;
Sprite rightButtonSprite_pressed;
CIw2DImage* rightButtonImage;
CIw2DImage* rightButtonImage_pressed;

TouchButton leftButton;
Sprite leftButtonSprite;
Sprite leftButtonSprite_pressed;
CIw2DImage* leftButtonImage;
CIw2DImage* leftButtonImage_pressed;

TouchButton upButton;
Sprite upButtonSprite;
Sprite upButtonSprite_pressed;
CIw2DImage* upButtonImage;
CIw2DImage* upButtonImage_pressed;

TouchButton downButton;
Sprite downButtonSprite;
Sprite downButtonSprite_pressed;
CIw2DImage* downButtonImage;
CIw2DImage* downButtonImage_pressed;

// Cube Materials
CIwMaterial* sideBlueMaterial;
CIwMaterial* sideRedMaterial;
CIwMaterial* sideGreenMaterial;
CIwMaterial* sideYellowMaterial;
CIwMaterial* sideOrangeMaterial;
CIwMaterial* sidePurpleMaterial;

CIwMaterial* side1Material;
CIwMaterial* side2Material;
CIwMaterial* side3Material;
CIwMaterial* side4Material;
CIwMaterial* side5Material;
CIwMaterial* side6Material;
CIwMaterial* nullMaterial;

CIwMaterial* side1TempMaterial;
CIwMaterial* side2TempMaterial;
CIwMaterial* side3TempMaterial;
CIwMaterial* side4TempMaterial;
CIwMaterial* side5TempMaterial;
CIwMaterial* side6TempMaterial;

CIwMaterial* blueSolidMaterial;
CIwMaterial* redSolidMaterial;
CIwMaterial* greenSolidMaterial;
CIwMaterial* yellowSolidMaterial;
CIwMaterial* purpleSolidMaterial;
CIwMaterial* orangeSolidMaterial;

CIwMaterial* blueTransMaterial;
CIwMaterial* redTransMaterial;
CIwMaterial* greenTransMaterial;
CIwMaterial* yellowTransMaterial;
CIwMaterial* purpleTransMaterial;
CIwMaterial* orangeTransMaterial;

CIwMaterial* blueSolidShadowMaterial;
CIwMaterial* redSolidShadowMaterial;
CIwMaterial* greenSolidShadowMaterial;
CIwMaterial* yellowSolidShadowMaterial;
CIwMaterial* purpleSolidShadowMaterial;
CIwMaterial* orangeSolidShadowMaterial;

CIwMaterial* blueTransShadowMaterial;
CIwMaterial* redTransShadowMaterial;
CIwMaterial* greenTransShadowMaterial;
CIwMaterial* yellowTransShadowMaterial;
CIwMaterial* purpleTransShadowMaterial;
CIwMaterial* orangeTransShadowMaterial;

CIwMaterial* warpingMaterial[6];
int16 warpingMaterialIndex[6] = {0, 0, 0, 0, 0, 0};
int16 warpingMaterialIntensity[6] = {0, 0, 0, 0, 0, 0};
CIwSVec3 warpingMaterialVertexStream[6][numCubes*24];
CIwSVec2 warpingMaterialUVStream[6][numCubes*24];
// use cubeNormals2 stream like other materials for the Normals stream
bool cubeIsWarping = false;

CIwMaterial* explodingMaterial[6];
int16 explodingMaterialIndex[6] = {0, 0, 0, 0, 0, 0};
int16 explodingMaterialIntensity[6] = {100, 100, 100, 100, 100, 100};
CIwSVec3 explodingMaterialVertexStream[6][numCubes*24];
CIwSVec2 explodingMaterialUVStream[6][numCubes*24];
// use cubeNormals2 stream like other materials for the Normals stream
int16 explodingDelayTime[6] = {0, 0, 0, 0, 0, 0};
bool cubeIsExploding = false;
bool explodingUp[6] = {true, true, true, true, true, true};

// FUZZY MATERIAL
const int16 numFuzzyMaterials = 3;
const int16 numFuzzyExplodeMaterials = 1;
CIwMaterial* fuzzyMaterial[numFuzzyMaterials];
CIwTexture* fuzzyTexture[numFuzzyMaterials];
CIwMaterial* fuzzyExplodeMaterial[numFuzzyMaterials];
CIwTexture* fuzzyExplodeTexture[numFuzzyMaterials];

// BOMB materials
const int NUM_OF_BOMB_MATERIALS = 6;
CIwMaterial *bombMaterial[NUM_OF_BOMB_MATERIALS];
CIwTexture *bombTexture[NUM_OF_BOMB_MATERIALS];
CIwMaterial *bombDefuseMaterial;
CIwTexture *bombDefuseTexture;
CIwMaterial *bombExplodeMaterial;
CIwTexture *bombExplodeTexture;
bool bombDirectionIsExploding[6] = { false, false, false, false, false, false };
bool bombTriggered[6] = {false, false, false, false, false, false };
bool bombExistsOnPlane[6] = { false, false, false, false, false, false };
bool spawnBomb;
bool spawnBombMode = false;
int bombType;
enum { FBOMB, WTFBOMB };
int16 bombFrequency = 1;

bool bombInPlay;
Sprite bombAlertSprite;
CIw2DImage *bombAlertImage;
CIw2DImage *bombAlertImage_wtf;
bool bombsLanded = false;

Sprite bombDefusedSprite;
CIw2DImage *bombDefusedImage;
bool showBombDefusedSprite = false;

// plus points minus points material
// use fuzzyNormals for normal stream

// plane sides
PlaneSide plane[6];

// textures
CIwTexture* cubeTextureBlue = NULL;
CIwTexture* cubeTextureRed = NULL;
CIwTexture* cubeTextureGreen = NULL;
CIwTexture* cubeTextureYellow = NULL;
CIwTexture* cubeTextureOrange = NULL;
CIwTexture* cubeTexturePurple = NULL;

/*
CIwTexture* planeTextureBlue = NULL;
CIwTexture* planeTextureRed = NULL;
CIwTexture* planeTextureGreen = NULL;
CIwTexture* planeTextureYellow = NULL;
CIwTexture* planeTextureOrange = NULL;
CIwTexture* planeTexturePurple = NULL;
*/

CIwTexture* shadowTextureBlue = NULL;
CIwTexture* shadowTextureRed = NULL;
CIwTexture* shadowTextureGreen = NULL;
CIwTexture* shadowTextureYellow = NULL;
CIwTexture* shadowTextureOrange = NULL;
CIwTexture* shadowTexturePurple = NULL;

CIwTexture* warpingTextureGolden = NULL;
CIwTexture* explodingTextureRed = NULL;

int16 movingToStaticIndex = 0; // this will be obsolete. This was general test for every cube, so now we must use based on material instead

int16 redSolidIndex = 0;
int16 blueSolidIndex = 0;
int16 greenSolidIndex = 0;
int16 purpleSolidIndex = 0;
int16 yellowSolidIndex = 0;
int16 orangeSolidIndex = 0;

int16 redTransIndex = 0;
int16 blueTransIndex = 0;
int16 greenTransIndex = 0;
int16 purpleTransIndex = 0;
int16 yellowTransIndex = 0;
int16 orangeTransIndex = 0;

int16 redSolidShadowIndex = 0;
int16 blueSolidShadowIndex = 0;
int16 greenSolidShadowIndex = 0;
int16 purpleSolidShadowIndex = 0;
int16 yellowSolidShadowIndex = 0;
int16 orangeSolidShadowIndex = 0;

int16 blueSolidIntensity = 0;
int16 redSolidIntensity = 0;
int16 greenSolidIntensity = 0;
int16 orangeSolidIntensity = 0;
int16 purpleSolidIntensity = 0;
int16 yellowSolidIntensity = 0;

int16 blueTransIntensity = 255;
int16 redTransIntensity = 255;
int16 greenTransIntensity = 255;
int16 orangeTransIntensity = 255;
int16 purpleTransIntensity = 255;
int16 yellowTransIntensity = 150;

int16 blueSolidIntensityIncrement = 3; // add the other colors
int16 redSolidIntensityIncrement = 3;
int16 greenSolidIntensityIncrement = 3;
int16 orangeSolidIntensityIncrement = 3;
int16 purpleSolidIntensityIncrement = 3;
int16 yellowSolidIntensityIncrement = 3;

bool blueSolidIncreasing = false;
bool redSolidIncreasing = false;
bool greenSolidIncreasing = false;
bool orangeSolidIncreasing = false;
bool purpleSolidIncreasing = false;
bool yellowSolidIncreasing = false;

int16 alphaValue_cube = CIwMaterial::ALPHA_DEFAULT; // DEFAULT alpha uses chromakeying, where magenta RGB = (255, 0, 255) is transparent
int16 alphaValue_cubeTransparent = CIwMaterial::ALPHA_HALF;
int16 alphaValue_side = CIwMaterial::ALPHA_ADD;
int16 alphaValue_shadow = CIwMaterial::ALPHA_DEFAULT;
int16 alphaValue_shadowTransparent = CIwMaterial::ALPHA_ADD;
int16 alphaValue_warpingMaterial = CIwMaterial::ALPHA_ADD;
int16 alphaValue_explodingMaterial = CIwMaterial::ALPHA_ADD;
int16 alphaValue_fuzzyMaterial = CIwMaterial::ALPHA_DEFAULT;

Shadow* selectedShadow = NULL;
bool shadowIsTouched = false;
int16 layerLevelOnTouch;

int16 multiplier = 1; // when testing, to help render in loop. may not need this
int16 s = 800; // side length, original was 40. 800 gives a max starting height of about 20 * s
int16 RATE = 30; // this is equivalent to the FPS that I've bottlenecked for the updating
int16 INITIAL_SPEED = 800; // The speed is units per second. However, it must go by a multiple of the RATE // set in initializeDifficulty/level
//int16 MAX_SPEED = 20000; // not used
int16 ACCELERATION = 0; // acceleration is units per second. Must go up by multiple of the RATE, which is equivalent to FPS // last number was 100
const int16 n = 2364;// normals //const int16 n = 0x93c;
Cube cubeArray[ numCubes ];
Cube cubeArrayMoving[ numMovingCubes ];
Shadow shadowArray[ numShadows ];
bool canSpawn = true;
//vector<Cube> cubeArray;
//vector<Cube> cubeArrayMoving;
int16 streamNumber = 0; // for keeping track of how many vertex streams were created
// for spawning Moving Cubes
// the cubeSetType
enum { SINGLE, DOUBLE, TRIPLE_CORNER, TRIPLE_LINE, QUAD_SQUARE, QUAD_T };
CIwSVec3 nextPosition;
uint64 uniqueID = 0; // this is used to give each spawned cube a unique ID

// CAMERA variables
CIwMat view;
int16 cameraDepth = -s * 8; // default is s*-8
int16 savedDepth = cameraDepth;
int16 worldX, worldY; // camera rotation
int16 savedX, savedY;
int16 cameraDepthIncrement = 1;
int16 rotateSensitivityMultiplier = 9; // the rotation sensitivity
//double zoomDeccelerationFactor = 100; // controls the zoom sensitivty based on location to center
//double zoomAcceleration;
double zoomSensitivityMultiplier = (float)s / 15; // reduces zoom sensitivity/zoom distance by factor of the denominator/10 if cubes are 10 big
int16 zoomOutLimit = 12 * s; // the zoom limit is a positive value, represents the multiple of the size of a cube
int16 zoomInLimit = 1 * s; // the zoom limit is a positive value, represents the multiple of the size of a cube // last value was 3
double zoomSensitivityMax = (float)s / 50; // upper and lower limit of zoom sensitivity original was 30
double zoomSensitivityMin = (float)s / 70;  // original was 80 I think
double zoomSensitivityDelta = (zoomSensitivityMax - zoomSensitivityMin) / float(zoomOutLimit - zoomInLimit);
double zoomSensitivity; //= zoomSensitivityMin + zoomSensitivityDelta * ((cameraDepth*-1) - zoomInLimit);; // this will replace the zoomSensitivityMultiplier, calculated on zoom activation touch
double distance; // for calculating camera depth
double startDistance; // for helping determine if zooming in or out
double endDistance;
int16 draggedX1, draggedY1;
int16 draggedX2, draggedY2;
int16 reversedIndex = 1; // for reversing y-axis rotation if x-axis goes beyond top/bottom limit

int16 fuzzyCount = 0;
int16 fuzzyLimit = 5;


CIwSVec3 fuzzyVertices[4] =
{
	CIwSVec3(-s/2, -s/2, 0), 
    CIwSVec3( -s/2, s/2, 0),
    CIwSVec3( s/2,  s/2, 0),
    CIwSVec3( s/2, -s/2, 0),
};

// FUZZY MATERIAL UV STREAM
CIwSVec2 fuzzyUVStream[4] = 
{
	// this is for mapping cells for sprites
	// Each UV corresponds to each Vertex drawn with the draw mode
	// or whatever Index order things are drawn in.
	// Tweak the UVs so that they match each coordinate for U and V
	// Just look at this example and figure it out.
	// Where there is a non-zero number, represents a corner in the axis direction, 
	// or a UV value of 1 if this were NOT a sprite image.
	
	CIwSVec2(IW_FIXED(0.0), IW_FIXED(0.0) ),
	CIwSVec2(IW_FIXED(0.0), IW_FIXED(0.125) ),
	CIwSVec2(IW_FIXED(0.125), IW_FIXED(0.125) ),
	CIwSVec2(IW_FIXED(0.125), IW_FIXED(0.0) ),
};

CIwSVec2 fuzzyUVExplodeStream[4] = 
{
	// this is for mapping cells for sprites
	// Each UV corresponds to each Vertex drawn with the draw mode
	// or whatever Index order things are drawn in.
	// Tweak the UVs so that they match each coordinate for U and V
	// Just look at this example and figure it out.
	// Where there is a non-zero number, represents a corner in the axis direction, 
	// or a UV value of 1 if this were NOT a sprite image.
	
	CIwSVec2(IW_FIXED(0.0), IW_FIXED(0.0) ),
	CIwSVec2(IW_FIXED(0.0), IW_FIXED(0.125) ),
	CIwSVec2(IW_FIXED(0.125), IW_FIXED(0.125) ),
	CIwSVec2(IW_FIXED(0.125), IW_FIXED(0.0) ),
};

CIwSVec3 fuzzyNormals[4] = 
{
	CIwSVec3( 0, 0, -IW_GEOM_ONE ),
	CIwSVec3( 0, 0, -IW_GEOM_ONE ),
	CIwSVec3( 0, 0, -IW_GEOM_ONE ),
	CIwSVec3( 0, 0, -IW_GEOM_ONE ),
};

CIwSVec2 sideUVStream[4] =
{
	CIwSVec2(IW_FIXED(0.0), IW_FIXED(0.0) ),
	CIwSVec2(IW_FIXED(0.0), IW_FIXED(1.0) ),
	CIwSVec2(IW_FIXED(1.0), IW_FIXED(1.0) ),
	CIwSVec2(IW_FIXED(1.0), IW_FIXED(0.0) ),
};
CIwSVec2 planesUVStream[numCubesLength * numCubesWidth * numCubesHeight * 4] = {};

// UV Stream
CIwSVec2 uvstream_base[24] = 
{
	CIwSVec2( IW_FIXED( 0.0 ), IW_FIXED( 0.0 ) ),
	CIwSVec2( IW_FIXED( 0.0 ), IW_FIXED( 1.0 ) ),
	CIwSVec2( IW_FIXED( 1.0 ), IW_FIXED( 1.0 ) ),
	CIwSVec2( IW_FIXED( 1.0 ), IW_FIXED( 0.0 ) ),

	CIwSVec2( IW_FIXED( 0.0 ), IW_FIXED( 0.0 ) ),
	CIwSVec2( IW_FIXED( 0.0 ), IW_FIXED( 1.0 ) ),
	CIwSVec2( IW_FIXED( 1.0 ), IW_FIXED( 1.0 ) ),
	CIwSVec2( IW_FIXED( 1.0 ), IW_FIXED( 0.0 ) ),

	CIwSVec2( IW_FIXED( 0.0 ), IW_FIXED( 0.0 ) ),
	CIwSVec2( IW_FIXED( 0.0 ), IW_FIXED( 1.0 ) ),
	CIwSVec2( IW_FIXED( 1.0 ), IW_FIXED( 1.0 ) ),
	CIwSVec2( IW_FIXED( 1.0 ), IW_FIXED( 0.0 ) ),

	CIwSVec2( IW_FIXED( 0.0 ), IW_FIXED( 0.0 ) ),
	CIwSVec2( IW_FIXED( 0.0 ), IW_FIXED( 1.0 ) ),
	CIwSVec2( IW_FIXED( 1.0 ), IW_FIXED( 1.0 ) ),
	CIwSVec2( IW_FIXED( 1.0 ), IW_FIXED( 0.0 ) ),

	CIwSVec2( IW_FIXED( 0.0 ), IW_FIXED( 0.0 ) ),
	CIwSVec2( IW_FIXED( 0.0 ), IW_FIXED( 1.0 ) ),
	CIwSVec2( IW_FIXED( 1.0 ), IW_FIXED( 1.0 ) ),
	CIwSVec2( IW_FIXED( 1.0 ), IW_FIXED( 0.0 ) ),

	CIwSVec2( IW_FIXED( 0.0 ), IW_FIXED( 0.0 ) ),
	CIwSVec2( IW_FIXED( 0.0 ), IW_FIXED( 1.0 ) ),
	CIwSVec2( IW_FIXED( 1.0 ), IW_FIXED( 1.0 ) ),
	CIwSVec2( IW_FIXED( 1.0 ), IW_FIXED( 0.0 ) ),
};

// CUBE1 vertices - the base cube
CIwSVec3 cubeVertices[24] =
{
	// faceSide 1
	CIwSVec3(-s/2, -s/2, -s/2), 
    CIwSVec3( -s/2, s/2, -s/2),
    CIwSVec3( s/2,  s/2, -s/2),
    CIwSVec3( s/2, -s/2, -s/2),
	

	// faceSide 2
    CIwSVec3( s/2, -s/2,  -s/2),
    CIwSVec3( s/2, s/2,  -s/2),
    CIwSVec3( s/2,  s/2, s/2),
    CIwSVec3( s/2,  -s/2, s/2),

	// faceSide 3
	CIwSVec3( s/2, -s/2,  s/2),
    CIwSVec3( s/2, s/2,  s/2),
    CIwSVec3( -s/2,  s/2, s/2),
    CIwSVec3( -s/2,  -s/2, s/2),

	// faceSide 4
	CIwSVec3( -s/2, -s/2,  s/2),
    CIwSVec3( -s/2, s/2,  s/2),
    CIwSVec3( -s/2,  s/2, -s/2),
    CIwSVec3( -s/2,  -s/2, -s/2),

	// faceSide 5
	CIwSVec3( -s/2, -s/2,  s/2),
    CIwSVec3( -s/2, -s/2,  -s/2),
    CIwSVec3( s/2,  -s/2, -s/2),
    CIwSVec3( s/2, -s/2, s/2),

	// faceSide 6
	CIwSVec3( -s/2, s/2,  -s/2),
    CIwSVec3( -s/2, s/2,  s/2),
    CIwSVec3( s/2,  s/2, s/2),
    CIwSVec3( s/2,  s/2, -s/2),
};

CIwSVec3 cubeNormals[24] = 
{
	// faceSide 1
	CIwSVec3( -n, -n, -n),
    CIwSVec3( -n, n, -n),
    CIwSVec3( n,  n, -n),
    CIwSVec3( n, -n, -n),
	
	// faceSide 2
    CIwSVec3( n, -n,  -n),
    CIwSVec3( n, n,  -n),
    CIwSVec3( n,  n, n),
    CIwSVec3( n,  -n, n),

	// faceSide 3
	CIwSVec3( n, -n,  n),
    CIwSVec3( n, n,  n),
    CIwSVec3( -n,  n, n),
    CIwSVec3( -n,  -n, n),

	// faceSide 4 
	CIwSVec3( -n, -n,  n),
    CIwSVec3( -n, n,  n),
    CIwSVec3( -n,  n, -n),
    CIwSVec3( -n,  -n, -n),

	// faceSide 5
	CIwSVec3( -n, -n,  n),
    CIwSVec3( -n, -n,  -n),
    CIwSVec3( n,  -n, -n),
    CIwSVec3( n, -n, n),

	// faceSide 6
	CIwSVec3(-n, n,-n),
    CIwSVec3(-n, n, n),
    CIwSVec3( n, n, n),
    CIwSVec3( n, n,-n),
};

// SHADOW new vertices

CIwSVec3 shadowVerticesFaceSide1[24] =
{
	// faceSide 1
	CIwSVec3(-s/2, -s/2, -s/2 - s/4), 
    CIwSVec3( -s/2, s/2, -s/2 - s/4),
    CIwSVec3( s/2,  s/2, -s/2 - s/4),
    CIwSVec3( s/2, -s/2, -s/2 - s/4),

	// faceSide 2
    CIwSVec3( s/2, -s/2,  -s/2 - s/4),
    CIwSVec3( s/2, s/2,  -s/2 - s/4),
    CIwSVec3( s/2,  s/2, s/2 - s),
    CIwSVec3( s/2,  -s/2, s/2 - s),

	// faceSide 3
	CIwSVec3( s/2, -s/2,  s/2 - s),
    CIwSVec3( s/2, s/2,  s/2 - s),
    CIwSVec3( -s/2,  s/2, s/2 - s),
    CIwSVec3( -s/2,  -s/2, s/2 - s),

	// faceSide 4
	CIwSVec3( -s/2, -s/2,  s/2 - s),
    CIwSVec3( -s/2, s/2,  s/2 - s),
    CIwSVec3( -s/2,  s/2, -s/2 - s/4),
    CIwSVec3( -s/2,  -s/2, -s/2 - s/4),

	// faceSide 5
	CIwSVec3( -s/2, -s/2,  s/2 - s),
    CIwSVec3( -s/2, -s/2,  -s/2 - s/4),
    CIwSVec3( s/2,  -s/2, -s/2 - s/4),
    CIwSVec3( s/2, -s/2, s/2 - s),

	// faceSide 6
	CIwSVec3( -s/2, s/2,  -s/2 - s/4),
    CIwSVec3( -s/2, s/2,  s/2 - s),
    CIwSVec3( s/2,  s/2, s/2 - s),
    CIwSVec3( s/2,  s/2, -s/2 - s/4),
};

CIwSVec3 shadowVerticesFaceSide2[24] =
{
	// faceSide 1
	CIwSVec3(-s/2 + s, -s/2, -s/2), 
    CIwSVec3( -s/2 + s, s/2, -s/2),
    CIwSVec3( s/2 + s/4,  s/2, -s/2),
    CIwSVec3( s/2 + s/4, -s/2, -s/2),
	

	// faceSide 2
    CIwSVec3( s/2 + s/4, -s/2,  -s/2),
    CIwSVec3( s/2 + s/4, s/2,  -s/2),
    CIwSVec3( s/2 + s/4,  s/2, s/2),
    CIwSVec3( s/2 + s/4,  -s/2, s/2),

	// faceSide 3
	CIwSVec3( s/2 + s/4, -s/2,  s/2),
    CIwSVec3( s/2 + s/4, s/2,  s/2),
    CIwSVec3( -s/2 + s,  s/2, s/2),
    CIwSVec3( -s/2 + s,  -s/2, s/2),

	// faceSide 4
	CIwSVec3( -s/2 + s, -s/2,  s/2),
    CIwSVec3( -s/2 + s, s/2,  s/2),
    CIwSVec3( -s/2 + s,  s/2, -s/2),
    CIwSVec3( -s/2 + s,  -s/2, -s/2),

	// faceSide 5
	CIwSVec3( -s/2 + s, -s/2,  s/2),
    CIwSVec3( -s/2 + s, -s/2,  -s/2),
    CIwSVec3( s/2 + s/4,  -s/2, -s/2),
    CIwSVec3( s/2 + s/4, -s/2, s/2),

	// faceSide 6
	CIwSVec3( -s/2 + s, s/2,  -s/2),
    CIwSVec3( -s/2 + s, s/2,  s/2),
    CIwSVec3( s/2 + s/4,  s/2, s/2),
    CIwSVec3( s/2 + s/4,  s/2, -s/2),
};

CIwSVec3 shadowVerticesFaceSide3[24] =
{
	// faceSide 1
	CIwSVec3(-s/2, -s/2, -s/2 + s), 
    CIwSVec3( -s/2, s/2, -s/2 + s),
    CIwSVec3( s/2,  s/2, -s/2 + s),
    CIwSVec3( s/2, -s/2, -s/2 + s),
	

	// faceSide 2
    CIwSVec3( s/2, -s/2,  -s/2 + s),
    CIwSVec3( s/2, s/2,  -s/2 + s),
    CIwSVec3( s/2,  s/2, s/2 + s/4),
    CIwSVec3( s/2,  -s/2, s/2 + s/4),

	// faceSide 3
	CIwSVec3( s/2, -s/2,  s/2 + s/4),
    CIwSVec3( s/2, s/2,  s/2 + s/4),
    CIwSVec3( -s/2,  s/2, s/2 + s/4),
    CIwSVec3( -s/2,  -s/2, s/2 + s/4),

	// faceSide 4
	CIwSVec3( -s/2, -s/2,  s/2 + s/4),
    CIwSVec3( -s/2, s/2,  s/2 + s/4),
    CIwSVec3( -s/2,  s/2, -s/2 + s),
    CIwSVec3( -s/2,  -s/2, -s/2 + s),

	// faceSide 5
	CIwSVec3( -s/2, -s/2,  s/2 + s/4),
    CIwSVec3( -s/2, -s/2,  -s/2 + s),
    CIwSVec3( s/2,  -s/2, -s/2 + s),
    CIwSVec3( s/2, -s/2, s/2 + s/4),

	// faceSide 6
	CIwSVec3( -s/2, s/2,  -s/2 + s),
    CIwSVec3( -s/2, s/2,  s/2 + s/4),
    CIwSVec3( s/2,  s/2, s/2 + s/4),
    CIwSVec3( s/2,  s/2, -s/2 + s),
};

CIwSVec3 shadowVerticesFaceSide4[24] =
{
	// faceSide 1
	CIwSVec3(-s/2 - s/4, -s/2, -s/2), 
    CIwSVec3( -s/2 - s/4, s/2, -s/2),
    CIwSVec3( s/2 - s,  s/2, -s/2),
    CIwSVec3( s/2 - s, -s/2, -s/2),
	

	// faceSide 2
    CIwSVec3( s/2 - s, -s/2,  -s/2),
    CIwSVec3( s/2 - s, s/2,  -s/2),
    CIwSVec3( s/2 - s,  s/2, s/2),
    CIwSVec3( s/2 - s,  -s/2, s/2),

	// faceSide 3
	CIwSVec3( s/2 - s, -s/2,  s/2),
    CIwSVec3( s/2 - s, s/2,  s/2),
    CIwSVec3( -s/2 - s/4,  s/2, s/2),
    CIwSVec3( -s/2 - s/4,  -s/2, s/2),

	// faceSide 4
	CIwSVec3( -s/2 - s/4, -s/2,  s/2),
    CIwSVec3( -s/2 - s/4, s/2,  s/2),
    CIwSVec3( -s/2 - s/4,  s/2, -s/2),
    CIwSVec3( -s/2 - s/4,  -s/2, -s/2),

	// faceSide 5
	CIwSVec3( -s/2 - s/4, -s/2,  s/2),
    CIwSVec3( -s/2 - s/4, -s/2,  -s/2),
    CIwSVec3( s/2 - s,  -s/2, -s/2),
    CIwSVec3( s/2 - s, -s/2, s/2),

	// faceSide 6
	CIwSVec3( -s/2 - s/4, s/2,  -s/2),
    CIwSVec3( -s/2 - s/4, s/2,  s/2),
    CIwSVec3( s/2 - s,  s/2, s/2),
    CIwSVec3( s/2 - s,  s/2, -s/2),
};

CIwSVec3 shadowVerticesFaceSide5[24] =
{
	// faceSide 1
	CIwSVec3(-s/2, -s/2 - s/4, -s/2), 
    CIwSVec3( -s/2, s/2 - s, -s/2),
    CIwSVec3( s/2,  s/2 - s, -s/2),
    CIwSVec3( s/2, -s/2 - s/4, -s/2),
	

	// faceSide 2
    CIwSVec3( s/2, -s/2 - s/4,  -s/2),
    CIwSVec3( s/2, s/2 - s,  -s/2),
    CIwSVec3( s/2,  s/2 - s, s/2),
    CIwSVec3( s/2,  -s/2 - s/4, s/2),

	// faceSide 3
	CIwSVec3( s/2, -s/2 - s/4,  s/2),
    CIwSVec3( s/2, s/2 - s,  s/2),
    CIwSVec3( -s/2,  s/2 - s, s/2),
    CIwSVec3( -s/2,  -s/2 - s/4, s/2),

	// faceSide 4
	CIwSVec3( -s/2, -s/2 - s/4,  s/2),
    CIwSVec3( -s/2, s/2 - s,  s/2),
    CIwSVec3( -s/2,  s/2 - s, -s/2),
    CIwSVec3( -s/2,  -s/2 - s/4, -s/2),

	// faceSide 5
	CIwSVec3( -s/2, -s/2 - s/4,  s/2),
    CIwSVec3( -s/2, -s/2 - s/4,  -s/2),
    CIwSVec3( s/2,  -s/2 - s/4, -s/2),
    CIwSVec3( s/2, -s/2 - s/4, s/2),

	// faceSide 6
	CIwSVec3( -s/2, s/2 - s,  -s/2),
    CIwSVec3( -s/2, s/2 - s,  s/2),
    CIwSVec3( s/2,  s/2 - s, s/2),
    CIwSVec3( s/2,  s/2 - s, -s/2),
};

CIwSVec3 shadowVerticesFaceSide6[24] =
{
	// faceSide 1
	CIwSVec3(-s/2, -s/2 + s, -s/2), 
    CIwSVec3( -s/2, s/2 + s/4, -s/2),
    CIwSVec3( s/2,  s/2 + s/4, -s/2),
    CIwSVec3( s/2, -s/2 + s, -s/2),
	

	// faceSide 2
    CIwSVec3( s/2, -s/2 + s,  -s/2),
    CIwSVec3( s/2, s/2 + s/4,  -s/2),
    CIwSVec3( s/2,  s/2 + s/4, s/2),
    CIwSVec3( s/2,  -s/2 + s, s/2),

	// faceSide 3
	CIwSVec3( s/2, -s/2 + s,  s/2),
    CIwSVec3( s/2, s/2 + s/4,  s/2),
    CIwSVec3( -s/2,  s/2 + s/4, s/2),
    CIwSVec3( -s/2,  -s/2 + s, s/2),

	// faceSide 4
	CIwSVec3( -s/2, -s/2 + s,  s/2),
    CIwSVec3( -s/2, s/2 + s/4,  s/2),
    CIwSVec3( -s/2,  s/2 + s/4, -s/2),
    CIwSVec3( -s/2,  -s/2 + s, -s/2),

	// faceSide 5
	CIwSVec3( -s/2, -s/2 + s,  s/2),
    CIwSVec3( -s/2, -s/2 + s,  -s/2),
    CIwSVec3( s/2,  -s/2 + s, -s/2),
    CIwSVec3( s/2, -s/2 + s, s/2),

	// faceSide 6
	CIwSVec3( -s/2, s/2 + s/4,  -s/2),
    CIwSVec3( -s/2, s/2 + s/4,  s/2),
    CIwSVec3( s/2,  s/2 + s/4, s/2),
    CIwSVec3( s/2,  s/2 + s/4, -s/2),
};

// The Shadow Transparent Cube
CIwSVec3 shadowVerticesTransparentFaceSide1[24] =
{
	// faceSide 1
	CIwSVec3(-s/2, -s/2, -s/2 - s), 
    CIwSVec3( -s/2, s/2, -s/2 - s),
    CIwSVec3( s/2,  s/2, -s/2 - s),
    CIwSVec3( s/2, -s/2, -s/2 - s),

	// faceSide 2
    CIwSVec3( s/2, -s/2,  -s/2 - s),
    CIwSVec3( s/2, s/2,  -s/2 - s),
    CIwSVec3( s/2,  s/2, s/2 - s - s/4),
    CIwSVec3( s/2,  -s/2, s/2 - s - s/4),

	// faceSide 3
	CIwSVec3( s/2, -s/2,  s/2 - s - s/4),
    CIwSVec3( s/2, s/2,  s/2 - s - s/4),
    CIwSVec3( -s/2,  s/2, s/2 - s - s/4),
    CIwSVec3( -s/2,  -s/2, s/2 - s - s/4),

	// faceSide 4
	CIwSVec3( -s/2, -s/2,  s/2 - s - s/4),
    CIwSVec3( -s/2, s/2,  s/2 - s - s/4),
    CIwSVec3( -s/2,  s/2, -s/2 - s),
    CIwSVec3( -s/2,  -s/2, -s/2 - s),

	// faceSide 5
	CIwSVec3( -s/2, -s/2,  s/2 - s - s/4),
    CIwSVec3( -s/2, -s/2,  -s/2 - s),
    CIwSVec3( s/2,  -s/2, -s/2 - s),
    CIwSVec3( s/2, -s/2, s/2 - s - s/4),

	// faceSide 6
	CIwSVec3( -s/2, s/2,  -s/2 - s),
    CIwSVec3( -s/2, s/2,  s/2 - s - s/4),
    CIwSVec3( s/2,  s/2, s/2 - s - s/4),
    CIwSVec3( s/2,  s/2, -s/2 - s),
};

CIwSVec3 shadowVerticesTransparentFaceSide2[24] =
{
	// faceSide 1
	CIwSVec3(-s/2 + s + s/4, -s/2, -s/2), 
    CIwSVec3( -s/2 + s + s/4, s/2, -s/2),
    CIwSVec3( s/2 + s,  s/2, -s/2),
    CIwSVec3( s/2 + s, -s/2, -s/2),
	

	// faceSide 2
    CIwSVec3( s/2 + s, -s/2,  -s/2),
    CIwSVec3( s/2 + s, s/2,  -s/2),
    CIwSVec3( s/2 + s,  s/2, s/2),
    CIwSVec3( s/2 + s,  -s/2, s/2),

	// faceSide 3
	CIwSVec3( s/2 + s, -s/2,  s/2),
    CIwSVec3( s/2 + s, s/2,  s/2),
    CIwSVec3( -s/2 + s + s/4 ,  s/2, s/2),
    CIwSVec3( -s/2 + s + s/4,  -s/2, s/2),

	// faceSide 4
	CIwSVec3( -s/2 + s + s/4, -s/2,  s/2),
    CIwSVec3( -s/2 + s + s/4, s/2,  s/2),
    CIwSVec3( -s/2 + s + s/4,  s/2, -s/2),
    CIwSVec3( -s/2 + s + s/4,  -s/2, -s/2),

	// faceSide 5
	CIwSVec3( -s/2 + s + s/4, -s/2,  s/2),
    CIwSVec3( -s/2 + s + s/4, -s/2,  -s/2),
    CIwSVec3( s/2 + s,  -s/2, -s/2),
    CIwSVec3( s/2 + s, -s/2, s/2),

	// faceSide 6
	CIwSVec3( -s/2 + s + s/4, s/2,  -s/2),
    CIwSVec3( -s/2 + s + s/4, s/2,  s/2),
    CIwSVec3( s/2 + s,  s/2, s/2),
    CIwSVec3( s/2 + s,  s/2, -s/2),
};

CIwSVec3 shadowVerticesTransparentFaceSide3[24] =
{
	// faceSide 1
	CIwSVec3(-s/2, -s/2, -s/2 + s + s/4), 
    CIwSVec3( -s/2, s/2, -s/2 + s + s/4),
    CIwSVec3( s/2,  s/2, -s/2 + s + s/4),
    CIwSVec3( s/2, -s/2, -s/2 + s + s/4),
	

	// faceSide 2
    CIwSVec3( s/2, -s/2,  -s/2 + s + s/4),
    CIwSVec3( s/2, s/2,  -s/2 + s + s/4),
    CIwSVec3( s/2,  s/2, s/2 + s),
    CIwSVec3( s/2,  -s/2, s/2 + s),

	// faceSide 3
	CIwSVec3( s/2, -s/2,  s/2 + s),
    CIwSVec3( s/2, s/2,  s/2 + s),
    CIwSVec3( -s/2,  s/2, s/2 + s),
    CIwSVec3( -s/2,  -s/2, s/2 + s),

	// faceSide 4
	CIwSVec3( -s/2, -s/2,  s/2 + s),
    CIwSVec3( -s/2, s/2,  s/2 + s),
    CIwSVec3( -s/2,  s/2, -s/2 + s + s/4),
    CIwSVec3( -s/2,  -s/2, -s/2 + s + s/4),

	// faceSide 5
	CIwSVec3( -s/2, -s/2,  s/2 + s),
    CIwSVec3( -s/2, -s/2,  -s/2 + s + s/4),
    CIwSVec3( s/2,  -s/2, -s/2 + s + s/4),
    CIwSVec3( s/2, -s/2, s/2 + s),

	// faceSide 6
	CIwSVec3( -s/2, s/2,  -s/2 + s + s/4),
    CIwSVec3( -s/2, s/2,  s/2 + s),
    CIwSVec3( s/2,  s/2, s/2 + s),
    CIwSVec3( s/2,  s/2, -s/2 + s + s/4),
};

CIwSVec3 shadowVerticesTransparentFaceSide4[24] =
{
	// faceSide 1
	CIwSVec3(-s/2 - s, -s/2, -s/2), 
    CIwSVec3( -s/2 - s, s/2, -s/2),
    CIwSVec3( s/2 - s - s/4,  s/2, -s/2),
    CIwSVec3( s/2 - s - s/4, -s/2, -s/2),
	

	// faceSide 2
    CIwSVec3( s/2 - s - s/4, -s/2,  -s/2),
    CIwSVec3( s/2 - s - s/4, s/2,  -s/2),
    CIwSVec3( s/2 - s - s/4,  s/2, s/2),
    CIwSVec3( s/2 - s - s/4,  -s/2, s/2),

	// faceSide 3
	CIwSVec3( s/2 - s - s/4, -s/2,  s/2),
    CIwSVec3( s/2 - s - s/4, s/2,  s/2),
    CIwSVec3( -s/2 - s,  s/2, s/2),
    CIwSVec3( -s/2 - s,  -s/2, s/2),

	// faceSide 4
	CIwSVec3( -s/2 - s, -s/2,  s/2),
    CIwSVec3( -s/2 - s, s/2,  s/2),
    CIwSVec3( -s/2 - s,  s/2, -s/2),
    CIwSVec3( -s/2 - s,  -s/2, -s/2),

	// faceSide 5
	CIwSVec3( -s/2 - s, -s/2,  s/2),
    CIwSVec3( -s/2 - s, -s/2,  -s/2),
    CIwSVec3( s/2 - s - s/4,  -s/2, -s/2),
    CIwSVec3( s/2 - s - s/4, -s/2, s/2),

	// faceSide 6
	CIwSVec3( -s/2 - s, s/2,  -s/2),
    CIwSVec3( -s/2 - s, s/2,  s/2),
    CIwSVec3( s/2 - s - s/4,  s/2, s/2),
    CIwSVec3( s/2 - s - s/4,  s/2, -s/2),
};

CIwSVec3 shadowVerticesTransparentFaceSide5[24] =
{
	// faceSide 1
	CIwSVec3(-s/2, -s/2 - s, -s/2), 
    CIwSVec3( -s/2, s/2 - s - s/4, -s/2),
    CIwSVec3( s/2,  s/2 - s - s/4, -s/2),
    CIwSVec3( s/2, -s/2 - s, -s/2),
	

	// faceSide 2
    CIwSVec3( s/2, -s/2 - s,  -s/2),
    CIwSVec3( s/2, s/2 - s - s/4,  -s/2),
    CIwSVec3( s/2,  s/2 - s - s/4, s/2),
    CIwSVec3( s/2,  -s/2 - s, s/2),

	// faceSide 3
	CIwSVec3( s/2, -s/2 - s,  s/2),
    CIwSVec3( s/2, s/2 - s - s/4,  s/2),
    CIwSVec3( -s/2,  s/2 - s - s/4, s/2),
    CIwSVec3( -s/2,  -s/2 - s, s/2),

	// faceSide 4
	CIwSVec3( -s/2, -s/2 - s,  s/2),
    CIwSVec3( -s/2, s/2 - s - s/4,  s/2),
    CIwSVec3( -s/2,  s/2 - s - s/4, -s/2),
    CIwSVec3( -s/2,  -s/2 - s, -s/2),

	// faceSide 5
	CIwSVec3( -s/2, -s/2 - s,  s/2),
    CIwSVec3( -s/2, -s/2 - s,  -s/2),
    CIwSVec3( s/2,  -s/2 - s, -s/2),
    CIwSVec3( s/2, -s/2 - s, s/2),

	// faceSide 6
	CIwSVec3( -s/2, s/2 - s - s/4,  -s/2),
    CIwSVec3( -s/2, s/2 - s - s/4,  s/2),
    CIwSVec3( s/2,  s/2 - s - s/4, s/2),
    CIwSVec3( s/2,  s/2 - s - s/4, -s/2),
};

CIwSVec3 shadowVerticesTransparentFaceSide6[24] =
{
	// faceSide 1
	CIwSVec3(-s/2, -s/2 + s + s/4, -s/2), 
    CIwSVec3( -s/2, s/2 + s, -s/2),
    CIwSVec3( s/2,  s/2 + s, -s/2),
    CIwSVec3( s/2, -s/2 + s + s/4, -s/2),
	

	// faceSide 2
    CIwSVec3( s/2, -s/2 + s + s/4,  -s/2),
    CIwSVec3( s/2, s/2 + s,  -s/2),
    CIwSVec3( s/2,  s/2 + s, s/2),
    CIwSVec3( s/2,  -s/2 + s + s/4, s/2),

	// faceSide 3
	CIwSVec3( s/2, -s/2 + s + s/4,  s/2),
    CIwSVec3( s/2, s/2 + s,  s/2),
    CIwSVec3( -s/2,  s/2 + s, s/2),
    CIwSVec3( -s/2,  -s/2 + s + s/4, s/2),

	// faceSide 4
	CIwSVec3( -s/2, -s/2 + s + s/4,  s/2),
    CIwSVec3( -s/2, s/2 + s,  s/2),
    CIwSVec3( -s/2,  s/2 + s, -s/2),
    CIwSVec3( -s/2,  -s/2 + s + s/4, -s/2),

	// faceSide 5
	CIwSVec3( -s/2, -s/2 + s + s/4,  s/2),
    CIwSVec3( -s/2, -s/2 + s + s/4,  -s/2),
    CIwSVec3( s/2,  -s/2 + s + s/4, -s/2),
    CIwSVec3( s/2, -s/2 + s + s/4, s/2),

	// faceSide 6
	CIwSVec3( -s/2, s/2 + s,  -s/2),
    CIwSVec3( -s/2, s/2 + s,  s/2),
    CIwSVec3( s/2,  s/2 + s, s/2),
    CIwSVec3( s/2,  s/2 + s, -s/2),
};


// these are obsolete I believe...
// SHADOW1 vertices - the base shadow
CIwSVec3 sideVerticesFaceSide1[4] = 
{
	// faceSide 1
	CIwSVec3(-s/2, -s/2, -s/2), 
    CIwSVec3( -s/2, s/2, -s/2),
    CIwSVec3( s/2,  s/2, -s/2),
    CIwSVec3( s/2, -s/2, -s/2),
};
CIwSVec3 sideVerticesFaceSide2[4] = 
{
	// faceSide 2
    CIwSVec3( s/2, -s/2,  -s/2),
    CIwSVec3( s/2, s/2,  -s/2),
    CIwSVec3( s/2,  s/2, s/2),
    CIwSVec3( s/2,  -s/2, s/2),
};
CIwSVec3 sideVerticesFaceSide3[4] = 
{
	// faceSide 3
	CIwSVec3( s/2, -s/2,  s/2),
    CIwSVec3( s/2, s/2,  s/2),
    CIwSVec3( -s/2,  s/2, s/2),
    CIwSVec3( -s/2,  -s/2, s/2),
};
CIwSVec3 sideVerticesFaceSide4[4] = 
{
	// faceSide 4
	CIwSVec3( -s/2, -s/2,  s/2),
    CIwSVec3( -s/2, s/2,  s/2),
    CIwSVec3( -s/2,  s/2, -s/2),
    CIwSVec3( -s/2,  -s/2, -s/2),
};
CIwSVec3 sideVerticesFaceSide5[4] = 
{
	// faceSide 5
	CIwSVec3( -s/2, -s/2,  s/2),
    CIwSVec3( -s/2, -s/2,  -s/2),
    CIwSVec3( s/2,  -s/2, -s/2),
    CIwSVec3( s/2, -s/2, s/2),
};
CIwSVec3 sideVerticesFaceSide6[4] = 
{
	// faceSide 6
	CIwSVec3( -s/2, s/2,  -s/2),
    CIwSVec3( -s/2, s/2,  s/2),
    CIwSVec3( s/2,  s/2, s/2),
    CIwSVec3( s/2,  s/2, -s/2),
};


// SHADOW1 normals - the base normals
CIwSVec3 shadowNormalsFaceSide1[4] = 
{
	// faceSide 1
	CIwSVec3( -n, -n, -n),
    CIwSVec3( -n, n, -n),
    CIwSVec3( n,  n, -n),
    CIwSVec3( n, -n, -n),
};
CIwSVec3 shadowNormalsFaceSide2[4] = 
{
	// faceSide 2
    CIwSVec3( n, -n,  -n),
    CIwSVec3( n, n,  -n),
    CIwSVec3( n,  n, n),
    CIwSVec3( n,  -n, n),
};
CIwSVec3 shadowNormalsFaceSide3[4] = 
{
	// faceSide 3
	CIwSVec3( n, -n,  n),
    CIwSVec3( n, n,  n),
    CIwSVec3( -n,  n, n),
    CIwSVec3( -n,  -n, n),
};
CIwSVec3 shadowNormalsFaceSide4[4] = 
{
	// faceSide 4 
	CIwSVec3( -n, -n,  n),
    CIwSVec3( -n, n,  n),
    CIwSVec3( -n,  n, -n),
    CIwSVec3( -n,  -n, -n),
};
CIwSVec3 shadowNormalsFaceSide5[4] = 
{
	// faceSide 5
	CIwSVec3( -n, -n,  n),
    CIwSVec3( -n, -n,  -n),
    CIwSVec3( n,  -n, -n),
    CIwSVec3( n, -n, n),	
};
CIwSVec3 shadowNormalsFaceSide6[4] = 
{
	// faceSide 6
	CIwSVec3(-n, n,-n),
    CIwSVec3(-n, n, n),
    CIwSVec3( n, n, n),
    CIwSVec3( n, n,-n),
};

// CUBE2 - arrays for static cubes
CIwSVec3 cubeVertices2[numCubes * 24] =
{
};

CIwSVec3 cubeNormals2[numCubes * 24] =
{
};

// array for translated static cubes
CIwSVec3 cubeTranslated2[numCubes * 24] =
{
};


// array for translated, then rotated static cubes. 
// This is only used if SetWorldVertexStream is used.
// But WorldVertex is not used b/c light does not reflect during rotation
// Instead, the translated coordinates ^ up top is used, with matrix tt1 applied to the setmodelmatrix
CIwSVec3 cubeTransformed2[numCubes * 24] =
{
};

// arrays for moving cubes
CIwSVec3 cubeMovingVertices2[numMovingCubes * 24] =
{
};

CIwSVec3 cubeMovingTranslated2[numMovingCubes * 24] =
{
};

CIwSVec3 cubeMovingNormals2[numMovingCubes * 24] =
{
};

// arrays for vertices to render only static cubes turned from moving
CIwSVec3 movingToStaticVertices[ numCubes * 24 ] =
{
};

CIwSVec3 movingToStaticNormals[ numCubes * 24 ] =
{
};

// temp arrays to store for rotating static cube animation
CIwSVec3 cubePositionsTemp[ numCubes * 24 ] = {};
CIwSVec3 movingCubePositionsTemp[ numCubes * 24 ] = {};

// arrays for vertices for MATERIALS
CIwSVec3 redSolidVertices[ numCubes*24 ] = {};
CIwSVec3 greenSolidVertices[ numCubes*24 ] = {};
CIwSVec3 blueSolidVertices[ numCubes*24 ] = {};
CIwSVec3 purpleSolidVertices[ numCubes*24 ] = {};
CIwSVec3 yellowSolidVertices[ numCubes*24 ] = {};
CIwSVec3 orangeSolidVertices[ numCubes*24 ] = {};

CIwSVec3 redTransVertices[ numCubes*24 ] = {};
CIwSVec3 greenTransVertices[ numCubes*24 ] = {};
CIwSVec3 blueTransVertices[ numCubes*24 ] = {};
CIwSVec3 purpleTransVertices[ numCubes*24 ] = {};
CIwSVec3 yellowTransVertices[ numCubes*24 ] = {};
CIwSVec3 orangeTransVertices[ numCubes*24 ] = {};

CIwSVec2 redSolidUVStream[ numCubes*24 ] = {};
CIwSVec2 greenSolidUVStream[ numCubes*24 ] = {};
CIwSVec2 blueSolidUVStream[ numCubes*24 ] = {};
CIwSVec2 purpleSolidUVStream[ numCubes*24 ] = {};
CIwSVec2 yellowSolidUVStream[ numCubes*24 ] = {};
CIwSVec2 orangeSolidUVStream[ numCubes*24 ] = {};

CIwSVec2 redTransUVStream[ numCubes*24 ] = {};
CIwSVec2 greenTransUVStream[ numCubes*24 ] = {};
CIwSVec2 blueTransUVStream[ numCubes*24 ] = {};
CIwSVec2 purpleTransUVStream[ numCubes*24 ] = {};
CIwSVec2 yellowTransUVStream[ numCubes*24 ] = {};
CIwSVec2 orangeTransUVStream[ numCubes*24 ] = {};

// arrays for the shadows
CIwSVec3 shadowVertices[numShadows * 24] ={};
CIwSVec3 shadowVerticesTranslated[numShadows * 24] ={};
CIwSVec3 shadowNormals[numShadows * 24] ={};
CIwSVec3 shadowVerticesTransparent[numShadows * 24] = {};
CIwSVec3 shadowVerticesTransparentTranslated[numShadows * 24] = {};
CIwSVec2 shadowUVStream[numShadows * 24] = {};

CIwSVec3 blueSolidShadowVertices[numShadows * 24] = {};
CIwSVec3 greenSolidShadowVertices[numShadows * 24] = {};
CIwSVec3 orangeSolidShadowVertices[numShadows * 24] = {};
CIwSVec3 purpleSolidShadowVertices[numShadows * 24] = {};
CIwSVec3 redSolidShadowVertices[numShadows * 24] = {};
CIwSVec3 yellowSolidShadowVertices[numShadows * 24] = {};

CIwSVec3 blueTransShadowVertices[numShadows * 24] = {};
CIwSVec3 greenTransShadowVertices[numShadows * 24] = {};
CIwSVec3 orangeTransShadowVertices[numShadows * 24] = {};
CIwSVec3 purpleTransShadowVertices[numShadows * 24] = {};
CIwSVec3 redTransShadowVertices[numShadows * 24] = {};
CIwSVec3 yellowTransShadowVertices[numShadows * 24] = {};

CIwSVec3 blueSolidShadowNormals[numShadows * 24] = {};
CIwSVec3 greenSolidShadowNormals[numShadows * 24] = {};
CIwSVec3 orangeSolidShadowNormals[numShadows * 24] = {};
CIwSVec3 purpleSolidShadowNormals[numShadows * 24] = {};
CIwSVec3 redSolidShadowNormals[numShadows * 24] = {};
CIwSVec3 yellowSolidShadowNormals[numShadows * 24] = {};

// arrays for sides for static cube
CIwSVec3 staticSideVertices[ numStaticSides * 4 ] = {};
CIwSVec3 staticSideVerticesTranslated[numStaticSides * 4] = {};
CIwSVec3 staticSideNormals[ numStaticSides * 4 ] = {};

CIwSVec3 staticSide1Vertices[numStaticSides * 4] ={};
CIwSVec3 staticSide1VerticesTranslated[numStaticSides * 4] ={};
CIwSVec3 staticSide1Normals[numStaticSides * 4] ={};

CIwSVec3 staticSide2Vertices[numStaticSides * 4] ={};
CIwSVec3 staticSide2VerticesTranslated[numStaticSides * 4] ={};
CIwSVec3 staticSide2Normals[numStaticSides * 4] ={};

CIwSVec3 staticSide3Vertices[numStaticSides * 4] ={};
CIwSVec3 staticSide3VerticesTranslated[numStaticSides * 4] ={};
CIwSVec3 staticSide3Normals[numStaticSides * 4] ={};

CIwSVec3 staticSide4Vertices[numStaticSides * 4] ={};
CIwSVec3 staticSide4VerticesTranslated[numStaticSides * 4] ={};
CIwSVec3 staticSide4Normals[numStaticSides * 4] ={};

CIwSVec3 staticSide5Vertices[numStaticSides * 4] ={};
CIwSVec3 staticSide5VerticesTranslated[numStaticSides * 4] ={};
CIwSVec3 staticSide5Normals[numStaticSides * 4] ={};

CIwSVec3 staticSide6Vertices[numStaticSides * 4] ={};
CIwSVec3 staticSide6VerticesTranslated[numStaticSides * 4] ={};
CIwSVec3 staticSide6Normals[numStaticSides * 4] ={};

// vertices for interpolation animation
CIwSVec3 staticSide1VerticesInterp[numStaticSides * 4] ={};
CIwSVec3 staticSide1VerticesTranslatedInterp[numStaticSides * 4] ={};
CIwSVec3 staticSide1NormalsInterp[numStaticSides * 4] ={};

CIwSVec3 staticSide2VerticesInterp[numStaticSides * 4] ={};
CIwSVec3 staticSide2VerticesTranslatedInterp[numStaticSides * 4] ={};
CIwSVec3 staticSide2NormalsInterp[numStaticSides * 4] ={};

CIwSVec3 staticSide3VerticesInterp[numStaticSides * 4] ={};
CIwSVec3 staticSide3VerticesTranslatedInterp[numStaticSides * 4] ={};
CIwSVec3 staticSide3NormalsInterp[numStaticSides * 4] ={};

CIwSVec3 staticSide4VerticesInterp[numStaticSides * 4] ={};
CIwSVec3 staticSide4VerticesTranslatedInterp[numStaticSides * 4] ={};
CIwSVec3 staticSide4NormalsInterp[numStaticSides * 4] ={};

CIwSVec3 staticSide5VerticesInterp[numStaticSides * 4] ={};
CIwSVec3 staticSide5VerticesTranslatedInterp[numStaticSides * 4] ={};
CIwSVec3 staticSide5NormalsInterp[numStaticSides * 4] ={};

CIwSVec3 staticSide6VerticesInterp[numStaticSides * 4] ={};
CIwSVec3 staticSide6VerticesTranslatedInterp[numStaticSides * 4] ={};
CIwSVec3 staticSide6NormalsInterp[numStaticSides * 4] ={};


// Not used
// splits up the total vertices into smaller streams for drawprim
// capped at 20 cubes per stream[x]
CIwSVec3 cubeTranslatedStream[21][24 * 20] = 
{
};


// METHODS-----------

// TOUCH1 methods
void MultiTouchButton( s3ePointerTouchEvent* event )
{
	if( event->m_TouchID == 0 )
	{
		x1 = event->m_x;
		y1 = event->m_y;

		// SHADOW1
		motionX1 = x1; // for shadow
		motionY1 = y1;
	}
	else if( event->m_TouchID == 1 )
	{
		x2 = event->m_x;
		y2 = event->m_y;
	}

	
	// zooming
	// Sets what kinds of touch are active
	if( event->m_TouchID == 1 )// if there is a second touch, simulTouch is true
	{
		if( event->m_Pressed == 1 ) // if the second touch is activated
		{
			// disable button presses			
			rightButton.initialPressed = false;
			rightButton.pressed = false;
			leftButton.initialPressed = false;
			leftButton.pressed = false;
			upButton.initialPressed = false;
			upButton.pressed = false;
			downButton.initialPressed = false;
			downButton.pressed = false;

			// disable menus for menu cube
			// release Menu Cube buttons
			for( int i = 0; i < numOfActiveMenuCubes; i++ )
			{
				menuCubes[i].button.pressed = false;
			}
			multiTouchDisableMenu = true;

			// immediately disable the drop tap when a second touch is activated
			dropTap = false;

			isTouched2 = (bool)event->m_Pressed;

			isSimulTouched = true;
			rotateEnabled = false;
			touchMusic = false;

			// enable if first finger is also touched
			if( isTouched1 )
			{
				// zoomEnabled = true; // disabled zooming
				// if first touch is still touching, for touchdrag with second finger
				x1 = x1 - deltaX1;
				y1 = y1 - deltaY1;				
				// calculates the zoom sensitivity
				zoomSensitivity = zoomSensitivityMin + zoomSensitivityDelta * ((cameraDepth*-1) - zoomInLimit); // this will replace the zoomSensitivityMultiplier, calculated on zoom activation touch
			}

			//this ensures that zooming does not happen with current deltaX from rotation when second finger touches
			deltaX1 = 0;
			deltaY1 = 0;
			deltaX1Two = 0;

			// initialize a starting distance for delta distance for zoom
			startDistance = sqrt( pow( x1 - x2, 2 ) + pow( y1 - y2, 2 ) );
		}
		else // if second touch is deactivated
		{
			// multitouched setting to false is later on, so that either untouch triggers it
			isTouched2 = false;
		}
	}
	
	if( event->m_TouchID == 0 ) // if it is the first touch
	{
		// skipping cutscene
		if( allowCinemaSkip == true && s3eVideoIsPlaying() == true )
		{
			stopCinema = true;
		}

		isTouched1 = (bool)event->m_Pressed;
		if( isTouched1 == true ) // if first touch is pressed
		{			

			touchMusic = true;

			if( GameState == AT_MENU )
			{
				// enable new story confirmation buttons
				if( enableNewStoryConfirmationScreen == true )
				{
					for( int i = 0; i < newStoryConfirmationScreen.buttonCount; i++ )
					{
						if( newStoryConfirmationScreen.button[i].isPressed( x1, y1 ) )
						{
							newStoryConfirmationScreen.button[i].initialPressed = true;
							newStoryConfirmationScreen.button[i].pressed = true;
						}
					}

				}
				else // regular menu buttons
				{
					// Reset Menu Cubes for Swiping
					for( int i = 0; i < numOfActiveMenuCubes; i++ )
					{
						menuCubes[i].releaseSwipe();
					}
					deltaX1 = 0;
					deltaX1Two = 0;

					// Pressing Menu Buttons
					for( int i = 0; i < numOfActiveMenuCubes; i++ )
					{
						if( showQuestionMarkScreen == false )
						{
							if( menuCubes[i].isTouched( x1, y1 ) )
							{
								menuCubes[i].button.initialPressed = true;
								menuCubes[i].button.pressed = true;
								break; // break out of loop searching for menu cubes once one is touched
							}
						}
						else
						{
							showQuestionMarkScreen = false;
							ResetMenuButtonBobble();
						}
					}
				}

			} // end of if game state == at menu
			else if( GameState == PLAY_GAME )
			{
				rotateEnabled = true;
				// enables possible tap action, for dropping down the cube							
				dropTap = true;
				initialTapMS = s3eTimerGetMs();

				// AUTOSNAP disable
				autosnap = false;

				// FLOATING OBJECT has priority over rotate buttons
				if( testFO.isTouched( x1, y1 ) && testFO.activated == true )
				{
					testFO.makeTransition();
				}
				// ROTATE BUTTON. Add a boolean to allow rotation only if cubes are not spawning
				else if( spawningSetCounter >= 1 ) // if 1 frame has passed and after a whole set was done spawning and have moved 1 frame
				{
					if( rightButton.isPressed( x1, y1 ) )
					{
						rightButton.initialPressed = true;
						rightButton.pressed = true;
						rotateEnabled = false;
						dropTap = false; // disable drop tap if a button is pressed

						AddOneAPM();
					}
					else if( leftButton.isPressed( x1, y1 ) )
					{
						leftButton.initialPressed = true;
						leftButton.pressed = true;
						rotateEnabled = false;
						dropTap = false; // disable drop tap if a button is pressed

						AddOneAPM();
					}
					else if( upButton.isPressed( x1, y1 ) )
					{
						upButton.initialPressed = true;
						upButton.pressed = true;
						rotateEnabled = false;
						dropTap = false; // disable drop tap if a button is pressed

						AddOneAPM();
					}
					else if( downButton.isPressed( x1, y1 ) )
					{
						downButton.initialPressed = true;
						downButton.pressed = true;
						rotateEnabled = false;
						dropTap = false; // disable drop tap if a button is pressed

						AddOneAPM();
					}
					else if( rotateButton.isPressed( x1, y1 ) )
					{
						rotateButton.initialPressed = true;
						rotateButton.pressed = true;
						rotateEnabled = false;

						AddOneAPM();
					}
					else if( pauseButton.isPressed( x1, y1 ) )
					{
						pauseButton.initialPressed = true;
						pauseButton.pressed = true;
						rotateEnabled = false;
					}
				}

				// SHADOW1
				// untouch all shadows
				for( int i = 0; i < numShadowsIndex; i++ )
				{
					shadowArray[i].touched = false;
					// set all initial positions
					shadowArray[i].initialPosition = shadowArray[i].position;

					shadowIsTouched = false;
				}

				// QFI - add one apm
				bool shadowFoundIncreaseAPM = false;

				for( int i = 0; i < numShadowsIndex; i++ ) // checks to see if a shadow is touched
				{
					// sets model matrix before calculating to make sure no glitches
					shadowArray[i].setModelMatrix( modelMatrix1 );

					// only checks the shadow touch if its linked cube is not already dropped
					if( shadowArray[i].isTouched( x1, y1 ) && shadowArray[i].shadowGroup->dropCubes == false )
					{

						shadowIsTouched = true;

						shadowFoundIncreaseAPM = true;

						if( selectedShadow != NULL ) // ensures only one shadow, the closest shadow, gets activated as touched and as the "selectedshadow"
						{
							int16 zDistance = 0; //zDistance is the shadow's zDistance from the camera, finds closest shadow being touched
							int16 zDistanceOriginal = 0;
							CIwVec3 location = tt1.TransformVec(shadowArray[i].position);
							CIwVec3 locationOriginal = tt1.TransformVec( selectedShadow->position );
							zDistance = abs(view.t.z) - abs(location.z);
							zDistanceOriginal = abs(view.t.z) - abs(locationOriginal.z);

							if( zDistance < zDistanceOriginal )
							{
								selectedShadow->touched = false;
								selectedShadow = shadowArray + i;
								selectedShadow->touched = true;
							}

						}
						else
						{
							selectedShadow = shadowArray + i;
							selectedShadow->touched = true;
						}

						//shadowArray[i].touched = true;
						rotateEnabled = false;
					}

				} // end of for loop checking for closest shadow

				// finds the layer level of the closest cube on touch of shadow to determine move sensitivity
				if( selectedShadow != NULL )
				{
					layerLevelOnTouch = selectedShadow->cube->closestLandingCube->layerLevel;
				}

				if( shadowFoundIncreaseAPM == true )
				{
					AddOneAPM();
				}

				// Rotation re-adjustment when on facesides 5 or 6
				// This turns the cube clockwise or counter clockwise
				// based on where the user touches the screen when faceside 5 or 6 is facing camera. 
				/* Intuitively, users touch and drag the top portion of the screen toward right to rotate the cube
				clockwise, and touch-drag the bottom half of screen toward right to
				rotate counterclockwise, regardless of what angle the x-axis is rotated on.
				This overrides the reversed index in TouchMotion()
				*/
				if( getActiveFaceSide() == 5 )
				{
					if( y1 > IwGxGetScreenHeight() /2 )
						reversedIndex = 1;
					else
						reversedIndex = -1;
				}
				else if( getActiveFaceSide() == 6 )
				{
					if( y1 > IwGxGetScreenHeight() /2 )
						reversedIndex = -1;
					else
						reversedIndex = 1;
				}
			} // end of if game state == play game
			else if( GameState == AT_CHALLENGE_MENU_SCREEN )
			{
				for( int i = 0; i < menuScreen[0].buttonCount; i++ )
				{
					if( menuScreen[0].button[i].isPressed( x1, y1 ) )
					{
						menuScreen[0].button[i].initialPressed = true;
						menuScreen[0].button[i].pressed = true;
						rotateEnabled = false;
					}
				}
			}
			else if( GameState == AT_HIGH_SCORE_MENU_SCREEN )
			{
				if( showTrophyMessage == false )
				{
					for( int i = 0; i < menuScreen[1].buttonCount; i++ )
					{
						if( menuScreen[1].button[i].isPressed( x1, y1 ) )
						{
							menuScreen[1].button[i].initialPressed = true;
							menuScreen[1].button[i].pressed = true;
							rotateEnabled = false;
						}
					}
				}
				else // if show trophy message is true, set to false.
				{
					showTrophyMessage = false;
				}
			}
			else if( GameState == AT_CREDITS_MENU_SCREEN )
			{
				for( int i = 0; i < menuScreen[2].buttonCount; i++ )
				{
					if( menuScreen[2].button[i].isPressed( x1, y1 ) )
					{
						menuScreen[2].button[i].initialPressed = true;
						menuScreen[2].button[i].pressed = true;
						rotateEnabled = false;
					}
				}
			}
			else if( GameState == AT_TUTORIAL_MENU_SCREEN )
			{
				for( int i = 0; i < menuScreen[3].buttonCount; i++ )
				{
					if( menuScreen[3].button[i].isPressed( x1, y1 ) )
					{
						menuScreen[3].button[i].initialPressed = true;
						menuScreen[3].button[i].pressed = true;
						rotateEnabled = false;
					}
				}
			}
			else if( GameState == AT_SCORE_SCREEN )
			{
				// enable quit confirmation buttons
				if( enableQuitConfirmationScreen == true )
				{
					for( int i = 0; i < quitConfirmationScreen.buttonCount; i++ )
					{
						if( quitConfirmationScreen.button[i].isPressed( x1, y1 ) )
						{
							quitConfirmationScreen.button[i].initialPressed = true;
							quitConfirmationScreen.button[i].pressed = true;
						}
					}

				}
				else
				{
					if( quitButton.isPressed( x1, y1 ) )
					{
						quitButton.initialPressed = true;
						quitButton.pressed = true;
						rotateEnabled = false;
					}

					if( restartButton.isPressed( x1, y1 ) )
					{
						restartButton.initialPressed = true;
						restartButton.pressed = true;
						rotateEnabled = false;
					}

					if( storyMode == true )
					{
						if( advanceToNextLevel == true )
						{
							if( nextButton.isPressed( x1, y1 ) )
							{
								nextButton.initialPressed = true;
								nextButton.pressed = true;
								rotateEnabled = false;
							}
						}
					}
				}
			}
			else if( GameState == PAUSED )
			{
				// enable quit confirmation buttons
				if( enableQuitConfirmationScreen == true )
				{
					for( int i = 0; i < quitConfirmationScreen.buttonCount; i++ )
					{
						if( quitConfirmationScreen.button[i].isPressed( x1, y1 ) )
						{
							quitConfirmationScreen.button[i].initialPressed = true;
							quitConfirmationScreen.button[i].pressed = true;
						}
					}

				}
				else // normal pause buttons behavior
				{
					if( resumeButton.isPressed( x1, y1 ) )
					{
						resumeButton.initialPressed = true;
						resumeButton.pressed = true;
						rotateEnabled = false;

						playClickSound();
					}

					if( quitButton.isPressed( x1, y1 ) )
					{
						quitButton.initialPressed = true;
						quitButton.pressed = true;
						rotateEnabled = false;

						playClickSound();
					}

					if( restartButton.isPressed( x1, y1 ) )
					{
						restartButton.initialPressed = true;
						restartButton.pressed = true;
						rotateEnabled = false;

						playClickSound();
					}

					if( testButton.isPressed( x1, y1 ) )
					{
						testButton.initialPressed = true;
						testButton.pressed = true;
						rotateEnabled = false;
					}
				}	
			}
			else if( GameState == CHOOSE_DIFFICULTY )
			{
				if( testButton.isPressed( x1, y1 ) )
				{
					testButton.initialPressed = true;
					testButton.pressed = true;
					rotateEnabled = false;
				}
				if( difficultyStartButton.isPressed( x1, y1 ) )
				{
					difficultyStartButton.initialPressed = true;
					difficultyStartButton.pressed = true;
					rotateEnabled = false;
				}
				if( difficultyEasyButton.isPressed( x1, y1 ) )
				{
					difficultyEasyButton.initialPressed = true;
					difficultyEasyButton.pressed = true;
					rotateEnabled = false;
				}

				if( difficultyMediumButton.isPressed( x1, y1 ) )
				{
					difficultyMediumButton.initialPressed = true;
					difficultyMediumButton.pressed = true;
					rotateEnabled = false;
				}

				if( difficultyHardButton.isPressed( x1, y1 ) )
				{
					difficultyHardButton.initialPressed = true;
					difficultyHardButton.pressed = true;
					rotateEnabled = false;
				}
			}
			else if( GameState == PLAY_TUTORIAL )	
			{
				// disable rotate for tutorial
				rotateEnabled = false;

				// enable rotate for tutorial
				if( tutorialNumber >= 5 )
				{
					rotateEnabled = true;
				}

				dropTap = true;
				initialTapMS = s3eTimerGetMs();

				// AUTOSNAP disable
				autosnap = false;

				// FLOATING OBJECT has priority over rotate buttons
				if( testFO.isTouched( x1, y1 ) && testFO.activated == true )
				{
					testFO.makeTransition();
				}
				// ROTATE BUTTON. Add a boolean to allow rotation only if cubes are not spawning
				else if( spawningSetCounter >= 1 ) // if 1 frame has passed and after a whole set was done spawning and have moved 1 frame
				{
					if( rightButton.isPressed( x1, y1 ) )
					{
						rightButton.initialPressed = true;
						rightButton.pressed = true;
						rotateEnabled = false;
						dropTap = false; // disable drop tap if a button is pressed
					}
					else if( leftButton.isPressed( x1, y1 ) )
					{
						leftButton.initialPressed = true;
						leftButton.pressed = true;
						rotateEnabled = false;
						dropTap = false; // disable drop tap if a button is pressed
					}
					else if( upButton.isPressed( x1, y1 ) )
					{
						upButton.initialPressed = true;
						upButton.pressed = true;
						rotateEnabled = false;
						dropTap = false; // disable drop tap if a button is pressed
					}
					else if( downButton.isPressed( x1, y1 ) )
					{
						downButton.initialPressed = true;
						downButton.pressed = true;
						rotateEnabled = false;
						dropTap = false; // disable drop tap if a button is pressed
					}
					else if( rotateButton.isPressed( x1, y1 ) )
					{
						rotateButton.initialPressed = true;
						rotateButton.pressed = true;
						rotateEnabled = false;
					}
					else if( pauseButton.isPressed( x1, y1 ) )
					{
						pauseButton.initialPressed = true;
						pauseButton.pressed = true;
						rotateEnabled = false;
					}
					else if( tutorialLeftButton.isPressed( x1, y1 ) )
					{
						tutorialLeftButton.initialPressed = true;
						tutorialLeftButton.pressed = true;
						rotateEnabled = false;
					}
					else if( tutorialRightButton.isPressed( x1, y1 ) )
					{
						tutorialRightButton.initialPressed = true;
						tutorialRightButton.pressed = true;
						rotateEnabled = false;
					}
				}

				// SHADOW1
				// untouch all shadows
				for( int i = 0; i < numShadowsIndex; i++ )
				{
					shadowArray[i].touched = false;
					// set all initial positions
					shadowArray[i].initialPosition = shadowArray[i].position;

					shadowIsTouched = false;
				}

				for( int i = 0; i < numShadowsIndex; i++ ) // checks to see if a shadow is touched
				{
					// sets model matrix before calculating to make sure no glitches
					shadowArray[i].setModelMatrix( modelMatrix1 );

					// only checks the shadow touch if its linked cube is not already dropped
					if( shadowArray[i].isTouched( x1, y1 ) && shadowArray[i].shadowGroup->dropCubes == false )
					{
						shadowIsTouched = true;

						if( selectedShadow != NULL )
						{
							int16 zDistance = 0; //zDistance is the shadow's zDistance from the camera, finds closest shadow being touched
							int16 zDistanceOriginal = 0;
							CIwVec3 location = tt1.TransformVec(shadowArray[i].position);
							CIwVec3 locationOriginal = tt1.TransformVec( selectedShadow->position );
							zDistance = abs(view.t.z) - abs(location.z);
							zDistanceOriginal = abs(view.t.z) - abs(locationOriginal.z);

							if( zDistance < zDistanceOriginal )
							{
								selectedShadow->touched = false;
								selectedShadow = shadowArray + i;
								selectedShadow->touched = true;
							}
						}
						else
						{
							selectedShadow = shadowArray + i;
							selectedShadow->touched = true;
						}

						//shadowArray[i].touched = true;
						rotateEnabled = false;
					}
				} // end of for loop checking for closest shadow

				// Rotation re-adjustment when on facesides 5 or 6
				// This turns the cube clockwise or counter clockwise
				// based on where the user touches the screen when faceside 5 or 6 is facing camera. 
				/* Intuitively, users touch and drag the top portion of the screen toward right to rotate the cube
				clockwise, and touch-drag the bottom half of screen toward right to
				rotate counterclockwise, regardless of what angle the x-axis is rotated on.
				This overrides the reversed index in TouchMotion()
				*/
				if( getActiveFaceSide() == 5 )
				{
					if( y1 > IwGxGetScreenHeight() /2 )
						reversedIndex = 1;
					else
						reversedIndex = -1;
				}
				else if( getActiveFaceSide() == 6 )
				{
					if( y1 > IwGxGetScreenHeight() /2 )
						reversedIndex = -1;
					else
						reversedIndex = 1;
				}
			} // end of if gamestate == play tutorial

		} // end of if first touch is pressed
		else // if first touch is released
		{
			if( GameState == AT_MENU )
			{
				// check for pressed Menu Cube buttons during release
				ReleaseMenuButtons();
				ReleaseNewStoryConfirmationButtons();

				/*
				if( menuCube.highScoreButton.isTouched( motionX1, motionY1 ) ) // high score released
				{
					menuCube.highScoreButton.activated = true;
				}
				if( menuCube.helpButton.isTouched( motionX1, motionY1 ) ) // help released
				{
					menuCube.helpButton.activated = true;
					// Activates Tutorial
					GameState = AT_DISPLAY_LOADING_TUTORIAL;
				}
				if( menuCube.creditsButton.isTouched( motionX1, motionY1 ) ) // credits released
				{
					menuCube.creditsButton.activated = true;
				}
				if( menuCube.highScoreBackButton.isTouched( motionX1, motionY1 ) ) // high score back released
				{
					menuCube.highScoreBackButton.activated = true;
				}
				if( menuCube.helpBackButton.isTouched( motionX1, motionY1 ) ) // help back released
				{
					menuCube.helpBackButton.activated = true;
				}
				if( menuCube.creditsBackButton.isTouched( motionX1, motionY1 ) ) // credits back released
				{
					menuCube.creditsBackButton.activated = true;
				}
				*/

				// release Menu Cube buttons
				/*
				menuCube.highScoreButton.pressed = false;
				menuCube.helpButton.pressed = false;
				menuCube.creditsButton.pressed = false;
				menuCube.highScoreBackButton.pressed = false;
				menuCube.helpBackButton.pressed = false;
				menuCube.creditsBackButton.pressed = false;
				*/
			} // end of if GameState == AT_MENU
			else if( GameState == PLAY_GAME )
			{
				// AUTOSNAP release		
				ResetAutoSnapVariables();
				autosnap = true;

				// ROTATE BUTTON Release
				ReleaseButtons();
			
				// Drop Tap
				// NO EXPLODING CUBES check
				cubeIsExploding = false;
				int16 dir = 0;
				for( int i = numOriginalCubes; i < numStaticCubes; i++ )
				{
					if( cubeArray[i].exploding == true )
					{
						dir = cubeArray[i].direction;
						if( dir == getActiveFaceSide() )
						{
							cubeIsExploding = true;
							break;
						}
					}
				}
				
				//if( dropTap == true && cubeIsExploding == false )
				if( dropTap == true )
				{
					if( selectedShadow != NULL )
					{
						selectedShadow->shadowGroup->dropCubes = true;
						cubeIsDropping = true;
						dropCubes();


						// QFI - Multitasking index calculating total distance to landing
						// multitasking index and comfort index are only calculated if the spawn types are RANDOM
						// otherwise you can just move and choose to not drop and let cubes fall if they spawn INCOLOR
						if( true /* cubeSpawning != DOUBLE_INCOLOR && 
							cubeSpawning != TRIPLE_INCOLOR && 
							cubeSpawning != QUADRUPLE_INCOLOR && 
							cubeSpawning != QUINTUPLE_INCOLOR && 
							cubeSpawning != SEXTUPLE_INCOLOR */ )
						{
							double averageGroupDTL = 0;
							int16 tempNumCubes = 0;
							// find cubes that are dropping from droptap
							for( int i = 0; i < numMovingCubesIndex; i++ )
							{
								if( cubeArrayMoving[i].shadow->shadowGroup->dropCubes == true )
								{
									averageGroupDTL += cubeArrayMoving[i].distanceToLanding;
									tempNumCubes++;
								}
							}
							averageGroupDTL = averageGroupDTL / tempNumCubes;
							averageGroupDTL = averageGroupDTL / s; // divide by s to prevent overflow in totalDTL to make numbers smaller

							totalDTL += averageGroupDTL;
							totalDroppedCubeSets++;

							totalDTLCurrent += averageGroupDTL;
							totalDroppedCubeSetsCurrent++;
						}
					}
				}

				// untouch shadows
				UntouchShadows();

				// checking rotateEnabled ensures that it is checked only after a rotation is happening.F
				// It is possible to have a touch release from tap-drag with first finger with second touch ongoing
				// We do not want this to be checked in those circumstances
				if( rotateEnabled == true ) // corrects x-axis direction rotation
				{
					// CAMERA x-axis rotation direction re-alignment
					// method 3
					// Imitate the Maya transforms
					CorrectReversedIndex();
				} // end of y-axis rotation correction

				// wraps the rotation values
				// so that it doesn't get overflowed
				worldX = worldX % 4096;
				worldY = worldY % 4096;

				// saves the rotation
				savedX = worldX / rotateSensitivityMultiplier;
				savedY = worldY / rotateSensitivityMultiplier;

				// for shadows
				deltaX1 = 0;
				deltaY1 = 0;

				isTouched1 = false;
				rotateEnabled = false;

				// resets variables for zoom
				startDistance = 0; // not sure if this does anything

				/*
				// if there are no multitouch or zoom interfering
				if( touchMusic == true )
				{
					// music playing, if touches triangle
					if( musicIsPlaying == false && intersected == true )
					{
						s3eIOSBackgroundMusicPlay();
						musicIsPlaying = true;
					}
					else if( musicIsPlaying == true && intersected == true ) // if music is playing, turn off / pause
					{
						s3eIOSBackgroundMusicPause();
						musicIsPlaying = false;
					}
				}*/
			} // end of if GameState == PLAY_GAME
			else if( GameState == AT_CHALLENGE_MENU_SCREEN )
			{
				ReleaseChallengeMenuScreenButtons();
			}
			else if( GameState == AT_HIGH_SCORE_MENU_SCREEN )
			{
				ReleaseHighScoreMenuScreenButtons();
			}
			else if( GameState == AT_CREDITS_MENU_SCREEN )
			{
				ReleaseCreditsMenuScreenButtons();
			}
			else if( GameState == AT_TUTORIAL_MENU_SCREEN )
			{
				ReleaseTutorialMenuScreenButtons();
			}
			else if( GameState == AT_SCORE_SCREEN )
			{
				ReleaseScoreScreenButtons();
				ReleaseQuitConfirmationButtons();
			}
			else if( GameState == PAUSED )
			{
				ReleasePausedButtons();
				ReleaseQuitConfirmationButtons();
			}
			else if( GameState == CHOOSE_DIFFICULTY )
			{
				ReleaseDifficultyButtons();
			}
			else if( GameState == PLAY_TUTORIAL )
			{
				// AUTOSNAP release		
				ResetAutoSnapVariables();
				autosnap = true;

				// ROTATE BUTTON Release
				ReleaseButtons();

				// Drop Tap
				// NO EXPLODING CUBES check
				cubeIsExploding = false;
				int16 dir = 0;
				for( int i = numOriginalCubes; i < numStaticCubes; i++ )
				{
					if( cubeArray[i].exploding == true )
					{
						dir = cubeArray[i].direction;
						if( dir == getActiveFaceSide() )
						{
							cubeIsExploding = true;
							break;
						}
					}
				}

				// disable droptap for tutorial levels 1 and 2
				if( tutorialNumber == 1 || tutorialNumber == 2 )
				{
					dropTap = false;
				}

				//if( dropTap == true && cubeIsExploding == false )
				if( dropTap == true )
				{
					if( selectedShadow != NULL )
					{
						selectedShadow->shadowGroup->dropCubes = true;
						cubeIsDropping = true;
						dropCubes();
					}
				}

				// untouch shadows
				UntouchShadows();

				// checking rotateEnabled ensures that it is checked only after a rotation is happening.F
				// It is possible to have a touch release from tap-drag with first finger with second touch ongoing
				// We do not want this to be checked in those circumstances
				if( rotateEnabled == true ) // corrects x-axis direction rotation
				{
					// CAMERA x-axis rotation direction re-alignment
					// method 3
					// Imitate the Maya transforms
					CorrectReversedIndex();
				} // end of y-axis rotation correction

				// wraps the rotation values
				// so that it doesn't get overflowed
				worldX = worldX % 4096;
				worldY = worldY % 4096;

				// saves the rotation
				savedX = worldX / rotateSensitivityMultiplier;
				savedY = worldY / rotateSensitivityMultiplier;

				// for shadows
				deltaX1 = 0;
				deltaY1 = 0;

				isTouched1 = false;
				rotateEnabled = false;

				// resets variables for zoom
				startDistance = 0; // not sure if this does anything
			}
		} // End of first touch release
	} // End of first touch ID

	// Used to reset variables for ZOOM if either touch is released
	// Having isSimulTouched rather than checking touch1 and touch1 is like checking the past, 
	// seeing if it ever WAS touched by both fingers
	if(  isSimulTouched == true && event->m_Pressed == 0 ) // this can probably be copied to the touch Releases of both touches
	{
		isSimulTouched = false;
		zoomEnabled = false;

		// saves zoom data
		savedDepth = cameraDepth;

		//startDistance = 0;
		endDistance = 0;
		savedDepth = cameraDepth;


		// delta's needed to be preserved in order to correct
		// the x1, y1, x2, y2 values for distance checking when 1 of 2 touches is
		// released and retouched. This happens on the touch events
	}

	// both touches are off the screen
	if( isTouched1 == false && isTouched2 == false )
	{
		// reset delta variables for zoom so it doesn't zoom on touch'
		// since distance = sum of delta's
		
		/*deltaX1 = 0; Need deltaX1 to be in existance for swiping. Zooming is disabled anyway
		deltaY1 = 0;
		deltaX2 = 0;
		deltaY2 = 0;
		*/
		// And the endDistance for determining zoom IN or OUT uses dragged variables
		draggedX1 = 0;
		draggedY1 = 0;
		draggedX2 = 0;
		draggedY2 = 0;
		// distance = 0;
		
		// re-enable menu's
		multiTouchDisableMenu = false;
		zooming = false;
	}
}

void SingleTouchButton( s3ePointerTouchEvent* event )
{
	x1 = event->m_x;
	y1 = event->m_y;

	motionX1 = x1; // for shadow
	motionY1 = y1;

	isTouched = (bool)event->m_Pressed;

	if( isTouched ) // limbo disables all buttons when they are pressed
	{
		// skipping cutscene
		if( allowCinemaSkip == true && s3eVideoIsPlaying() == true )
		{
			stopCinema = true;
		}

		if( GameState == AT_MENU )
		{
			// enable new story confirmation buttons
			if( enableNewStoryConfirmationScreen == true )
			{
				for( int i = 0; i < newStoryConfirmationScreen.buttonCount; i++ )
				{
					if( newStoryConfirmationScreen.button[i].isPressed( x1, y1 ) )
					{
						newStoryConfirmationScreen.button[i].initialPressed = true;
						newStoryConfirmationScreen.button[i].pressed = true;
					}
				}

			}
			else // regular menu buttons
			{
				// Reset Menu Cubes for Swiping
				for( int i = 0; i < numOfActiveMenuCubes; i++ )
				{
					menuCubes[i].releaseSwipe();
				}
				deltaX1 = 0;
				deltaX1Two = 0;

				// Pressing Menu Buttons
				for( int i = 0; i < numOfActiveMenuCubes; i++ )
				{
					if( showQuestionMarkScreen == false )
					{
						if( menuCubes[i].isTouched( x1, y1 ) )
						{
							menuCubes[i].button.initialPressed = true;
							menuCubes[i].button.pressed = true;
							break; // break out of loop searching for menu cubes once one is touched
						}
					}
					else
					{
						showQuestionMarkScreen = false;
						ResetMenuButtonBobble();
					}
				}
			}
		}
		else if( GameState == PLAY_GAME )
		{
			rotateEnabled = true;

			// AUTOSNAP disable
			autosnap = false;

			// enables possible tap action, for dropping down the cube				
			dropTap = true;
			initialTapMS = s3eTimerGetMs();

			// FLOATING OBJECTS
			if( testFO.isTouched( x1, y1 ) && testFO.activated == true )
			{
				testFO.makeTransition();
			}
			// ROTATE BUTTON. Add a boolean to allow rotation only if cubes are not spawning
			// cubes in play affect whether or not buttons are pressed
			else if( spawningSetCounter >= 1 ) // if 1 frame has passed and after a whole set was done spawning and have moved 1 frame
			{
				if( rightButton.isPressed( x1, y1 ) )
				{
					rightButton.initialPressed = true;
					rightButton.pressed = true;
					rotateEnabled = false;
					dropTap = false; // disable drop tap if a button is pressed

					AddOneAPM();
				}
				else if( leftButton.isPressed( x1, y1 ) )
				{
					leftButton.initialPressed = true;
					leftButton.pressed = true;
					rotateEnabled = false;
					dropTap = false; // disable drop tap if a button is pressed

					AddOneAPM();
				}
				else if( upButton.isPressed( x1, y1 ) )
				{
					upButton.initialPressed = true;
					upButton.pressed = true;
					rotateEnabled = false;
					dropTap = false; // disable drop tap if a button is pressed

					AddOneAPM();
				}
				else if( downButton.isPressed( x1, y1 ) )
				{
					downButton.initialPressed = true;
					downButton.pressed = true;
					rotateEnabled = false;
					dropTap = false; // disable drop tap if a button is pressed

					AddOneAPM();
				}
				else if( rotateButton.isPressed( x1, y1 ) )
				{
					rotateButton.initialPressed = true;
					rotateButton.pressed = true;
					rotateEnabled = false;

					AddOneAPM();
				}
				else if( pauseButton.isPressed( x1, y1 ) )
				{
					pauseButton.initialPressed = true;
					pauseButton.pressed = true;
					rotateEnabled = false;

					playClickSound();
				}
			}

			// SHADOW1
			// untouch all shadows
			for( int i = 0; i < numShadowsIndex; i++ )
			{
				shadowArray[i].touched = false;
				// set all initial positions
				shadowArray[i].initialPosition = shadowArray[i].position;

				shadowIsTouched = false;
			}

			// QFI add apm
			bool shadowFoundIncreaseAPM = false;

			for( int i = 0; i < numShadowsIndex; i++ ) // checks to see if a shadow is touched
			{
				// sets model matrix before calculating to make sure no glitches
				shadowArray[i].setModelMatrix( modelMatrix1 );

				// check for closest shadow
				// only checks the shadow touch if its linked cube is not already dropped
				if( shadowArray[i].isTouched( x1, y1 ) && shadowArray[i].shadowGroup->dropCubes == false )
				{
					shadowIsTouched = true;
					shadowFoundIncreaseAPM = true;

					if( selectedShadow != NULL ) // make sure only one shadow is touched
					{
						int16 zDistance = 0; //zDistance is the shadow's zDistance from the camera, finds closest shadow being touched
						int16 zDistanceOriginal = 0;
						CIwVec3 location = tt1.TransformVec(shadowArray[i].position);
						CIwVec3 locationOriginal = tt1.TransformVec( selectedShadow->position );
						zDistance = abs(view.t.z) - abs(location.z);
						zDistanceOriginal = abs(view.t.z) - abs(locationOriginal.z);

						if( zDistance < zDistanceOriginal )
						{
							selectedShadow->touched = false;
							selectedShadow = shadowArray + i;
							selectedShadow->touched = true;
						}
					}
					else
					{
						selectedShadow = shadowArray + i;
						selectedShadow->touched = true;
					}

					//shadowArray[i].touched = true;
					rotateEnabled = false;
				} // end of checking for closest shadow
			} // end of for loop seeing of shadows are touched

			// finds the layer level of the closest cube on touch of shadow to determine move sensitivity
			if( selectedShadow != NULL )
			{
				layerLevelOnTouch = selectedShadow->cube->closestLandingCube->layerLevel;
			}

			if( shadowFoundIncreaseAPM == true )
			{
				AddOneAPM();
			}

			// Rotation re-adjustment when on facesides 5 or 6
			// This turns the cube clockwise or counter clockwise
			// based on where the user touches the screen when faceside 5 or 6 is facing camera. 
			/* Intuitively, users touch and drag the top portion of the screen toward right to rotate the cube
			clockwise, and touch-drag the bottom half of screen toward right to
			rotate counterclockwise, regardless of what angle the x-axis is rotated on.
			This overrides the reversed index in TouchMotion()
			*/
			if( getActiveFaceSide() == 5 )
			{
				if( y1 > IwGxGetScreenHeight() /2 )
					reversedIndex = 1;
				else
					reversedIndex = -1;
			}
			else if( getActiveFaceSide() == 6 )
			{
				if( y1 > IwGxGetScreenHeight() /2 )
					reversedIndex = -1;
				else
					reversedIndex = 1;
			}
		} // end of if gamestate == play game		
		else if( GameState == AT_CHALLENGE_MENU_SCREEN )
		{
			for( int i = 0; i < menuScreen[0].buttonCount; i++ )
			{
				if( menuScreen[0].button[i].isPressed( x1, y1 ) )
				{
					menuScreen[0].button[i].initialPressed = true;
					menuScreen[0].button[i].pressed = true;
					rotateEnabled = false;
				}
			}
		}
		else if( GameState == AT_HIGH_SCORE_MENU_SCREEN )
		{
			if( showTrophyMessage == false )
			{
				for( int i = 0; i < menuScreen[1].buttonCount; i++ )
				{
					if( menuScreen[1].button[i].isPressed( x1, y1 ) )
					{
						menuScreen[1].button[i].initialPressed = true;
						menuScreen[1].button[i].pressed = true;
						rotateEnabled = false;

						if( i == 0 || i == 1 )
						{
							playClickSound();
						}
					}
				}
			}
			else // if show trophy message is true, set to false.
			{
				showTrophyMessage = false;
			}
		}
		else if( GameState == AT_CREDITS_MENU_SCREEN )
		{
			for( int i = 0; i < menuScreen[2].buttonCount; i++ )
			{
				if( menuScreen[2].button[i].isPressed( x1, y1 ) )
				{
					menuScreen[2].button[i].initialPressed = true;
					menuScreen[2].button[i].pressed = true;
					rotateEnabled = false;

					playClickSound();
				}
			}
		}
		else if( GameState == AT_TUTORIAL_MENU_SCREEN )
		{
			for( int i = 0; i < menuScreen[3].buttonCount; i++ )
			{
				if( menuScreen[3].button[i].isPressed( x1, y1 ) )
				{
					menuScreen[3].button[i].initialPressed = true;
					menuScreen[3].button[i].pressed = true;
					rotateEnabled = false;

					playClickSound();
				}
			}
		}
		else if( GameState == AT_SCORE_SCREEN )
		{
			// enable quit confirmation buttons
			if( enableQuitConfirmationScreen == true )
			{
				for( int i = 0; i < quitConfirmationScreen.buttonCount; i++ )
				{
					if( quitConfirmationScreen.button[i].isPressed( x1, y1 ) )
					{
						quitConfirmationScreen.button[i].initialPressed = true;
						quitConfirmationScreen.button[i].pressed = true;
					}
				}

			}
			else
			{
				if( quitButton.isPressed( x1, y1 ) )
				{
					quitButton.initialPressed = true;
					quitButton.pressed = true;
					rotateEnabled = false;
				}

				if( restartButton.isPressed( x1, y1 ) )
				{
					restartButton.initialPressed = true;
					restartButton.pressed = true;
					rotateEnabled = false;
				}

				if( storyMode == true )
				{
					if( advanceToNextLevel == true )
					{
						if( nextButton.isPressed( x1, y1 ) )
						{
							nextButton.initialPressed = true;
							nextButton.pressed = true;
							rotateEnabled = false;
						}
					}
				}
			}
		}
		else if( GameState == PAUSED )
		{
			// enable quit confirmation buttons
			if( enableQuitConfirmationScreen == true )
			{
				for( int i = 0; i < quitConfirmationScreen.buttonCount; i++ )
				{
					if( quitConfirmationScreen.button[i].isPressed( x1, y1 ) )
					{
						quitConfirmationScreen.button[i].initialPressed = true;
						quitConfirmationScreen.button[i].pressed = true;
					}
				}

			}
			else // normal pause buttons behavior
			{
				if( resumeButton.isPressed( x1, y1 ) )
				{
					resumeButton.initialPressed = true;
					resumeButton.pressed = true;
					rotateEnabled = false;

					playClickSound();
				}

				if( quitButton.isPressed( x1, y1 ) )
				{
					quitButton.initialPressed = true;
					quitButton.pressed = true;
					rotateEnabled = false;

					playClickSound();
				}

				if( restartButton.isPressed( x1, y1 ) )
				{
					restartButton.initialPressed = true;
					restartButton.pressed = true;
					rotateEnabled = false;

					playClickSound();
				}

				if( testButton.isPressed( x1, y1 ) )
				{
					testButton.initialPressed = true;
					testButton.pressed = true;
					rotateEnabled = false;
				}
			}			
		}
		else if( GameState == CHOOSE_DIFFICULTY )
		{
			if( testButton.isPressed( x1, y1 ) )
			{
				testButton.initialPressed = true;
				testButton.pressed = true;
				rotateEnabled = false;
			}
			if( difficultyStartButton.isPressed( x1, y1 ) )
			{
				difficultyStartButton.initialPressed = true;
				difficultyStartButton.pressed = true;
				rotateEnabled = false;
			}
			if( difficultyEasyButton.isPressed( x1, y1 ) )
			{
				difficultyEasyButton.initialPressed = true;
				difficultyEasyButton.pressed = true;
				rotateEnabled = false;
			}

			if( difficultyMediumButton.isPressed( x1, y1 ) )
			{
				difficultyMediumButton.initialPressed = true;
				difficultyMediumButton.pressed = true;
				rotateEnabled = false;
			}

			if( difficultyHardButton.isPressed( x1, y1 ) )
			{
				difficultyHardButton.initialPressed = true;
				difficultyHardButton.pressed = true;
				rotateEnabled = false;
			}
		}
		else if( GameState == PLAY_TUTORIAL )
		{
			// disable rotate for tutorial
			rotateEnabled = false;

			// enable rotate for tutorial
			if( tutorialNumber >= 5 )
			{
				rotateEnabled = true;
			}

			// AUTOSNAP disable
			autosnap = false;

			// enables possible tap action, for dropping down the cube				
			dropTap = true;
			initialTapMS = s3eTimerGetMs();

			// ROTATE BUTTON. Add a boolean to allow rotation only if cubes are not spawning
			if( spawningSetCounter >= 1 ) // if 1 frame has passed and after a whole set was done spawning and have moved 1 frame
			{
				if( rightButton.isPressed( x1, y1 ) )
				{
					rightButton.initialPressed = true;
					rightButton.pressed = true;
					rotateEnabled = false;
					dropTap = false; // disable drop tap if a button is pressed
				}
				else if( leftButton.isPressed( x1, y1 ) )
				{
					leftButton.initialPressed = true;
					leftButton.pressed = true;
					rotateEnabled = false;
					dropTap = false; // disable drop tap if a button is pressed
				}
				else if( upButton.isPressed( x1, y1 ) )
				{
					upButton.initialPressed = true;
					upButton.pressed = true;
					rotateEnabled = false;
					dropTap = false; // disable drop tap if a button is pressed
				}
				else if( downButton.isPressed( x1, y1 ) )
				{
					downButton.initialPressed = true;
					downButton.pressed = true;
					rotateEnabled = false;
					dropTap = false; // disable drop tap if a button is pressed
				}
				else if( rotateButton.isPressed( x1, y1 ) )
				{
					rotateButton.initialPressed = true;
					rotateButton.pressed = true;
					rotateEnabled = false;
				}
				else if( pauseButton.isPressed( x1, y1 ) )
				{
					pauseButton.initialPressed = true;
					pauseButton.pressed = true;
					rotateEnabled = false;
				}
				else if( tutorialLeftButton.isPressed( x1, y1 ) )
				{
					tutorialLeftButton.initialPressed = true;
					tutorialLeftButton.pressed = true;
					rotateEnabled = false;
				}
				else if( tutorialRightButton.isPressed( x1, y1 ) )
				{
					tutorialRightButton.initialPressed = true;
					tutorialRightButton.pressed = true;
					rotateEnabled = false;
				}
			}

			// SHADOW1
			// untouch all shadows
			for( int i = 0; i < numShadowsIndex; i++ )
			{
				shadowArray[i].touched = false;
				// set all initial positions
				shadowArray[i].initialPosition = shadowArray[i].position;

				shadowIsTouched = false;
			}

			for( int i = 0; i < numShadowsIndex; i++ ) // checks to see if a shadow is touched
			{
				// sets model matrix before calculating to make sure no glitches
				shadowArray[i].setModelMatrix( modelMatrix1 );

				// check for closest shadow
				// only checks the shadow touch if its linked cube is not already dropped
				if( shadowArray[i].isTouched( x1, y1 ) && shadowArray[i].shadowGroup->dropCubes == false )
				{
					shadowIsTouched = true;

					if( selectedShadow != NULL )
					{
						int16 zDistance = 0; //zDistance is the shadow's zDistance from the camera, finds closest shadow being touched
						int16 zDistanceOriginal = 0;
						CIwVec3 location = tt1.TransformVec(shadowArray[i].position);
						CIwVec3 locationOriginal = tt1.TransformVec( selectedShadow->position );
						zDistance = abs(view.t.z) - abs(location.z);
						zDistanceOriginal = abs(view.t.z) - abs(locationOriginal.z);

						if( zDistance < zDistanceOriginal )
						{
							selectedShadow->touched = false;
							selectedShadow = shadowArray + i;
							selectedShadow->touched = true;
						}
					}
					else
					{
						selectedShadow = shadowArray + i;
						selectedShadow->touched = true;
					}

					//shadowArray[i].touched = true;
					rotateEnabled = false;
				} // end of checking for closest shadow
			} // end of for loop seeing of shadows are touched

			// Rotation re-adjustment when on facesides 5 or 6
			// This turns the cube clockwise or counter clockwise
			// based on where the user touches the screen when faceside 5 or 6 is facing camera. 
			/* Intuitively, users touch and drag the top portion of the screen toward right to rotate the cube
			clockwise, and touch-drag the bottom half of screen toward right to
			rotate counterclockwise, regardless of what angle the x-axis is rotated on.
			This overrides the reversed index in TouchMotion()
			*/
			if( getActiveFaceSide() == 5 )
			{
				if( y1 > IwGxGetScreenHeight() /2 )
					reversedIndex = 1;
				else
					reversedIndex = -1;
			}
			else if( getActiveFaceSide() == 6 )
			{
				if( y1 > IwGxGetScreenHeight() /2 )
					reversedIndex = -1;
				else
					reversedIndex = 1;
			}
		}// end of if game state == play_tutorial
	} // end of if is touched

	// when the touch is let go
	if( isTouched == false )
	{
		if( GameState == AT_MENU )
		{	
			ReleaseMenuButtons();
			ReleaseNewStoryConfirmationButtons();
			/*
			if( menuCube.highScoreButton.isTouched( motionX1, motionY1 ) ) // high score released
			{
				menuCube.highScoreButton.activated = true;
			}
			if( menuCube.helpButton.isTouched( motionX1, motionY1 ) ) // help released
			{
				menuCube.helpButton.activated = true;
				// Activates Tutorial
				GameState = AT_DISPLAY_LOADING_TUTORIAL;
			}
			if( menuCube.creditsButton.isTouched( motionX1, motionY1 ) ) // credits released
			{
				menuCube.creditsButton.activated = true;
			}
			if( menuCube.highScoreBackButton.isTouched( motionX1, motionY1 ) ) // high score back released
			{
				menuCube.highScoreBackButton.activated = true;
			}
			if( menuCube.helpBackButton.isTouched( motionX1, motionY1 ) ) // help back released
			{
				menuCube.helpBackButton.activated = true;
			}
			if( menuCube.creditsBackButton.isTouched( motionX1, motionY1 ) ) // credits back released
			{
				menuCube.creditsBackButton.activated = true;
			}
			*/

			// release Menu Cube buttons
			/*
			menuCube.highScoreButton.pressed = false;
			menuCube.helpButton.pressed = false;
			menuCube.creditsButton.pressed = false;
			menuCube.highScoreBackButton.pressed = false;
			menuCube.helpBackButton.pressed = false;
			menuCube.creditsBackButton.pressed = false;
			*/
		}
		else if( GameState == PLAY_GAME )
		{
			rotateEnabled = false;

			// AUTOSNAP release		
			ResetAutoSnapVariables();
			autosnap = true;

			// ROTATE BUTTON release
			ReleaseButtons();

			/* fixed the error with selectedShadow!=null conditional statement I think
			// Find of cubes that are dropping. Disable the droptap if active side is same side as that cube
			for( int i = 0; i < numShadowsIndex; i++ )
			{
				if( selectedShadow != NULL )
				{

				*/

			// Drop Tap
			// NO EXPLODING CUBES check
			cubeIsExploding = false;
			int16 dir = 0;
			for( int i = numOriginalCubes; i < numStaticCubes; i++ )
			{
				if( cubeArray[i].exploding == true )
				{
					dir = cubeArray[i].direction;
					if( dir == getActiveFaceSide() )
					{
						cubeIsExploding = true;
						break;
					}
				}
			}

			// drop the cubes
			//if( dropTap == true && cubeIsExploding == false )
			if( dropTap == true )
			{
				if( selectedShadow != NULL )
				{
					selectedShadow->shadowGroup->dropCubes = true;
					cubeIsDropping = true;
					dropCubes();
					
					// QFI - Multitasking index calculating total distance to landing
					// multitasking index and comfort index are only calculated if the spawn types are RANDOM
					// otherwise you can just move and choose to not drop and let cubes fall if they spawn INCOLOR
					if( true /* cubeSpawning != DOUBLE_INCOLOR && 
							cubeSpawning != TRIPLE_INCOLOR && 
							cubeSpawning != QUADRUPLE_INCOLOR && 
							cubeSpawning != QUINTUPLE_INCOLOR && 
							cubeSpawning != SEXTUPLE_INCOLOR */  )
					{
						double averageGroupDTL = 0;
						int16 tempNumCubes = 0;
						// find cubes that are dropping from droptap
						for( int i = 0; i < numMovingCubesIndex; i++ )
						{
							if( cubeArrayMoving[i].shadow->shadowGroup->dropCubes == true )
							{
								averageGroupDTL += cubeArrayMoving[i].distanceToLanding;
								tempNumCubes++;
							}
						}
						averageGroupDTL = averageGroupDTL / tempNumCubes;
						averageGroupDTL = averageGroupDTL / s; // divide by s to prevent overflow in totalDTL to make numbers smaller

						totalDTL += averageGroupDTL;
						totalDroppedCubeSets++;

						totalDTLCurrent += averageGroupDTL;
						totalDroppedCubeSetsCurrent++;
					}
				}
			}

			// untouch all shadows
			UntouchShadows();

			// wraps the rotation values
			// so that it doesn't get overflowed
			worldX = worldX % 4096;
			worldY = worldY % 4096;

			// saves the rotation
			savedX = worldX / rotateSensitivityMultiplier;
			savedY = worldY / rotateSensitivityMultiplier;

			deltaX1 = 0; // for shadows
			deltaY1 = 0;

			// CUBE2 transform re-align axes
			// method 3
			// Imitate the Maya transforms
			CorrectReversedIndex();
		}// end of play_game 
		else if( GameState == AT_CHALLENGE_MENU_SCREEN )
		{
			ReleaseChallengeMenuScreenButtons();
		}
		else if( GameState == AT_HIGH_SCORE_MENU_SCREEN )
		{
			ReleaseHighScoreMenuScreenButtons();
		}
		else if( GameState == AT_CREDITS_MENU_SCREEN )
		{
			ReleaseCreditsMenuScreenButtons();
		}
		else if( GameState == AT_TUTORIAL_MENU_SCREEN )
		{
			ReleaseTutorialMenuScreenButtons();
		}
		else if( GameState == AT_SCORE_SCREEN )
		{
			ReleaseScoreScreenButtons();
			ReleaseQuitConfirmationButtons();
		}
		else if( GameState == PAUSED )
		{
			ReleasePausedButtons();
			ReleaseQuitConfirmationButtons();
		}
		else if( GameState == CHOOSE_DIFFICULTY )
		{
			ReleaseDifficultyButtons();
		}
		else if( GameState == PLAY_TUTORIAL )
		{
			rotateEnabled = false;

			// AUTOSNAP release		
			ResetAutoSnapVariables();
			autosnap = true;

			// ROTATE BUTTON release
			ReleaseButtons();

			/* fixed the error with selectedShadow!=null conditional statement I think
			// Find of cubes that are dropping. Disable the droptap if active side is same side as that cube
			for( int i = 0; i < numShadowsIndex; i++ )
			{
				if( selectedShadow != NULL )
				{

				*/

			// Drop Tap
			// NO EXPLODING CUBES check
			cubeIsExploding = false;
			int16 dir = 0;
			for( int i = numOriginalCubes; i < numStaticCubes; i++ )
			{
				if( cubeArray[i].exploding == true )
				{
					dir = cubeArray[i].direction;
					if( dir == getActiveFaceSide() )
					{
						cubeIsExploding = true;
						break;
					}
				}
			}

			// disable droptap for tutorial levels 1 and 2
			if( tutorialNumber == 1 || tutorialNumber == 2 )
			{
				dropTap = false;
			}

			// drop the cubes
			//if( dropTap == true && cubeIsExploding == false )
			if( dropTap == true )
			{
				if( selectedShadow != NULL )
				{
					selectedShadow->shadowGroup->dropCubes = true;
					cubeIsDropping = true;
					dropCubes();
				}
			}

			// untouch all shadows
			UntouchShadows();

			// wraps the rotation values
			// so that it doesn't get overflowed
			worldX = worldX % 4096;
			worldY = worldY % 4096;

			// saves the rotation
			savedX = worldX / rotateSensitivityMultiplier;
			savedY = worldY / rotateSensitivityMultiplier;

			deltaX1 = 0; // for shadows
			deltaY1 = 0;

			// CUBE2 transform re-align axes
			// method 3
			// Imitate the Maya transforms
			CorrectReversedIndex();
		}// end of play_tutorial 

	} // end of letting go of touch
} // end of singletouchbutton
void MultiTouchMotion( s3ePointerTouchMotionEvent* event )
{
	if( event->m_TouchID == 0) // sets the delta values for touchID 0
	{
		deltaX1 = x1 - event->m_x;
		deltaY1 = y1 - event->m_y;

		draggedX1 = event->m_x;
		draggedY1 = event->m_y;

		// SHADOW1
		motionX1 = event->m_x; // for shadows
		motionY1 = event->m_y;
	}
	else if( event->m_TouchID == 1) // sets the delta values for touchID 1
	{
		// these values only change when there is a drag
		deltaX2 = x2 - event->m_x;
		deltaY2 = y2 - event->m_y;

		draggedX2 = event->m_x;
		draggedY2 = event->m_y;
	}

	// ZOOM	
	// this seems to execute even when there is no drag
	if( isTouched1 == true && isTouched2 == true ) // if two fingers are on the device
	{		
		zoomEnabled = false; // disable zooming

		if( zoomEnabled == true ) // executes zooming
		{
			// this signifies that zooming is occurring. it is disabled when both fingers are released
			zooming = true;
			// endDistance is only calculated once on touch of second finger
			// And also when the draggedX2 and draggedY2 are activated
			if( draggedX2 != 0 && draggedY2 != 0 ) // prevents end distance from being skewed toward high draggedX1/Y1 value and a Zero draggedX2/Y2 value
			{
				endDistance = sqrt( pow( draggedX1 - draggedX2, 2 ) + pow( draggedY1 - draggedY2, 2 ) );// distance between the current two dragged touches

				// convert distance in terms of cube sizes
				//distance = abs(startDistance - endDistance) * zoomSensitivityMultiplier;
				distance = abs(startDistance - endDistance) * zoomSensitivity;
			
				// sets the depth for camera zooming
				if( startDistance - endDistance > 0 )
					cameraDepth =  savedDepth - (int)distance; // zoom out
				else // if old distance - new distance is less than zero
					cameraDepth = savedDepth + (int)distance; // zoom in
			}
		}
	}

	if( GameState == AT_MENU )
	{
		if( enableNewStoryConfirmationScreen == true )
		{
			for( int i = 0; i < newStoryConfirmationScreen.buttonCount; i++ )
			{
				if( newStoryConfirmationScreen.button[i].initialPressed == true && newStoryConfirmationScreen.button[i].isPressed( motionX1, motionY1 ) )
				{
					newStoryConfirmationScreen.button[i].pressed = true;
				}
				else
				{
					newStoryConfirmationScreen.button[i].pressed = false;
				}
			}
		}
		else // regular menu buttons
		{
			// Pressing Menu Buttons
			for( int i = 0; i < numOfActiveMenuCubes; i++ )
			{
				if( menuCubes[i].button.initialPressed == true && menuCubes[i].isTouched( motionX1, motionY1 ) )
				{
					menuCubes[i].button.pressed = true;
				}
				else
				{
					menuCubes[i].button.pressed = false;
				}
			}
		}
	}
	else if( GameState == PLAY_GAME )
	{

		// ROTATE BUTTON press checking
		if( rightButton.initialPressed == true && rightButton.isPressed( motionX1, motionY1 ) ) // right button
		{
			rightButton.pressed = true;
			rotateEnabled = false;
		}
		else
		{
			rightButton.pressed = false;
		}
		if( leftButton.initialPressed == true && leftButton.isPressed( motionX1, motionY1 ) ) // left button
		{
			leftButton.pressed = true;
			rotateEnabled = false;
		}
		else
		{
			leftButton.pressed = false;
		}
		if( upButton.initialPressed == true && upButton.isPressed( motionX1, motionY1 ) ) // up button
		{
			upButton.pressed = true;
			rotateEnabled = false;
		}
		else
		{
			upButton.pressed = false;
		}
		if( downButton.initialPressed == true && downButton.isPressed( motionX1, motionY1 ) ) // down button
		{
			downButton.pressed = true;
			rotateEnabled = false;
		}
		else
		{
			downButton.pressed = false;
		} // end of Rotate button press checking
		if( pauseButton.initialPressed == true && pauseButton.isPressed( motionX1, motionY1 ) )
		{
			pauseButton.pressed = true;
			rotateEnabled = false;
		}
		else
		{
			pauseButton.pressed = false;
		}
		if( rotateButton.initialPressed == true && rotateButton.isPressed( motionX1, motionY1 ) )
		{
			rotateButton.pressed = true;
			rotateEnabled = false;
		}
		else
		{
			rotateButton.pressed = false;
		}

		// Sets camera rotate
		if( rotateEnabled )
		{
			deltaX1 = x1 - event->m_x;
			deltaY1 = y1 - event->m_y;

			int16 rotatePixelsConvertedX = deltaX1 * 480.0/width;
			int16 rotatePixelsConvertedY = deltaY1 * 320.0/height;

			//worldX = (savedX + -1* deltaX1 * reversedIndex) * rotateSensitivityMultiplier;
			//worldY = (savedY + deltaY1) * rotateSensitivityMultiplier;
			
			worldX = (savedX + -1* rotatePixelsConvertedX * reversedIndex) * rotateSensitivityMultiplier;
			worldY = (savedY + rotatePixelsConvertedY) * rotateSensitivityMultiplier;
		}
		else // placing the direction re-alignment here ensures correct direction if stopping rotation with second touch
		{
			// CAMERA x-axis rotation direction re-alignment
			// method 3
			// Imitate the Maya transforms
			CorrectReversedIndex();
		}
	} // end of if game state == play game
	else if( GameState == AT_CHALLENGE_MENU_SCREEN )
	{
		for( int i = 0; i < menuScreen[0].buttonCount; i++ )
		{
			if( menuScreen[0].button[i].initialPressed == true && menuScreen[0].button[i].isPressed( motionX1, motionY1 ) )
			{
				menuScreen[0].button[i].pressed = true;
				rotateEnabled = false;
			}
			else
			{
				menuScreen[0].button[i].pressed = false;
			}
		}
	}
	else if( GameState == AT_HIGH_SCORE_MENU_SCREEN )
	{
		for( int i = 0; i < menuScreen[1].buttonCount; i++ )
		{
			if( menuScreen[1].button[i].initialPressed == true && menuScreen[1].button[i].isPressed( motionX1, motionY1 ) )
			{
				menuScreen[1].button[i].pressed = true;
				rotateEnabled = false;
			}
			else
			{
				menuScreen[1].button[i].pressed = false;
			}
		}
	}
	else if( GameState == AT_CREDITS_MENU_SCREEN )
	{
		for( int i = 0; i < menuScreen[2].buttonCount; i++ )
		{
			if( menuScreen[2].button[i].initialPressed == true && menuScreen[2].button[i].isPressed( motionX1, motionY1 ) )
			{
				menuScreen[2].button[i].pressed = true;
				rotateEnabled = false;
			}
			else
			{
				menuScreen[2].button[i].pressed = false;
			}
		}
	}
	else if( GameState == AT_TUTORIAL_MENU_SCREEN )
	{
		for( int i = 0; i < menuScreen[3].buttonCount; i++ )
		{
			if( menuScreen[3].button[i].initialPressed == true && menuScreen[3].button[i].isPressed( motionX1, motionY1 ) )
			{
				menuScreen[3].button[i].pressed = true;
				rotateEnabled = false;
			}
			else
			{
				menuScreen[3].button[i].pressed = false;
			}
		}
	}
	else if( GameState == AT_SCORE_SCREEN )
	{
		if( enableQuitConfirmationScreen == true )
		{
			for( int i = 0; i < quitConfirmationScreen.buttonCount; i++ )
			{
				if( quitConfirmationScreen.button[i].initialPressed == true && quitConfirmationScreen.button[i].isPressed( motionX1, motionY1 ) )
				{
					quitConfirmationScreen.button[i].pressed = true;
				}
				else
				{
					quitConfirmationScreen.button[i].pressed = false;
				}
			}
		}
		else
		{
			if( quitButton.initialPressed == true && quitButton.isPressed( motionX1, motionY1 ) )
			{
				quitButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				quitButton.pressed = false;
			}
			if( restartButton.initialPressed == true && restartButton.isPressed( motionX1, motionY1 ) )
			{
				restartButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				restartButton.pressed = false;
			}

			// next button
			if( storyMode == true )
			{
				if( advanceToNextLevel == true )
				{
					if( nextButton.initialPressed == true && nextButton.isPressed( motionX1, motionY1 ) )
					{
						nextButton.pressed = true;
						rotateEnabled = false;
					}
					else
					{
						nextButton.pressed = false;
					}
				}
			}
		}
	}
	else if( GameState == PAUSED )
	{
		if( enableQuitConfirmationScreen == true )
		{
			for( int i = 0; i < quitConfirmationScreen.buttonCount; i++ )
			{
				if( quitConfirmationScreen.button[i].initialPressed == true && quitConfirmationScreen.button[i].isPressed( motionX1, motionY1 ) )
				{
					quitConfirmationScreen.button[i].pressed = true;
				}
				else
				{
					quitConfirmationScreen.button[i].pressed = false;
				}
			}
		}
		else // pause buttons regular behavior
		{
			if( resumeButton.initialPressed == true && resumeButton.isPressed( motionX1, motionY1 ) )
			{
				resumeButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				resumeButton.pressed = false;
			}
			if( quitButton.initialPressed == true && quitButton.isPressed( motionX1, motionY1 ) )
			{
				quitButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				quitButton.pressed = false;
			}
			if( restartButton.initialPressed == true && restartButton.isPressed( motionX1, motionY1 ) )
			{
				restartButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				restartButton.pressed = false;
			}
			
			if( testButton.initialPressed == true && testButton.isPressed( motionX1, motionY1 ) )
			{
				testButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				testButton.pressed = false;
			}
		}
	}
	else if( GameState == CHOOSE_DIFFICULTY )
	{
		if( testButton.initialPressed == true && testButton.isPressed( motionX1, motionY1 ) )
		{
			testButton.pressed = true;
			rotateEnabled = false;
		}
		else
		{
			testButton.pressed = false;
		}

		if( difficultyStartButton.initialPressed == true && difficultyStartButton.isPressed( motionX1, motionY1 ) )
		{
			difficultyStartButton.pressed = true;
			rotateEnabled = false;
		}
		else
		{
			difficultyStartButton.pressed = false;
		}
		if( difficultyEasyButton.initialPressed == true && difficultyEasyButton.isPressed( motionX1, motionY1 ) )
		{
			difficultyEasyButton.pressed = true;
			rotateEnabled = false;
		}
		else
		{
			difficultyEasyButton.pressed = false;
		}
		if( difficultyMediumButton.initialPressed == true && difficultyMediumButton.isPressed( motionX1, motionY1 ) )
		{
			difficultyMediumButton.pressed = true;
			rotateEnabled = false;
		}
		else
		{
			difficultyMediumButton.pressed = false;
		}
		if( difficultyHardButton.initialPressed == true && difficultyHardButton.isPressed( motionX1, motionY1 ) )
		{
			difficultyHardButton.pressed = true;
			rotateEnabled = false;
		}
		else
		{
			difficultyHardButton.pressed = false;
		}
	}
	else if( GameState == PLAY_TUTORIAL )
	{
		// ROTATE BUTTON press checking
		if( rightButton.initialPressed == true && rightButton.isPressed( motionX1, motionY1 ) ) // right button
		{
			rightButton.pressed = true;
			rotateEnabled = false;
		}
		else
		{
			rightButton.pressed = false;
		}
		if( leftButton.initialPressed == true && leftButton.isPressed( motionX1, motionY1 ) ) // left button
		{
			leftButton.pressed = true;
			rotateEnabled = false;
		}
		else
		{
			leftButton.pressed = false;
		}
		if( upButton.initialPressed == true && upButton.isPressed( motionX1, motionY1 ) ) // up button
		{
			upButton.pressed = true;
			rotateEnabled = false;
		}
		else
		{
			upButton.pressed = false;
		}
		if( downButton.initialPressed == true && downButton.isPressed( motionX1, motionY1 ) ) // down button
		{
			downButton.pressed = true;
			rotateEnabled = false;
		}
		else
		{
			downButton.pressed = false;
		} // end of Rotate button press checking
		if( pauseButton.initialPressed == true && pauseButton.isPressed( motionX1, motionY1 ) )
		{
			pauseButton.pressed = true;
			rotateEnabled = false;
		}
		else
		{
			pauseButton.pressed = false;
		}
		if( tutorialLeftButton.initialPressed == true && tutorialLeftButton.isPressed( motionX1, motionY1 ) )
		{
			tutorialLeftButton.pressed = true;
			rotateEnabled = false;
		}
		else
		{
			tutorialLeftButton.pressed = false;
		}
		if( tutorialRightButton.initialPressed == true && tutorialRightButton.isPressed( motionX1, motionY1 ) )
		{
			tutorialRightButton.pressed = true;
			rotateEnabled = false;
		}
		else
		{
			tutorialRightButton.pressed = false;
		}
		if( rotateButton.initialPressed == true && rotateButton.isPressed( motionX1, motionY1 ) )
		{
			rotateButton.pressed = true;
			rotateEnabled = false;
		}
		else
		{
			rotateButton.pressed = false;
		}

		// Sets camera rotate
		if( rotateEnabled )
		{
			deltaX1 = x1 - event->m_x;
			deltaY1 = y1 - event->m_y;

			worldX = (savedX + -1* deltaX1 * reversedIndex) * rotateSensitivityMultiplier;
			worldY = (savedY + deltaY1) * rotateSensitivityMultiplier;

			// grant tutorial completion for Rotate Camera 
			if( tutorialNumber == 5 )
			{
				if( abs(deltaX1) > 100 || abs(deltaY1) > 100 )
				{
					tutorialRotateCameraPassed = true;
				}
			}
		}
		else // placing the direction re-alignment here ensures correct direction if stopping rotation with second touch
		{
			// CAMERA x-axis rotation direction re-alignment
			// method 3
			// Imitate the Maya transforms
			CorrectReversedIndex();
		}
	}
}

void SingleTouchMotion( s3ePointerMotionEvent* event )
{
	if( isTouched )
	{
		motionX1 = event->m_x; // for shadows
		motionY1 = event->m_y;

		deltaX1 = x1 - event->m_x;
		deltaY1 = y1 - event->m_y;

		//printf("Coordinates are: %d, %d \n", motionX1 - IwGxGetScreenWidth()/2, motionY1 - IwGxGetScreenHeight()/2 );

		if( GameState == AT_MENU )
		{	
			if( enableNewStoryConfirmationScreen == true )
			{
				for( int i = 0; i < newStoryConfirmationScreen.buttonCount; i++ )
				{
					if( newStoryConfirmationScreen.button[i].initialPressed == true && newStoryConfirmationScreen.button[i].isPressed( motionX1, motionY1 ) )
					{
						newStoryConfirmationScreen.button[i].pressed = true;
					}
					else
					{
						newStoryConfirmationScreen.button[i].pressed = false;
					}
				}
			}
			else // regular menu buttons
			{
				// Pressing Menu Buttons
				for( int i = 0; i < numOfActiveMenuCubes; i++ )
				{
					if( menuCubes[i].button.initialPressed == true && menuCubes[i].isTouched( motionX1, motionY1 ) )
					{
						menuCubes[i].button.pressed = true;
					}
					else
					{
						menuCubes[i].button.pressed = false;
					}
				}
			}
		}
		else if( GameState == PLAY_GAME )
		{
			// ROTATE BUTTON press checking
			if( rightButton.initialPressed == true && rightButton.isPressed( motionX1, motionY1 ) ) // right button
			{
				rightButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				rightButton.pressed = false;
			}
			if( leftButton.initialPressed == true && leftButton.isPressed( motionX1, motionY1 ) ) // left button
			{
				leftButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				leftButton.pressed = false;
			}
			if( upButton.initialPressed == true && upButton.isPressed( motionX1, motionY1 ) ) // up button
			{
				upButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				upButton.pressed = false;
			}
			if( downButton.initialPressed == true && downButton.isPressed( motionX1, motionY1 ) ) // down button
			{
				downButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				downButton.pressed = false;
			}
			if( pauseButton.initialPressed == true && pauseButton.isPressed( motionX1, motionY1 ) )
			{
				pauseButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				pauseButton.pressed = false;
			}
			if( rotateButton.initialPressed == true && rotateButton.isPressed( motionX1, motionY1 ) )
			{
				rotateButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				rotateButton.pressed = false;
			}

			if( rotateEnabled )
			{
				// reversedIndex accounts for the y-axis rotation direction 
				// if x-axis rotation goes beyond top/bottom limit
				int16 rotatePixelsConvertedX = deltaX1 * 480.0/width;
				int16 rotatePixelsConvertedY = deltaY1 * 320.0/height;

				//worldX = (savedX + -1* deltaX1 * reversedIndex) * rotateSensitivityMultiplier; // 6 multiplies the sensitivity of rotation
				//worldY = (savedY + deltaY1) * rotateSensitivityMultiplier;

				worldX = (savedX + -1* rotatePixelsConvertedX * reversedIndex) * rotateSensitivityMultiplier; // 6 multiplies the sensitivity of rotation
				worldY = (savedY + rotatePixelsConvertedY) * rotateSensitivityMultiplier;

			} // end of rotate enabled

		} // end of gamestate = playgame
		else if( GameState == AT_CHALLENGE_MENU_SCREEN )
		{
			for( int i = 0; i < menuScreen[0].buttonCount; i++ )
			{
				if( menuScreen[0].button[i].initialPressed == true && menuScreen[0].button[i].isPressed( motionX1, motionY1 ) )
				{
					menuScreen[0].button[i].pressed = true;
					rotateEnabled = false;
				}
				else
				{
					menuScreen[0].button[i].pressed = false;
				}
			}
		}
		else if( GameState == AT_HIGH_SCORE_MENU_SCREEN )
		{
			for( int i = 0; i < menuScreen[1].buttonCount; i++ )
			{
				if( menuScreen[1].button[i].initialPressed == true && menuScreen[1].button[i].isPressed( motionX1, motionY1 ) )
				{
					menuScreen[1].button[i].pressed = true;
					rotateEnabled = false;
				}
				else
				{
					menuScreen[1].button[i].pressed = false;
				}
			}
		}
		else if( GameState == AT_CREDITS_MENU_SCREEN )
		{
			for( int i = 0; i < menuScreen[2].buttonCount; i++ )
			{
				if( menuScreen[2].button[i].initialPressed == true && menuScreen[2].button[i].isPressed( motionX1, motionY1 ) )
				{
					menuScreen[2].button[i].pressed = true;
					rotateEnabled = false;
				}
				else
				{
					menuScreen[2].button[i].pressed = false;
				}
			}
		}
		else if( GameState == AT_TUTORIAL_MENU_SCREEN )
		{
			for( int i = 0; i < menuScreen[3].buttonCount; i++ )
			{
				if( menuScreen[3].button[i].initialPressed == true && menuScreen[3].button[i].isPressed( motionX1, motionY1 ) )
				{
					menuScreen[3].button[i].pressed = true;
					rotateEnabled = false;
				}
				else
				{
					menuScreen[3].button[i].pressed = false;
				}
			}
		}
		else if( GameState == AT_SCORE_SCREEN )
		{
			if( enableQuitConfirmationScreen == true )
			{
				for( int i = 0; i < quitConfirmationScreen.buttonCount; i++ )
				{
					if( quitConfirmationScreen.button[i].initialPressed == true && quitConfirmationScreen.button[i].isPressed( motionX1, motionY1 ) )
					{
						quitConfirmationScreen.button[i].pressed = true;
					}
					else
					{
						quitConfirmationScreen.button[i].pressed = false;
					}
				}
			}
			else
			{
				if( quitButton.initialPressed == true && quitButton.isPressed( motionX1, motionY1 ) )
				{
					quitButton.pressed = true;
					rotateEnabled = false;
				}
				else
				{
					quitButton.pressed = false;
				}
				if( restartButton.initialPressed == true && restartButton.isPressed( motionX1, motionY1 ) )
				{
					restartButton.pressed = true;
					rotateEnabled = false;
				}
				else
				{
					restartButton.pressed = false;
				}

				// next button
				if( storyMode == true )
				{
					if( advanceToNextLevel == true )
					{
						if( nextButton.initialPressed == true && nextButton.isPressed( motionX1, motionY1 ) )
						{
							nextButton.pressed = true;
							rotateEnabled = false;
						}
						else
						{
							nextButton.pressed = false;
						}
					}
				}
			}
		}
		else if( GameState == PAUSED )
		{
			// enable quit confirmation buttons
			if( enableQuitConfirmationScreen == true )
			{
				for( int i = 0; i < quitConfirmationScreen.buttonCount; i++ )
				{
					if( quitConfirmationScreen.button[i].initialPressed == true && quitConfirmationScreen.button[i].isPressed( motionX1, motionY1 ) )
					{
						quitConfirmationScreen.button[i].pressed = true;
					}
					else
					{
						quitConfirmationScreen.button[i].pressed = false;
					}
				}
			}
			else // pause buttons regular behavior
			{
				if( resumeButton.initialPressed == true && resumeButton.isPressed( motionX1, motionY1 ) )
				{
					resumeButton.pressed = true;
					rotateEnabled = false;
				}
				else
				{
					resumeButton.pressed = false;
				}
				if( quitButton.initialPressed == true && quitButton.isPressed( motionX1, motionY1 ) )
				{
					quitButton.pressed = true;
					rotateEnabled = false;
				}
				else
				{
					quitButton.pressed = false;
				}
				if( restartButton.initialPressed == true && restartButton.isPressed( motionX1, motionY1 ) )
				{
					restartButton.pressed = true;
					rotateEnabled = false;
				}
				else
				{
					restartButton.pressed = false;
				}
			
				if( testButton.initialPressed == true && testButton.isPressed( motionX1, motionY1 ) )
				{
					testButton.pressed = true;
					rotateEnabled = false;
				}
				else
				{
					testButton.pressed = false;
				}
			}
		}
		else if( GameState == CHOOSE_DIFFICULTY )
		{
			if( testButton.initialPressed == true && testButton.isPressed( motionX1, motionY1 ) )
			{
				testButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				testButton.pressed = false;
			}

			if( difficultyStartButton.initialPressed == true && difficultyStartButton.isPressed( motionX1, motionY1 ) )
			{
				difficultyStartButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				difficultyStartButton.pressed = false;
			}
			if( difficultyEasyButton.initialPressed == true && difficultyEasyButton.isPressed( motionX1, motionY1 ) )
			{
				difficultyEasyButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				difficultyEasyButton.pressed = false;
			}
			if( difficultyMediumButton.initialPressed == true && difficultyMediumButton.isPressed( motionX1, motionY1 ) )
			{
				difficultyMediumButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				difficultyMediumButton.pressed = false;
			}
			if( difficultyHardButton.initialPressed == true && difficultyHardButton.isPressed( motionX1, motionY1 ) )
			{
				difficultyHardButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				difficultyHardButton.pressed = false;
			}

		}
		else if( GameState == PLAY_TUTORIAL )
		{
			// ROTATE BUTTON press checking
			if( rightButton.initialPressed == true && rightButton.isPressed( motionX1, motionY1 ) ) // right button
			{
				rightButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				rightButton.pressed = false;
			}
			if( leftButton.initialPressed == true && leftButton.isPressed( motionX1, motionY1 ) ) // left button
			{
				leftButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				leftButton.pressed = false;
			}
			if( upButton.initialPressed == true && upButton.isPressed( motionX1, motionY1 ) ) // up button
			{
				upButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				upButton.pressed = false;
			}
			if( downButton.initialPressed == true && downButton.isPressed( motionX1, motionY1 ) ) // down button
			{
				downButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				downButton.pressed = false;
			}
			if( pauseButton.initialPressed == true && pauseButton.isPressed( motionX1, motionY1 ) )
			{
				pauseButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				pauseButton.pressed = false;
			}
			if( tutorialLeftButton.initialPressed == true && tutorialLeftButton.isPressed( motionX1, motionY1 ) )
			{
				tutorialLeftButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				tutorialLeftButton.pressed = false;
			}
			if( tutorialRightButton.initialPressed == true && tutorialRightButton.isPressed( motionX1, motionY1 ) )
			{
				tutorialRightButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				tutorialRightButton.pressed = false;
			}
			if( rotateButton.initialPressed == true && rotateButton.isPressed( motionX1, motionY1 ) )
			{
				rotateButton.pressed = true;
				rotateEnabled = false;
			}
			else
			{
				rotateButton.pressed = false;
			}

			if( rotateEnabled )
			{
				// reversedIndex accounts for the y-axis rotation direction 
				// if x-axis rotation goes beyond top/bottom limit
				worldX = (savedX + -1* deltaX1 * reversedIndex) * rotateSensitivityMultiplier; // 6 multiplies the sensitivity of rotation
				worldY = (savedY + deltaY1) * rotateSensitivityMultiplier;

				// grant tutorial completion for Rotate Camera 
				if( tutorialNumber == 5 )
				{
					if( abs(deltaX1) > 100 || abs(deltaY1 > 100 ) )
					{
						tutorialRotateCameraPassed = true;
					}
				}
			} // end of rotate enabled
		} // end of gamestate = playtutorial
	} // end of if istouched
}

void Init()
{
	// android
	// initialize orientation for android, take out for ios
	if( s3eDeviceGetInt( S3E_DEVICE_OS ) != S3E_OS_ID_IPHONE )
	{
		s3eSurfaceSetInt(S3E_SURFACE_DEVICE_ORIENTATION_LOCK, 4);
	}
		


	IwGxInit(); // for rendering 3d/2d
	Iw2DInit(); // for rendering images, sprites
	IwGraphicsInit(); // for importing models for background obj - Put in loading background
	IwGxFontInit(); // for displaying text - put in Loading background

	Iw2DSetUseMipMapping( false );
	IwGxMipMappingOff();

	// initialize width and height
	width = IwGxGetScreenWidth();
	height = IwGxGetScreenHeight();

	// initialize flurry
	if (!s3eFlurryAvailable())
    {
        printf("Flurry not available. Failed to initialize Flurry.");
        hasFlurry = false;
	}
	// testing, disable flurry for testing soas to not skew data	
	else
	{
		hasFlurry = true;
		s3eFlurrySetSessionReportOnPause( true );
		s3eFlurrySetSessionReportOnClose( true );
		
		int32 userID = s3eDeviceGetInt( S3E_DEVICE_UNIQUE_ID );
		std::ostringstream idstream;
		idstream << userID;
		char idChar[500];
		strcpy( idChar, (idstream.str()).c_str() );
		s3eFlurrySetUserID( idChar );
	}

	//Enable AppCircle
	//s3eFlurryAppCircleEnable();

	//iOS Applicaton Key
	if( hasFlurry )
	{
		if(s3eDeviceGetInt (S3E_DEVICE_OS) == S3E_OS_ID_IPHONE)
		{
			//s3eFlurryStart("SBI85EBKAWR1ETK5CCW9");
			s3eFlurryStart("1DNJ3QW7TP76YSIHYJNL"); // this is the test flurry account for ios			
			printf("Started Flurry...\n");
		}
		//Android Applicaton Key
		else if(s3eDeviceGetInt (S3E_DEVICE_OS) == S3E_OS_ID_ANDROID)
		{
			//s3eFlurryStart("HD4EZJ147ELQAT9H43KM"); 
			s3eFlurryStart("2YETE6ZDP2M9MQECE7UA");// this is test flurry account for android
		}
	}

	// initialize adwhirl
	if (s3eDeviceGetInt (S3E_DEVICE_OS) == S3E_OS_ID_IPHONE)
	{
		// this ID is specifically made for testing s3eAdWhirl
		// make sure you change this ID to your iPhone app AdWhirl ID when building your own app
		//s3eAdWhirlStart("3b1ff14d23b14cafa6b2d544ddb6afb0");

		hasAdWhirl = true;
	}

	if( s3eIOSIAdAvailable() == S3E_TRUE && iAdOn == true )
	{
		hasIAd = true;
		printf("Has iAd!! \n");
	}
	else
	{
		hasIAd = false;
	}

	// callbacks
	
	// Screen Orientation
	// s3e surface callback for s3e_surface_screensize, get orientation, set orientation
	// can do a manual program of rotation if possible?

	//extern void (*g_IwGxTextureUploadPreCallback)(CIwTexture*);
	//g_IwGxTextureUploadPreCallback = DisplayLoading( ) ;

	//IwSerialiseSetCallbackPeriod(64); // this sets callback period for amount of data being read
	//IwSerialiseSetCallback(DisplayLoading); // sets callback for data being read

	//s3eResult timerCallback = s3eTimerSetTimer( 33, DisplayLoading, 0 );// (time in milliseconds, fn, void ) 33 milliseconds is 1 frame
	s3eDeviceRegister( S3E_DEVICE_NOTIFY_PAUSE, PauseCallbackReceived, 0 ); // pausing
	
	// Set screen clear colour
	IwGxSetColClear(0, 0, 0, 255);
	// Set field of view
	//IwGxSetPerspMul(0xa0);
	// resolution based
	
	/*
	For phone devices, keep cameradepth but scale the z-depth of frustrum
	For iPad, scale the cameradepth but not the zdepth?? Need to test.
	The values are based on: 320 res height -> 0xf0=240, 768 res height -> 0x200=512
	*/
	IwGxSetPerspMul( 17.0/28 * height + 320.0/7 );
	
	// Set near and far planes
	//IwGxSetFarZNearZ(0x400, 0x10);
	IwGxSetFarZNearZ(30000, 0x10); // better set far plane to 30k, so integers don't overflow

	// CAMERA initialization
	view.SetRotX(0);
	cameraDepth = -s * 8; // default is s*-8
	
	// Initialize QFI variables
	scoredDrops = 0;
	totalDrops = 0;
	efficiencyIndex = 0.0;

	scoredDropsCurrent = 0;
	totalDropsCurrent = 0;
	efficiencyIndexCurrent = 0;

	totalDTL = 0;
	averageDTL = 0;
	totalDroppedCubeSets = 0;
	multitaskingIndex = 0;
	multitaskingIndexCurrent = 0;

	totalDTLCurrent = 0;
	averageDTLCurrent = 0;
	totalDroppedCubeSetsCurrent = 0;
	multitaskingIndexCurrent = 0;

	startingHeight = 18;

	panicLimit = 5 / 18.0;
	comfortIndex = 0;
	comfortIndexCurrent = 0;


	// UI1 initialize
	//IwUIInit();
	
	// FONT initialize
	//IwResManagerInit(); do not need this if have iwgraphics
	
	// Loads background and stars for menu, and gameplay
	//LoadBackground(); // at Render
	//GameState = AT_DISPLAY_LOADING_BACKGROUND;
	GameState = AT_LOADING_BACKGROUND;

	/* obsolete */
	//LoadMenuData();
	//InitializeMenu();

	levelDataLoaded = false; // makes sure it starts as false. already declared when bool was declared. put it here so I know it's false and used at startup


	//Instantiate the view and controller singletons.
	//IwUI will not instantiate these itself, since they can be subclassed to add functionality.
	//new CIwUIController;
	//new CIwUIView;

	// load transition screen for menu
	/*
	testSprite.setPosition( 128, 200 ); // position is where the middle of the image is
	testSprite.setUWidth( 128 ); // UWidth is the number of actual pixels per block of frame of original image
	testSprite.setSize( 64, 64 ); // size is the size that will be rendered on the block
	testSpriteImage = Iw2DCreateImage("test.png");
	testSprite.setImage( testSpriteImage );
	testSprite.setDelayTime( 20 );
	loadingMenuTransition.setPosition( IwGxGetScreenWidth() / 2, IwGxGetScreenHeight() / 2 );	
	loadingMenuTransition.setUWidth( 128 );
	loadingMenuTransition.setUHeight( 128 );
	loadingMenuTransition.setSize( 480, 320 );
	// loadingMenuTransition.setImage( testSpriteImage );
	loadingMenuTransition.setDelayTime( 20 );	
	*/


	/*
	//Load the hello world UI
	IwGetResManager()->LoadGroup("UI.group");
    //Set the default style sheet
    //CIwResource* pResource = IwGetResManager()->GetResNamed("iwui", IW_UI_RESTYPE_STYLESHEET);
	CIwUIElement* pElement = CIwUIElement::CreateFromResource("main");
	
	IwGetUIView()->AddElement(pElement);

	CIwUIAnimation* dropDown = new CIwUIAnimation;
	dropDown->SetName("dropdownAnim");
	CIwColour color1 = {0, 0, 0, 255};
	CIwColour color2 = {255, 0, 0, 255};
	dropDown->SetKeyFrameValue(0, "colour", color1 );
	dropDown->SetKeyFrameValue(1000, "colour", color2 );
	dropDown->SetKeyFrameValue( 1000, "texture", cubeTextureBlue );
	dropDown->SetKeyFrameValue(0, "offset", CIwVec2(0,-480) );
	dropDown->SetKeyFrameValue(1000, "offset", CIwVec2(0,0) );
	//dropDown->SetKeyFrameValue(0, "scale", IW_FIXED_FROM_FLOAT(0.0f) );
	//dropDown->SetKeyFrameValue(500, "scale", IW_FIXED_FROM_FLOAT(1.0f) );

	// Start animation playing on element
	IwGetUIAnimManager()->PlayAnim(dropDown, pElement, false, false, 0);

	*/

	// sets uniqueID
	uniqueID = 1;

	// TRANSFORM1 initialization
	//tt1.SetIdentity(); // not necessary
	rotX.SetIdentity();
	rotY.SetIdentity();
	modelMatrix1.SetIdentity();
	bobbleMatrix.SetIdentity(); // bobbling rotation applied to the static cubes 
	bobbleMatrixStars.SetIdentity();
	bobbleMatrixBackground.SetIdentity();
	bobbleRotX.SetIdentity();
	bobbleRotY.SetIdentity();
	bobbleRotZ.SetIdentity();

	// LIGHTING1 initialization
	IwGxSetLightType(0, IW_GX_LIGHT_AMBIENT );
	IwGxSetLightCol(0, 255, 255, 255 );

	IwGxSetLightType(1, IW_GX_LIGHT_DIFFUSE);
	IwGxSetLightCol( 1, 255, 255, 255 );

	CIwSVec3 lightDir( 1, 1, 1 );
	lightDir.Normalise();
	IwGxSetLightDirn(1, &lightDir);

	// TOUCH1 initialization
	// An OS which supports multi-touch will return TOUCH_EVENTs if they are registered for.
    // An OS which does not will only raise standard pointer events.
    hasMultiTouch = s3ePointerGetInt(S3E_POINTER_MULTI_TOUCH_AVAILABLE) ? true : false;

    if (hasMultiTouch)
    {
        //Register for multi touch events on platforms where the functionality is available.
        s3ePointerRegister(S3E_POINTER_TOUCH_EVENT, (s3eCallback)MultiTouchButton, NULL);
        s3ePointerRegister(S3E_POINTER_TOUCH_MOTION_EVENT, (s3eCallback)MultiTouchMotion, NULL);
        //g_MultiTouchButton = NewButton("Disable Multitouch");
    }
    else
    {
        //Register for standard pointer events
        s3ePointerRegister(S3E_POINTER_BUTTON_EVENT, (s3eCallback)SingleTouchButton, NULL);
        s3ePointerRegister(S3E_POINTER_MOTION_EVENT, (s3eCallback)SingleTouchMotion, NULL);
    }
}

bool Update()
{
	// UI1 update
	//Update the controller (this will generate control events etc.)
    //IwGetUIController()->Update();
    
    //Update the view (this will do animations etc.) Airplay SDK's example framework has a fixed 
    //framerate of 20fps, so we pass that duration to the update function.
    //IwGetUIView()->Update(1000/30);

	// volume
	if( GameState != PAUSED )
	{
		if( loweredVolume == true )
		{			
			raiseVolume();
			loweredVolume = false;
		}
	}
	else
	{
		if( loweredVolume == false )
		{
			lowerVolume();
			loweredVolume = true;
		}
	}

	if( developerLevels == true )
	{
		// only spawn bombs on every 10 drops, and also if there are at least more than 2 colors in play, and only in QFI
		if( totalDrops % 10 >= 8 && totalDrops % 10 <= 9 && cubeSpawning != SINGLE_RANDOM )
		{
			spawnBomb = false;
		}
		else
		{
			spawnBomb = true;
		}
	}

	// update game over
	// reset game over once leaves score screen so image does not get shown
	if( GameState != AT_SCORE_SCREEN )
	{
		showGameOver = false;
	}	

	// update bomb CHECK AND SPAWN BOMBS
	if( spawnBombMode == true )
	{
		// check to see if there are bombs in play
		bombInPlay = false;
		for( int i = numOriginalCubes; i < numStaticCubes; i++ )
		{
			if( cubeArray[i].hasBomb == true )
			{
				bombInPlay = true;
				break;
			}			
		}
		for( int i = 0; i < numMovingCubesIndex; i++ )
		{
			if( cubeArrayMoving[i].hasBomb == true )
			{
				bombInPlay = true;
				break;
			}
		}

		// spawn the bombs
		// for episodes 1-3, only spawn 1 bomb at a time
		if( episode >= 1 && episode <= 6 )
		{
			if( bombFrequency == 1 )
			{
				if( bombInPlay == false && totalDrops % 25 >= 1 && totalDrops % 25 <= 3 )
				{
					spawnBomb = true;
				}
			}
			else if( bombFrequency == 2 )
			{
				if( bombInPlay == false && totalDrops % 15 >= 1 && totalDrops % 15 <= 3 )
				{
					spawnBomb = true;
				}
			}
			else if( bombFrequency == 3 )
			{
				if( bombInPlay == false && totalDrops % 10 >= 1 && totalDrops % 10 <= 3 )
				{
					spawnBomb = true;
				}
			}
			else if( bombFrequency == 4 )
			{
				if( bombInPlay == false && totalDrops % 7 >= 1 && totalDrops % 7 <= 3 )
				{
					spawnBomb = true;
				}
			}
		}
	}

	if( GameState == AT_TUTORIAL_MENU_SCREEN && s3eVideoIsPlaying() == false )
	{
		if( playedTutorialAtMenu == true )
		{
			// initialize music
			if( musicOn )
			{
				if( s3eAudioPlay("fuzzytheme.mp3", 0) == S3E_RESULT_ERROR )
				{
					printf("Error with playing background music.\n");
				}
			}

			playedTutorialAtMenu = false;
		}
	}

	// stop cinema
	if( stopCinema == true )
	{
		s3eVideoStop();
		stopCinema = false;
	}
	
	// update cinema transitions

	// Transition into Playing Game when the movie is finished playing
	if( GameState == PLAY_CINEMATIC && s3eVideoIsPlaying() == false )
	{
		allowCinemaSkip = false; // this is solely to disable tutorial skipping for first-time view

		if( playingRapVideoFromMenu == true )
		{
			playingRapVideoFromMenu = false;
			TargetState = AT_MENU;

			if( musicOn )
			{
				// play music
				if( s3eAudioPlay("fuzzytheme.mp3", 0) == S3E_RESULT_ERROR )
				{
					printf("Error with playing background music.\n");
				}
			}

			ResetMenuButtonBobble();
		}
		else if( playingTutorialHowToFromMenu == true )
		{			
			playingTutorialHowToFromMenu = false;
			TargetState = AT_TUTORIAL_MENU_SCREEN;

			if( musicOn )
			{
				// play music
				if( s3eAudioPlay("fuzzytheme.mp3", 0) == S3E_RESULT_ERROR )
				{
					printf("Error with playing background music.\n");
				}
			}
		}
		else if( playingTutorialWarningsFromMenu == true )
		{
			playingTutorialWarningsFromMenu = false;
			TargetState = AT_TUTORIAL_MENU_SCREEN;

			if( musicOn )
			{
				// play music
				if( s3eAudioPlay("fuzzytheme.mp3", 0) == S3E_RESULT_ERROR )
				{
					printf("Error with playing background music.\n");
				}
			}
		}
		else if( playingTutorialBombFromMenu == true )
		{
			playingTutorialBombFromMenu = false;
			TargetState = AT_TUTORIAL_MENU_SCREEN;

			if( musicOn )
			{
				// play music
				if( s3eAudioPlay("fuzzytheme.mp3", 0) == S3E_RESULT_ERROR )
				{
					printf("Error with playing background music.\n");
				}
			}
		}
		else if( playedWarningTutorialOnce == false && targetEpisode == 1 && levelNumber == 7 )
		{
			s3eVideoPlay("tutorial_warnings.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );
			playingWarningTutorial = true;
			playedWarningTutorialOnce = true;
			SaveTutorialPlayed();

			// allow cinema skip
			if( s3eTimerSetTimer( 1500, AllowCinemaSkip, 0 ) == S3E_RESULT_ERROR )
			{
				printf("Cinema Skip enable callback failed");		
			}
		}
		else if( playedHowToTutorialOnce == false && targetEpisode == 1 && startAtCheckpoint == false )
		{
			// play tutorial video
			s3eVideoPlay("tutorial_howto.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );
			playingHowToTutorial = true;
			playedHowToTutorialOnce = true;
			SaveTutorialPlayed();

			// allow cinema skip
			if( s3eTimerSetTimer( 1500, AllowCinemaSkip, 0 ) == S3E_RESULT_ERROR )
			{
				printf("Cinema Skip enable callback failed");
			}
		}
		else if( playedBombTutorialOnce == false && targetEpisode == 1 && startAtCheckpoint == true && levelNumber != 7 )
		{
			s3eVideoPlay("tutorial_bomb.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );
			playingBombTutorial = true;
			playedBombTutorialOnce = true;
			SaveTutorialPlayed();

			// allow cinema skip
			if( s3eTimerSetTimer( 1500, AllowCinemaSkip, 0 ) == S3E_RESULT_ERROR )
			{
				printf("Cinema Skip enable callback failed");		
			}
		}
		else if( gameOver == true )
		{
			TargetState = AT_SCORE_SCREEN;
		}
		else if( episode == 6 && levelNumber == 6 )
		{
			TargetState = AT_SCORE_SCREEN;
		}
		else if( targetEpisode == 7 )
		{
			TargetState = AT_LOADING_MENU;
			targetEpisode = 1;
		}
		else // if not gameover, automatically defaults to play-game
		{
			TargetState = PLAY_GAME;
			advanceToNextLevel = false; // turn off next button showing from cinematic

			playingHowToTutorial = false;
			playingBombTutorial = false;

			// reset score screen stuff
			showScore = false;
			showFuzziness = false;
			showSkillTitle = false;
		}
	}

	// Update Transitions
	if( transition == true )
	{
		
		if( transitionIsSet == false )
		{
			if( GameState == AT_BLACK_SCREEN && TargetState == AT_SPLASH )
			{
				transitionObject.setTransition( TransitionObject::BLACK, TransitionObject::FADEOUT, 1000 );
			}
			
			// Exiting splash, entering title
			if( GameState == AT_SPLASH && TargetState == AT_TITLE )
			{
				transitionObject.setTransition( TransitionObject::BLACK, TransitionObject::FADEOUT, 1000 );
			}

			// Exiting title, entering loading level
			if( GameState == AT_TITLE && TargetState == AT_LOADING_LEVEL )
			{
				transitionObject.setTransition( TransitionObject::BLACK, TransitionObject::FADEOUT, 1000 );
			}

			// EXITING title, entering loading menu
			if( GameState == AT_TITLE && TargetState == AT_LOADING_MENU )
			{
				transitionObject.setTransition( TransitionObject::BLACK, TransitionObject::FADEOUT, 1000 );
			}

			// Exiting Menu, entering loading screen
			if( GameState == AT_MENU && TargetState == AT_LOADING_LEVEL )
			{
				// white fadein from menu > loading screen
				transitionObject.setTransition( TransitionObject::WHITE, TransitionObject::FADEOUT, 1000 );
			}

			// Exiting Score Screen, entering Loading Screen. This only happens when clicking Restart to go to another level. Otherwise it will always go to cinematics.
			if( GameState == AT_SCORE_SCREEN && TargetState == AT_LOADING_LEVEL )
			{
				// white fadein from loading screen > play cinematic 
				transitionObject.setTransition( TransitionObject::WHITE, TransitionObject::FADEOUT, 1000 );
			}
			
			// Exiting loading screen, entering cinematic
			if( GameState == AT_LOADING_LEVEL && TargetState == PLAY_CINEMATIC )
			{
				// white fadein from loading screen > play cinematic 
				transitionObject.setTransition( TransitionObject::BLACK, TransitionObject::FADEOUT, 1000 );
			}

			// Exiting loading screen, entering cinematic
			if( GameState == PLAY_GAME && TargetState == PLAY_CINEMATIC )
			{
				// white fadein from loading screen > play cinematic 
				transitionObject.setTransition( TransitionObject::WHITE, TransitionObject::FADEOUT, 1000 );
			}

			// Exiting loading screen, entering cinematic
			if( GameState == AT_SCORE_SCREEN && TargetState == PLAY_CINEMATIC )
			{
				// white fadein from loading screen > play cinematic 
				transitionObject.setTransition( TransitionObject::WHITE, TransitionObject::FADEOUT, 1000 );
			}

			if( GameState == PAUSED && TargetState == PLAY_CINEMATIC )
			{
				// white fadein from loading screen > play cinematic 
				transitionObject.setTransition( TransitionObject::WHITE, TransitionObject::FADEOUT, 1000 );
			}

			if( GameState == AT_MENU && TargetState == PLAY_CINEMATIC )
			{
				// white fadein from loading screen > play cinematic 
				transitionObject.setTransition( TransitionObject::WHITE, TransitionObject::FADEOUT, 1000 );
			}

			if( GameState == AT_TUTORIAL_MENU_SCREEN && TargetState == PLAY_CINEMATIC )
			{
				// white fadein from loading screen > play cinematic 
				transitionObject.setTransition( TransitionObject::WHITE, TransitionObject::FADEOUT, 1000 );
			}

			// Exiting Game, entering score screen
			if( GameState == PLAY_GAME && TargetState == AT_SCORE_SCREEN )
			{
				// white fadein from play_game > score screen
				transitionObject.setTransition( TransitionObject::WHITE, TransitionObject::FADEOUT, 1000 );
			}

			if( GameState == PAUSED && TargetState == AT_SCORE_SCREEN )
			{
				// white fadein from play_game > score screen
				transitionObject.setTransition( TransitionObject::WHITE, TransitionObject::FADEOUT, 1000 );
			}

			// Exiting Score screen, entering game
			if( GameState == AT_SCORE_SCREEN && TargetState == PLAY_GAME )
			{
				// white fadein from play_game > score screen
				transitionObject.setTransition( TransitionObject::WHITE, TransitionObject::FADEOUT, 1000 );
			}

			// Exiting Score screen, entering loading main menu
			if( GameState == AT_SCORE_SCREEN && TargetState == AT_LOADING_MENU )
			{
				// white fadein from play_game > score screen
				transitionObject.setTransition( TransitionObject::WHITE, TransitionObject::FADEOUT, 1000 );
			}

			// Exiting loading menu, entering at_menu
			if( GameState == AT_LOADING_MENU && TargetState == AT_MENU )
			{
				// white fadein from play_game > score screen
				transitionObject.setTransition( TransitionObject::BLACK, TransitionObject::FADEOUT, 1000 );
			}

			// Exiting paused screen, entering at_loading menu
			if( GameState == PAUSED && TargetState == AT_LOADING_MENU )
			{
				// white fadein from play_game > score screen
				transitionObject.setTransition( TransitionObject::WHITE, TransitionObject::FADEOUT, 1000 );
			}

			// Restarting from paused
			if( GameState == PAUSED && TargetState == PLAY_GAME )
			{
				// white fadein from play_game > score screen
				transitionObject.setTransition( TransitionObject::WHITE, TransitionObject::FADEOUT, 1000 );
			}


			// Load the background for Menu
			if( TargetState == AT_MENU )
			{
				if( sphereLoaded[0] == false )
				{
					// Get the named group
					IwGetResManager()->LoadGroup("backgroundSphere.group");
					CIwResGroup* backgroundSphere = IwGetResManager()->GetGroupNamed("backgroundSphere");
					sphere = (CIwModel*)backgroundSphere->GetResNamed("backgroundSphere", IW_GRAPHICS_RESTYPE_MODEL);

					sphereLoaded[0] = true;
				}
			}

			// Load the Background
			if( TargetState == PLAY_GAME )
			{
				// play music and load the spheres. Load one sphere ahead so that it can render on transition
				switch( targetEpisode )
				{
				case 1:
					if( sphereLoaded[0] == false )
					{
						// Get the named group
						IwGetResManager()->LoadGroup("backgroundSphere.group");
						CIwResGroup* backgroundSphere = IwGetResManager()->GetGroupNamed("backgroundSphere");
						sphere = (CIwModel*)backgroundSphere->GetResNamed("backgroundSphere", IW_GRAPHICS_RESTYPE_MODEL);

						sphereLoaded[0] = true;
					}
					break;
				case 2:
					if( sphereLoaded[1] == false )
					{
						IwGetResManager()->LoadGroup("backgroundSphere2.group");
						// Get the named group
						CIwResGroup* backgroundSphere2 = IwGetResManager()->GetGroupNamed("backgroundSphere2");
						// Get and store pointer to the model resource
						sphere2 = (CIwModel*)backgroundSphere2->GetResNamed("backgroundSphere2", IW_GRAPHICS_RESTYPE_MODEL);

						sphereLoaded[1] = true;
					}
					break;
				case 3:
					if( sphereLoaded[2] == false )
					{
						IwGetResManager()->LoadGroup("backgroundSphere3.group");
						// Get the named group
						CIwResGroup* backgroundSphere3 = IwGetResManager()->GetGroupNamed("backgroundSphere3");
						// Get and store pointer to the model resource
						sphere3 = (CIwModel*)backgroundSphere3->GetResNamed("backgroundSphere3", IW_GRAPHICS_RESTYPE_MODEL);

						sphereLoaded[2] = true;
						windSystem.Initialize(s);
					}
					break;
				case 4:
					if( sphereLoaded[3] == false )
					{
						IwGetResManager()->LoadGroup("backgroundSphere4.group");
						// Get the named group
						CIwResGroup* backgroundSphere4 = IwGetResManager()->GetGroupNamed("backgroundSphere4");
						// Get and store pointer to the model resource
						sphere4 = (CIwModel*)backgroundSphere4->GetResNamed("backgroundSphere4", IW_GRAPHICS_RESTYPE_MODEL);

						sphereLoaded[3] = true;
					}
					break;
				case 5:
					if( sphereLoaded[4] == false )
					{
						IwGetResManager()->LoadGroup("backgroundSphere5.group");
						// Get the named group
						CIwResGroup* backgroundSphere5 = IwGetResManager()->GetGroupNamed("backgroundSphere5");
						// Get and store pointer to the model resource
						sphere5 = (CIwModel*)backgroundSphere5->GetResNamed("backgroundSphere5", IW_GRAPHICS_RESTYPE_MODEL);

						sphereLoaded[4] = true;
					}
					break;
				case 6:
					if( sphereLoaded[5] == false )
					{
						IwGetResManager()->LoadGroup("backgroundSphere6.group");
						// Get the named group
						CIwResGroup* backgroundSphere6 = IwGetResManager()->GetGroupNamed("backgroundSphere6");
						// Get and store pointer to the model resource
						sphere6 = (CIwModel*)backgroundSphere6->GetResNamed("backgroundSphere6", IW_GRAPHICS_RESTYPE_MODEL);

						sphereLoaded[5] = true;
					}
					break;
				} // end of switch( episode )
			}

			transitionIsSet = true;
		}

		// if finished transition, set target state
		if( transitionObject.isFinished() )
		{
			// ENTER states
			// stay in transition limbo if there is a video playing

			// EXIT out of transition completely. Has completely faded in.
			if( GameState == TargetState && GameState != PLAY_CINEMATIC ) // do not exit out of transition if playing cinematic
			{
				transition = false;

				// Limbo is only set to false when a transition finishes to prevent buttons from being double-activated
				limbo = false;
			}
			else // START OF END-HALF of transition fade-in
			{
				// ENTER the target state by fading in
				GameState = TargetState;
				
				if( TargetState == AT_SPLASH )
				{
					transitionObject.setTransition( TransitionObject::BLACK, TransitionObject::FADEIN, 1000 );
				}
				else if( TargetState == AT_TITLE )
				{
					transitionObject.setTransition( TransitionObject::BLACK, TransitionObject::FADEIN, 1000 );
				}
				else if( TargetState == AT_MENU )
				{
					transitionObject.setTransition( TransitionObject::BLACK, TransitionObject::FADEIN, 1000 );

					// Delete all spheres that are active, but leave ep 1
					for( int i = 0; i < 6; i++ )
					{
						if( sphereLoaded[i] == true && (i+1) != 1 )
						{
							TerminateEpisode( i+1 );
							sphereLoaded[i] = false;
						}
					}
				}
				else if( TargetState == AT_LOADING_MENU )
				{
					transitionObject.setTransition( TransitionObject::WHITE, TransitionObject::FADEIN, 1000 );
					
					// allow the callback to trigger menu loading to happen. this allows for a few seconds wait.
					triggeredLoadingMenuCallback = false;
					// play music
					if( musicOn )
					{
						if( s3eAudioPlay("fuzzytheme.mp3", 0) == S3E_RESULT_ERROR )
						{
							printf("Error with playing background music.\n");
						}
					}

					// Delete all spheres that are active but not supposed to be
					for( int i = 0; i < 6; i++ )
					{
						if( sphereLoaded[i] == true && (i+1) != targetEpisode )
						{
							TerminateEpisode( i+1 );
							sphereLoaded[i] = false;
						}
					}
				}
				else if( TargetState == AT_LOADING_LEVEL ) // If coming from restart, unload all data so fresh data can be reloaded for ep1 tutorial images
				{
					transitionObject.setTransition( TransitionObject::WHITE, TransitionObject::FADEIN, 1000 );

					// Unload level data so that new data can be loaded if: targetEpisode is 1, but current episode is not 1
					if( levelDataLoaded == true && episode != 1 && targetEpisode == 1 )
					{
						TerminateLevelData();
						levelDataLoaded = false;
					}
				}
				else if( TargetState == AT_TUTORIAL_MENU_SCREEN )
				{
					transitionObject.setTransition( TransitionObject::WHITE, TransitionObject::FADEIN, 1000 );
				}
				else if( TargetState == AT_SCORE_SCREEN )
				{
					transitionObject.setTransition( TransitionObject::WHITE, TransitionObject::FADEIN, 1000 );

					// set scores to be displayed after X- seconds
					if( s3eTimerSetTimer( 1500, setShowScore, 0 ) != S3E_RESULT_SUCCESS )
					{
						printf("Failed to set score to be shown.\n");
					}
					if( s3eTimerSetTimer( 1250, setShowPixie1, 0 ) != S3E_RESULT_SUCCESS )
					{
						printf("Failed to set pixie to be shown.\n");
					}

					if( s3eTimerSetTimer( 2500, setShowFuzziness, 0 ) != S3E_RESULT_SUCCESS )
					{
						printf("Failed to set fuzziness to be shown.\n");
					}
					if( s3eTimerSetTimer( 2250, setShowPixie2, 0 ) != S3E_RESULT_SUCCESS )
					{
						printf("Failed to set pixie to be shown.\n");
					}

					if( s3eTimerSetTimer( 3500, setShowSkillTitle, 0 ) != S3E_RESULT_SUCCESS )
					{
						printf("Failed to set skill title to be shown.\n");
					}
					if( s3eTimerSetTimer( 3250, setShowPixie3, 0 ) != S3E_RESULT_SUCCESS )
					{
						printf("Failed to set pixie to be shown.\n");
					}
				}
				else if( TargetState == PLAY_CINEMATIC ) 
				{
					if( s3eVideoIsPlaying() == false )
					{		
						allowCinemaSkip = false;

						
						if( playingRapVideoFromMenu == true )
						{
							s3eVideoPlay("fuzzyrap.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );

							if( hasFlurry )
							{
								char cstring[50] = "Played Rap Video!!!!!";
								s3eFlurryLogEvent( cstring, false );
							}
						}
						else if( playingTutorialHowToFromMenu == true )
						{
							s3eVideoPlay("tutorial_howto.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );
						}
						else if( playingTutorialWarningsFromMenu == true )
						{
							s3eVideoPlay("tutorial_warnings.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );
						}
						else if( playingTutorialBombFromMenu == true )
						{
							s3eVideoPlay("tutorial_bomb.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );
						}
						else if( episode == 3 && levelNumber >= 7 && levelNumber <= 9 && gameOver == true ) // game over for ep 3
						{
							s3eVideoPlay("cinema_3-death.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() ); // enable video

							// flurry log cinema
							if( hasFlurry )
							{
								char cstring[50] = "Died on Episode 3-7 to 3-9, playing Death Cinema";
								s3eFlurryLogEvent( cstring, false );
							}
						}				
						else if( targetEpisode == 1 && levelNumber == 7 )
						{
							s3eVideoPlay("cinema_1-3.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );

							// flurry log cinema
							if( hasFlurry )
							{
								char cstring[50] = "Reached Episode 1-7, playing Cinema";
								s3eFlurryLogEvent( cstring, false );
							}
						}
						else if( targetEpisode == 1 && levelNumber == 1 && startAtCheckpoint == false ) // regular opening custcene
						{
							s3eVideoPlay("cinema_1-1.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() ); // enable video							
						}
						else if( targetEpisode == 1 && levelNumber == 4) // regular bomb cutscene
						{
							s3eVideoPlay("cinema_1-2.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() ); // enable video

							// flurry log cinema
							if( hasFlurry )
							{
								char cstring[50] = "Reached Episode 1-4, playing Cinema";
								s3eFlurryLogEvent( cstring, false );
							}
						}
						else if( targetEpisode == 1 && startAtCheckpoint == true )
						{
							s3eVideoPlay("cinema_1-2.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() ); // enable video
						}
						else if( targetEpisode == 2 && levelNumber == 7 )
						{
							s3eVideoPlay("cinema_2-3.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );

							// flurry log cinema
							if( hasFlurry )
							{
								char cstring[50] = "Reached Episode 2-7, playing Cinema";
								s3eFlurryLogEvent( cstring, false );
							}
						}
						else if( targetEpisode == 2 && levelNumber == 1 && startAtCheckpoint == false )
						{
							s3eVideoPlay("cinema_2-1.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );
						}
						else if( targetEpisode == 2 && levelNumber == 4)
						{
							s3eVideoPlay("cinema_2-2.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );

							// flurry log cinema
							if( hasFlurry )
							{
								char cstring[50] = "Reached Episode 2-4, playing Cinema";
								s3eFlurryLogEvent( cstring, false );
							}
						}
						else if( targetEpisode == 2 && startAtCheckpoint == true )
						{
							s3eVideoPlay("cinema_2-2.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );
						}
						else if( targetEpisode == 3 && levelNumber == 7 )
						{
							s3eVideoPlay("cinema_3-3.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );

							// flurry log cinema
							if( hasFlurry )
							{
								char cstring[50] = "Reached Episode 3-7, playing Cinema";
								s3eFlurryLogEvent( cstring, false );
							}
						}
						else if( targetEpisode == 3 && levelNumber == 1 && startAtCheckpoint == false  )
						{
							s3eVideoPlay("cinema_3-1.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );
						}
						else if( targetEpisode == 3 && levelNumber == 4)
						{
							s3eVideoPlay("cinema_3-2.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );

							// flurry log cinema
							if( hasFlurry )
							{
								char cstring[50] = "Reached Episode 3-4, playing Cinema";
								s3eFlurryLogEvent( cstring, false );
							}
						}
						else if( targetEpisode == 3 && startAtCheckpoint == true  )
						{
							s3eVideoPlay("cinema_3-2.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );
						}
						else if( targetEpisode == 4 && levelNumber == 1 )
						{
							s3eVideoPlay("cinema_4.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );
						}
						else if( targetEpisode == 5 && levelNumber == 1 )
						{
							s3eVideoPlay("cinema_5.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );
						}
						else if( targetEpisode == 6 && levelNumber == 1 )
						{
							s3eVideoPlay("cinema_6.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );
						}
						else if( targetEpisode == 6 && levelNumber == 6 )
						{
							s3eVideoPlay("cinema_6-end.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );

							// flurry log cinema
							if( hasFlurry )
							{
								char cstring[50] = "Beat the game, playing End Cinema";
								s3eFlurryLogEvent( cstring, false );
							}
						}
						else if( targetEpisode == 7 && levelNumber == 1 &&  score >= 1000000 ) // play rap video
						{
							s3eVideoPlay("fuzzyrap.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );

							// flurry log cinema
							if( hasFlurry )
							{
								char cstring[50] = "Beat the game, playing Rap Cinema";
								s3eFlurryLogEvent( cstring, false );
							}
						}

						// I don't think the commenting out of all those variables makes a difference...
						// Tested it and it does not seem to. What controls cinema skip for tutorials is // update cinema > allowcinemaskip = false;
						// Allow cinema skipping only if it's not the final ending cutscene and/or rap video, or first time playing tutorial videos
						if( (!(targetEpisode == 6 && levelNumber == 6) && !(targetEpisode == 7)) /*&& 
							!(playingHowToTutorial == true && playedHowToTutorialOnce == false) &&
							!(playingBombTutorial == true && playedBombTutorialOnce == false) &&
							!(playingWarningTutorial == true && playedWarningTutorialOnce == false)*/ ) 
						{ 
							// register timer callback to allow for cinema skip after X seconds
							if( s3eTimerSetTimer( 1000, AllowCinemaSkip, 0 ) == S3E_RESULT_ERROR )
							{
								printf("Cinema Skip enable callback failed");		
							}
						}

						switch( targetEpisode )
						{
						case 1:
							if( sphereLoaded[0] == false )
							{
								// Get the named group
								IwGetResManager()->LoadGroup("backgroundSphere.group");
								CIwResGroup* backgroundSphere = IwGetResManager()->GetGroupNamed("backgroundSphere");
								sphere = (CIwModel*)backgroundSphere->GetResNamed("backgroundSphere", IW_GRAPHICS_RESTYPE_MODEL);

								sphereLoaded[0] = true;
							}
							break;
						case 2:
							if( sphereLoaded[1] == false )
							{
								IwGetResManager()->LoadGroup("backgroundSphere2.group");
								// Get the named group
								CIwResGroup* backgroundSphere2 = IwGetResManager()->GetGroupNamed("backgroundSphere2");
								// Get and store pointer to the model resource
								sphere2 = (CIwModel*)backgroundSphere2->GetResNamed("backgroundSphere2", IW_GRAPHICS_RESTYPE_MODEL);

								sphereLoaded[1] = true;
							}
							break;
						case 3:
							if( sphereLoaded[2] == false )
							{
								IwGetResManager()->LoadGroup("backgroundSphere3.group");
								// Get the named group
								CIwResGroup* backgroundSphere3 = IwGetResManager()->GetGroupNamed("backgroundSphere3");
								// Get and store pointer to the model resource
								sphere3 = (CIwModel*)backgroundSphere3->GetResNamed("backgroundSphere3", IW_GRAPHICS_RESTYPE_MODEL);

								sphereLoaded[2] = true;
								windSystem.Initialize(s);
							}
							break;
						case 4:
							if( sphereLoaded[3] == false )
							{
								IwGetResManager()->LoadGroup("backgroundSphere4.group");
								// Get the named group
								CIwResGroup* backgroundSphere4 = IwGetResManager()->GetGroupNamed("backgroundSphere4");
								// Get and store pointer to the model resource
								sphere4 = (CIwModel*)backgroundSphere4->GetResNamed("backgroundSphere4", IW_GRAPHICS_RESTYPE_MODEL);

								sphereLoaded[3] = true;
							}
							break;
						case 5:
							if( sphereLoaded[4] == false )
							{
								IwGetResManager()->LoadGroup("backgroundSphere5.group");
								// Get the named group
								CIwResGroup* backgroundSphere5 = IwGetResManager()->GetGroupNamed("backgroundSphere5");
								// Get and store pointer to the model resource
								sphere5 = (CIwModel*)backgroundSphere5->GetResNamed("backgroundSphere5", IW_GRAPHICS_RESTYPE_MODEL);

								sphereLoaded[4] = true;
							}
							break;
						case 6:
							if( sphereLoaded[5] == false )
							{
								IwGetResManager()->LoadGroup("backgroundSphere6.group");
								// Get the named group
								CIwResGroup* backgroundSphere6 = IwGetResManager()->GetGroupNamed("backgroundSphere6");
								// Get and store pointer to the model resource
								sphere6 = (CIwModel*)backgroundSphere6->GetResNamed("backgroundSphere6", IW_GRAPHICS_RESTYPE_MODEL);

								sphereLoaded[5] = true;
							}
							break;
						} // end of switch( episode )
					}
				}
				else if( TargetState == PLAY_GAME ) // enter GAME from cinematic
				{
					transitionObject.setTransition( TransitionObject::WHITE, TransitionObject::FADEIN, 1000 );
					// score screen
					savedAtScoreScreen = false;

					if( levelNumber == 1 )
					{
						// new addition. load from save file every time a game restarts
						LoadSaveFile();
						InitializeDifficulty( saveFile.integers[ SaveFile::targetEpisode ] ); // use this to be on safe side. Target ep. not updated on quit
						printf("\nInitializing Story Mode with episode %d...\n\n", saveFile.integers[ SaveFile::targetEpisode ] );		
						// flurry log start
						if( hasFlurry )
						{
							char cstring[50] = "Started episode: ";
							strcat( cstring, intToChar(targetEpisode) );
							s3eFlurryLogEvent( cstring, true );

							// this necessary to stop the TimedLogEvent
							strcpy( timedEvent, cstring );
						}
					}

					// Delete all spheres that are active but not supposed to be
					for( int i = 0; i < 6; i++ )
					{
						if( sphereLoaded[i] == true && (i+1) != episode )
						{
							TerminateEpisode( i+1 );
							sphereLoaded[i] = false;
						}
					}

					// play music and load the spheres. Load one sphere ahead so that it can render on transition
					switch( targetEpisode )
					{
					case 1:
						if( musicOn )
						{
							if( levelNumber >= 1 && levelNumber <= 6 )
							{
								if (s3eAudioPlay("music_wachadunya.mp3", 0) == S3E_RESULT_ERROR )
								{
									printf("Error with playing background music.\n");
								}
							}
							else if( levelNumber >= 7 && levelNumber <= 9 )
							{
								if (s3eAudioPlay("music_ep1_doubletime.mp3", 0) == S3E_RESULT_ERROR )
								{
									printf("Error with playing background music.\n");
								}
							}
						}
						break;
					case 2:
						if( musicOn )
						{
							if( levelNumber >= 1 && levelNumber <= 6 )
							{
								if (s3eAudioPlay("music_saangapi.mp3", 0) == S3E_RESULT_ERROR )
								{
									printf("Error with playing background music.\n");
								}
							}
							else if( levelNumber >= 7 && levelNumber <= 9 )
							{
								if (s3eAudioPlay("music_ep2_doubletime.mp3", 0) == S3E_RESULT_ERROR )
								{
									printf("Error with playing background music.\n");
								}
							}
						}


						break;
					case 3:
						if( musicOn )
						{
							if( levelNumber >= 1 && levelNumber <= 6 )
							{
								if (s3eAudioPlay("fuzzytheme.mp3", 0) == S3E_RESULT_ERROR )
								{
									printf("Error with playing background music.\n");
								}
							}
							else if( levelNumber >= 7 && levelNumber <= 9 )
							{
								if (s3eAudioPlay("music_ep3_doubletime.mp3", 0) == S3E_RESULT_ERROR )
								{
									printf("Error with playing background music.\n");
								}
							}
						}
						break;
					case 4:
						if( musicOn )
						{
							if( levelNumber >= 1 && levelNumber <= 6 )
							{
								if (s3eAudioPlay("music_hawawezi.mp3", 0) == S3E_RESULT_ERROR )
								{
									printf("Error with playing background music.\n");
								}
							}
							else if( levelNumber >= 7 && levelNumber <= 9 )
							{
								if (s3eAudioPlay("music_ep4_doubletime.mp3", 0) == S3E_RESULT_ERROR )
								{
									printf("Error with playing background music.\n");
								}
							}
						}
						break;
					case 5:
						if( musicOn )
						{
							if( levelNumber >= 1 && levelNumber <= 6 )
							{
								if (s3eAudioPlay("music_tutarudi.mp3", 0) == S3E_RESULT_ERROR )
								{
									printf("Error with playing background music.\n");
								}
							}
							else if( levelNumber >= 7 && levelNumber <= 9 )
							{
								if (s3eAudioPlay("music_ep5_doubletime.mp3", 0) == S3E_RESULT_ERROR )
								{
									printf("Error with playing background music.\n");
								}
							}
						}
						break;
					case 6:
						if( musicOn )
						{
							if( levelNumber >= 1 && levelNumber <= 6 )
							{
								if (s3eAudioPlay("music_nikowapi.mp3", 0) == S3E_RESULT_ERROR )
								{
									printf("Error with playing background music.\n");
								}
							}
							else if( levelNumber >= 7 && levelNumber <= 9 )
							{
								if (s3eAudioPlay("music_ep6_doubletime.mp3", 0) == S3E_RESULT_ERROR )
								{
									printf("Error with playing background music.\n");
								}
							}
						}
						break;						
					} // end of switch( episode )
				} // end of if targetState == play_game

			}
		}

		// This boolean ensures that transition is only rendered after at least one pass of transition == true is made
		renderTransition = true;
		
	} // end of transitions == true

	// update states
	if( GameState == AT_LOADING_BACKGROUND )
	{		
		LoadBackgroundAndOtherInit();
		// load font
		// FONT
		// load group containing font
		

		// get font (first one is the .gxfont, second one is resource name
		int16 deviation = 100;
		if( height >= 1280 )
		{
			IwGetResManager()->LoadGroup("hobostd32.group"); // the font is hobo-16, bold
			hobo16 = (CIwGxFont*)IwGetResManager()->GetResNamed("hobostd32", "CIwGxFont");
		}
		else if( height >= 960 )
		{
			IwGetResManager()->LoadGroup("hobostd32.group"); // the font is hobo-16, bold
			hobo16 = (CIwGxFont*)IwGetResManager()->GetResNamed("hobostd32", "CIwGxFont");
		}
		else if( height >= 640 )
		{
			IwGetResManager()->LoadGroup("hobostd32.group"); // the font is hobo-16, bold
			hobo16 = (CIwGxFont*)IwGetResManager()->GetResNamed("hobostd32", "CIwGxFont");
		}
		else if( height >= 480 )
		{
			IwGetResManager()->LoadGroup("hobostd24.group"); // the font is hobo-16, bold
			hobo16 = (CIwGxFont*)IwGetResManager()->GetResNamed("hobostd24", "CIwGxFont");
		}
		else //if( height >= 320 )
		{
			IwGetResManager()->LoadGroup("font.group"); // the font is hobo-16, bold
			// font.tga is hobo16
			hobo16 = (CIwGxFont*)IwGetResManager()->GetResNamed("font", "CIwGxFont");
		}
		
		IwGxFontSetFont( hobo16 );

		
		IwGetResManager()->LoadGroup("ocr20.group"); // the font is hobo-16, bold

		// get font (first one is the .gxfont, second one is resource name
		ocr20 = (CIwGxFont*)IwGetResManager()->GetResNamed("ocr20", "CIwGxFont");		

		/*
		IwGetResManager()->LoadGroup("hobo16.group");
		hobo16 = (CIwGxFont*)IwGetResManager()->GetResNamed("hobo16", "CIwGxFont");

		IwGetResManager()->LoadGroup("hobo17.group");
		hobo17 = (CIwGxFont*)IwGetResManager()->GetResNamed("hobo17", "CIwGxFont");

		IwGxFontSetFont( hobo16 );
		*/

		GameState = AT_BLACK_SCREEN;
	}
	if( GameState == AT_BLACK_SCREEN )
	{
		if( triggeredSplash == false )
		{
			TargetState = AT_SPLASH;
			transition = true;
			transitionIsSet = false;

			triggeredSplash = true;
		}
	}
	if( GameState == AT_SPLASH )
	{
		// do nothing, just render splash
		// set callback for loading title

		if( triggeredTitleCallback == false )
		{
			if( s3eTimerSetTimer( 4000, triggerTitle, 0 ) != S3E_RESULT_SUCCESS )
			{
				printf("failed to load title callback\n");
			}

			triggeredTitleCallback = true;
		}
	}
	if( GameState == AT_TITLE )
	{
		if( triggeredLoadingCallback == false )
		{
			if( s3eTimerSetTimer( 4000, triggerLoading, 0 ) != S3E_RESULT_SUCCESS )
			{
				printf("failed to load loading callback\n");
			}

			triggeredLoadingCallback = true;
		}
		// do nothing, just render title. 


		// set callback for loading level
	}
	if( GameState == AT_LOADING_LEVEL )
	{
		// delete the menu data
		if( menuDataTerminated == false )
		{
			TerminateMenuData();
			menuDataTerminated = true;
		}

		if( splashAndTitleTerminated == false )
		{
			delete splashImage;
			delete titleImage;

			splashAndTitleTerminated = true;
		}

		if( transition == false )
		{
			// Loads textures and initialization if hasn't happened yet. this happens only ONCE
			if( levelDataLoaded == false )
			{
				// display loading screen
				DisplayLoading();

				LoadLevelData(); // this has to happen before levels get initialized
				levelDataLoaded = true;
			}

			// (level, phase)
			//InitializeLevel( 1, 1 );
			if( storyMode == true ) // set true by releasingMenuButtons
			{					
				TargetState = PLAY_CINEMATIC;
				transition = true;
				transitionIsSet = false;				
			}
			else if( developerLevels == true )
			{
				GameState = CHOOSE_DIFFICULTY; // DEVELOPER OPTION TO CHOOSE AND TEST DIFFICULTY LEVELS
			}
			else if( challengeMode == true )
			{
				
			}
		}
	}
	if( GameState == CHOOSE_DIFFICULTY )
	{
		// update nothing
	}
	if( GameState == AT_LOADING_TUTORIAL )
	{
		// display loading screen
		DisplayLoading();

		// delete menu data
		TerminateMenuData();

		// Loads textures and initialization if hasn't happened yet. this happens only ONCE
		if( levelDataLoaded == false )
		{
			LoadLevelData(); // this has to happen before levels get initialized
			levelDataLoaded = true;
		}
		
		/* obsolete
		if( tutorialDataLoaded == false )
		{
			LoadTutorialData();
			tutorialDataLoaded = true;
		}
		*/

		LoadTutorialData();

		InitializeTutorial( 1 );
		GameState = PLAY_TUTORIAL;
	}
	if( GameState == AT_LOADING_MENU )
	{
		// delete the menu data
		if( levelDataLoaded == true )
		{
			TerminateLevelData();
			levelDataLoaded = false;
		}

		if( splashAndTitleTerminated == false )
		{
			delete splashImage;
			delete titleImage;

			splashAndTitleTerminated = true;
		}

		/*
		if( transition == false )
		{
			// display loading screen
			LoadMenuData();
			InitializeMenu();		

			menuCounter = 0;

			transition = true;
			transitionIsSet = false;
			TargetState = AT_MENU;
		}
		*/


		if( triggeredLoadingMenuCallback == false )
		{
			if( s3eTimerSetTimer( 3000, loadingMenuCallback, 0 ) != S3E_RESULT_SUCCESS )
			{
				printf("loading menu callback failed.\n");
			}
			else
			{
				triggeredLoadingMenuCallback = true;
			}
		}
	}	
	
	// Camera Transform and Bobble matrices
	if( GameState == AT_MENU || (GameState == PLAY_GAME) || GameState == PLAY_TUTORIAL )
	{
		// TRANSFORM1 matrix update
		rotX.SetRotX( worldY );
		rotY.SetRotY( worldX ); 
		
		// Sets the rotation for tutorial if on tutorial numbers 1-3 so they don't get locked out by rotation
		if( GameState == PLAY_TUTORIAL && tutorialNumber <= 4 )
		{
			worldY = 0;
			worldX = 0;

			rotX.SetRotX( worldY );
			rotY.SetRotY( worldX );
		}

		// Sets the Universal camera transform
		tt1 = rotY * rotX;

		// bobble for cubes
		bobbleRotX.SetRotX( (int16)bobbleY );
		bobbleRotY.SetRotY( (int16)bobbleX );
		bobbleRotZ.SetRotZ( (int16)bobbleZ );

		bobbleMatrix = bobbleRotY * bobbleRotX * bobbleRotZ;

		if( storyMode == true && episode == 3 )
		{
			modelMatrix1 = bobbleMatrix * swayMatrix * tt1; // this is used for all cubes during gameplay
		}
		else
		{
			modelMatrix1 = bobbleMatrix * tt1; // this is used for all cubes during gameplay
		}

		// bobble for stars
		bobbleRotXStars.SetRotX( (int16)(bobbleZ * .1) ); // the rotation angles for stars and background are shifted compared to the cube for distortion effect of crazy bobbling
		bobbleRotYStars.SetRotY( (int16)(bobbleY * .1) ); // the .1 ratio makes the bobbling of background not apparent unless the bobbling is extreme, which is the only case where we want it
		bobbleRotZStars.SetRotZ( (int16)(bobbleX * .1) );

		if( GameState == AT_MENU )
		{
			// no star bobbling for menu
			bobbleMatrixStars.SetRotX(0); // menu screen has no tt1. tt1 allows for free rotation
		}
		else if( GameState == PLAY_GAME || GameState == PLAY_TUTORIAL )
		{
			bobbleMatrixStars = bobbleRotYStars * bobbleRotXStars * bobbleRotZStars * tt1;
		}

		// bobble for background
		bobbleRotXBackground.SetRotX( (int16)(bobbleX * .1) );
		bobbleRotYBackground.SetRotY( (int16)(bobbleZ * .1) );
		bobbleRotZBackground.SetRotZ( (int16)(bobbleY * .1) );

		bobbleMatrixBackground = bobbleRotYBackground * bobbleRotXBackground * bobbleRotZBackground * tt1;
		if( GameState == AT_MENU )
		{
			// no background bobbling for menu
			bobbleMatrixBackground.SetRotX(0); // menu screen has no tt1. tt1 allows for free rotation
		}
		else if( GameState == PLAY_GAME || GameState == PLAY_TUTORIAL )
		{
			bobbleMatrixBackground = bobbleRotYBackground * bobbleRotXBackground * bobbleRotZBackground * tt1;
		}

		// check highest layer level
		highestLayerLevel = 0;
		for( int i = numOriginalCubes; i < numStaticCubes; i++ )
		{
			if( cubeArray[i].layerLevel > highestLayerLevel )
			{
				highestLayerLevel = cubeArray[i].layerLevel;
			}
		}


		// BOBBLELIMIT and BOBBLESPEED determine how much the cubes bobble
		// the higher the number of stacked cubes, the more it bobbles. Depends on the highest layerLevel attribute of cube
		if( storyMode == true && episode == 3 && highestLayerLevel <= 2 )
		{
			bobbleSpeed = 48;
		}
		else
		{
			if( GameState == AT_MENU )
			{
				bobbleLimit = 64; // limit is how much the cube sways
				bobbleSpeed = 32; // speed is how fast it sways. Smaller is faster
			}
			else if( highestLayerLevel == 1 || highestLayerLevel == 0 ) // if 1 cube stacked
			{
				//bobbleLimit = 40; // limit is how much the cube sways
				//bobbleSpeed = 96; // speed is how fast it sways. Smaller is faster
				bobbleLimit = 60;
				bobbleSpeed = 96;
			}
			else if( highestLayerLevel == 2 ) // if 2 cubes stacked
			{
				bobbleLimit = 60;
				bobbleSpeed = 96;
			}
			else if( highestLayerLevel == 3 ) // if 3 cubes stacked, highest tolerance
			{
				if( playedLayerLevel3WarningOnce == false )
				{
					playLayerLevel3Warning();
					playedLayerLevel3WarningOnce = true;
				}
				bobbleLimit = 80;
				bobbleSpeed = 24;
			}
			else if( highestLayerLevel >= 4 ) // disable touch and keep increasing limit until it reaches max
			{
				if( playedGameOverVoiceOnce == false )
				{
					playGameOverVoice();
					playedGameOverVoiceOnce = true;
				}

				if( bobbleLimit <= 120 )
					bobbleLimit += 1;

				if( bobbleSpeed >= 8 )
					bobbleSpeed -= 1;

				if( bobbleLimit >= 120 && bobbleSpeed <= 8 ) // once all cubes have gone crazy, explode everything
				{
					for( int i = numOriginalCubes; i < numStaticCubes; i++ )
					{
						cubeArray[i].exploding = true;
					}
				}

			}

			// reset layerlevel3 warning
			if( highestLayerLevel <= 2 )
			{
				playedLayerLevel3WarningOnce = false;
			}
		} // end of tweaking bobblespeed if not episode 3

		// Controlling Sway values that control main cube's position for episode 3
		swayX = swayAmplitude * sin( swayAngleX + PI );
		swayY = swayAmplitude * sin( swayAngleY + PI/4 );
		swayZ = swayAmplitude * sin( swayAngleZ + PI/2 );

		swayAngleX += PI / swaySpeed * 1.25;
		swayAngleY += PI / swaySpeed * 1.25;
		swayAngleZ += PI / swaySpeed * 1.25;

		// wrap the angles so they don't overflow
		if( swayAngleX > 2*PI )
		{
			swayAngleX -= 2*PI; 
		}
		if( swayAngleY > 2*PI )
		{
			swayAngleY -= 2*PI;
		}
		if( swayAngleZ > 2*PI )
		{
			swayAngleZ -= 2*PI;
		}

		swayMatrix.SetIdentity();
		swayMatrix.SetTrans( CIwSVec3( (int16)swayX, (int16)swayY, (int16)swayZ ) );

		// Makes the background sphere for episode 3 move "up", or cubes falling "down"
		if( storyMode == true && (episode == 3 || episode == 4 ) )
		{
			// make background's ground level slowly come closer
			//fallMatrix.SetTrans( fallMatrix.GetTrans() + CIwSVec3(0, 0, -2) );

			// update ep3 fall matrix
			if( levelNumber >= 1 && levelNumber <= 3  )
			{
				fallMatrix.SetTrans( CIwSVec3(0, 0, fallMatrix.GetTrans().z - 5) );
				if( fallMatrix.GetTrans().z <= 0 )
				{
					fallMatrix.SetTrans( CIwSVec3( 0, 0, 0 ) );
				}
			}
			else if( levelNumber >= 4 && levelNumber <= 6  )
			{
				fallMatrix.SetTrans( CIwSVec3(0, 0, fallMatrix.GetTrans().z - 5) );
				// clamps the background at the ground
				if( fallMatrix.GetTrans().z <= -s*5 )
				{
					fallMatrix.SetTrans( CIwSVec3( 0, 0, -s*5 ) );
				}
			}
			else if( levelNumber >= 7 && levelNumber <= 9  )
			{
				fallMatrix.SetTrans( CIwSVec3(0, 0, fallMatrix.GetTrans().z - 5) );
				// clamps the background at the ground
				if( levelNumber == 7 )
				{
					if( fallMatrix.GetTrans().z <= -s*6 )
					{
						fallMatrix.SetTrans( CIwSVec3( 0, 0, -s*6 ) );
					}
				}
				else if( levelNumber == 8 )
				{
					if( fallMatrix.GetTrans().z <= -s*8 )
					{
						fallMatrix.SetTrans( CIwSVec3( 0, 0, -s*8 ) );
					}
				}
				else if( levelNumber == 9 )
				{
					if( fallMatrix.GetTrans().z <= -s*10 )
					{
						fallMatrix.SetTrans( CIwSVec3( 0, 0, -s*10 ) );
					}
				}
			}

			// update ep3 timer
			// Calculate timer for ep 3
			if( episode == 3 && (levelNumber >= 7 && levelNumber <= 9 ) )
			{
				ep3Frames++;

				// play ping sound multiple times per second for timer if close to zero
				if( ep3Seconds <= 5 )
				{
					if( ep3Frames % 4 == 1 )
					{
						playPingSound();
					}
				}
				else if( ep3Seconds <= 10 && ep3Seconds >= 0 )
				{
					if( ep3Frames % 9 == 1 )
					{
						playPingSound();
					}
				}

				// decrement the seconds
				if( ep3Frames >= 30 )
				{
					ep3Frames %= 30;
					ep3Seconds--;

					// make ping sound come earlier for each successive level to increase panic, to offset extra time
					if( levelNumber == 7 )
					{
						// play ping sound for timer					
						if( ep3Seconds <= 30 && ep3Seconds > 10 )
						{
							playPingSound();
						}
						else if( ep3Seconds == 120 || ep3Seconds == 90 || ep3Seconds == 60 )
						{
							playPingSound();
						}
					}
					else if( levelNumber == 8 )
					{
						// play ping sound for timer					
						if( ep3Seconds <= 30 && ep3Seconds > 10 )
						{
							playPingSound();
						}
						else if( ep3Seconds == 120 || ep3Seconds == 90 || ep3Seconds == 60 )
						{
							playPingSound();
						}
					}
					else if( levelNumber == 9 )
					{
						// play ping sound for timer					
						if( ep3Seconds <= 40 && ep3Seconds > 10 )
						{
							playPingSound();
						}
						else if( ep3Seconds == 120 || ep3Seconds == 90 || ep3Seconds == 60  )
						{
							playPingSound();
						}
					}
				}
			}

			// update ep3 game over by timer
			if( ep3Seconds < 0 )
			{
				if( TargetState != PLAY_CINEMATIC )
				{
					transition = true;
					transitionIsSet = false;
					TargetState = PLAY_CINEMATIC;

					gameOver = true;
					
					/* do not use
					// flurry log death
					if( hasFlurry )
					{
						char cstring[50] = "Died on episode ";
						strcat( cstring, levelToCstring( episode, levelNumber ) );
						s3eFlurryLogEvent( cstring, false );

						char cstring2[50] = "Died on episode ";
						strcat( cstring2, levelToCstring( episode, levelNumber ) );
						strcat( cstring2, " by: out-of-time" );
						s3eFlurryLogEvent( cstring2, false );

						s3eFlurryEndTimedEvent( timedEvent );
					}
					*/
				}
			}
			
			if( episode == 3 )
			{
				rumbleAmplitude = 4; // old was 10 and 5  
				rumbleSpeed = 2; // smaller is faster, bigger is slower
			}
			else if( episode == 4 )
			{
				rumbleAmplitude = 100; // old was 10 and 5  
				rumbleSpeed = 150; // smaller is faster, bigger is slower
			}

			// the Rumble matrix for background of ep. 3
			// Controlling rumble values that control main cube's position for episode 3
			rumbleX = rumbleAmplitude * sin( rumbleAngleX + PI );
			rumbleY = rumbleAmplitude * sin( rumbleAngleY + PI/4 );
			rumbleZ = rumbleAmplitude * sin( rumbleAngleZ + PI/2 );

			rumbleAngleX += PI / rumbleSpeed * 1.25;
			rumbleAngleY += PI / rumbleSpeed * 1.25;
			rumbleAngleZ += PI / rumbleSpeed * 1.25;

			// wrap the angles so they don't overflow
			if( rumbleAngleX > 2*PI )
			{
				rumbleAngleX -= 2*PI; 
			}
			if( rumbleAngleY > 2*PI )
			{
				rumbleAngleY -= 2*PI;
			}
			if( rumbleAngleZ > 2*PI )
			{
				rumbleAngleZ -= 2*PI;
			}

			CIwMat rumbleRotX, rumbleRotY, rumbleRotZ;
			rumbleRotX.SetRotX( (int16)rumbleX );
			rumbleRotY.SetRotY( (int16)rumbleY );
			rumbleRotZ.SetRotZ( (int16)rumbleZ );

			rumbleMatrix.SetIdentity();	
			rumbleMatrix = rumbleRotX * rumbleRotY * rumbleRotZ;
		}

		// turn off for now
		//fallMatrix.SetTrans( CIwSVec3( 0, 0, 0 ) );
		
		// Controlling actual Bobbling Values
		if( bobbleRateX > 0 )
		{
			bobbleAngleX += PI / bobbleSpeed * 1.25;
			bobbleX = bobbleLimit * cos( bobbleAngleX ); // regular bobbling
		}
		else if( bobbleRateX < 0 )
		{
			bobbleAngleX -= PI / bobbleSpeed * 1.25;
			bobbleX = bobbleLimit * cos( bobbleAngleX );
		}

		if( bobbleRateY > 0 )
		{
			bobbleAngleY += PI / bobbleSpeed * 1; // the rates of the axes are different to simulate random bobbling
			bobbleY = bobbleLimit * cos( bobbleAngleY );
		}
		else if( bobbleRateY < 0 )
		{
			bobbleAngleY -= PI / bobbleSpeed * 1;
			bobbleY = bobbleLimit * cos( bobbleAngleY );
		}

		if( bobbleRateZ > 0 )
		{
			bobbleAngleZ += PI / bobbleSpeed * 1.5;
			bobbleZ = bobbleLimit * cos( bobbleAngleZ );
		}
		else if( bobbleRateZ < 0 )
		{
			bobbleAngleZ -= PI / bobbleSpeed * 1.5;
			bobbleZ = bobbleLimit * cos( bobbleAngleZ );
		}

		
		if( bobbleX >= bobbleLimit || bobbleX <= -bobbleLimit )
		{
			bobbleRateX *= -1;
		}

		if( bobbleY >= bobbleLimit || bobbleY <= -bobbleLimit ) // if the bobble rotation hits limits, reverse the rotation
		{
			bobbleRateY *= -1;
		}

		if( bobbleZ >= bobbleLimit || bobbleZ <= -bobbleLimit )
		{
			bobbleRateZ *= -1;
		}
	
		if( GameState == PLAY_GAME || GameState == PLAY_TUTORIAL )
		{
			// CAMERA transform
			// set camera zoom-out limit.
			if( cameraDepth < (-1* zoomOutLimit ) ) // 
			{
				cameraDepth = -1 * zoomOutLimit;
				savedDepth = cameraDepth; // must set the savedDepth for zooming
			}
			// set camera zoom-in limit
			if ( cameraDepth > (-1* zoomInLimit) ) // if the closest distance is within 4 times the unit size. cameraDepth is negative, so account for it in comparison
			{
				cameraDepth = -1 * zoomInLimit; // cameraDepth must be negative
				savedDepth = cameraDepth; // must set the savedDepth for zooming
			}
		}


		// ADJUST CAMERA ZOOM depending on layer count
		if( (GameState == PLAY_GAME || GameState == PLAY_TUTORIAL) && zooming == false )// only change camera depth when not zooming
		{
			// adjust camera depth depending on highest layerlevel of plane. get plane of side facing player.
			int16 dir = getActiveFaceSide();
			int16 highestLL = 0; // highest layer level of the active face side
			// find Plane's highest layer level
			for( int i = numOriginalCubes; i < numStaticCubes; i++ )
			{
				if( cubeArray[i].layerLevel > highestLL )
				{
					highestLL = cubeArray[i].layerLevel;
				}
			}
			if( highestLL >= 3 ) // if hits level 3 but cubes are not warping, zoom out. must be greater than or equal b/c can be 4 when stacked with another cube before warping
			{
				//if( cameraDepth > -s * (-1.0 * height / 224 + 73 / 7.0) )
				if( cameraDepth > -s * 9 )
				{
					cameraDepth += -s/10; // s/10 is the rate/increment at which the camera is zooming out

					if( cameraDepth <= -s * 9  ) // if the camera depth is zoomed in closer than this min depth, zoom out to here
					{
						cameraDepth = -s * 9; // clamps the max zoom-out
					}

					// need this to not affect zooming with pinching
					savedDepth = cameraDepth; 
				}
				zoomDownCheck = true; // enables checking for zooming down if level 3 gets depleted.
			}
			else if( zoomDownCheck == true ) 
			{

				//if( cameraDepth <= -s * (-1.0 * height / 300 + 59 / 7.0) )
				if( cameraDepth <= -s * 7 )
				{
					cameraDepth -= -s/10; // s/10 is the rate/increment at which the camera is zooming in

					if( cameraDepth >= -s * 7 )
					{
						cameraDepth = -s * 7; // clamps the max zoom-in
						zoomDownCheck = false; // disable the zoom-in check until cubes hit layerlevel 3 again
					}

					// need this to not affect zooming with pinching
					savedDepth = cameraDepth; 
				}
			}

			// need this so that it does not affect zooming in and out with pinching
		}

		view.t.z = cameraDepth; // works
	}

	// update score screen
	if( GameState == AT_SCORE_SCREEN )
	{
		if( storyMode == true )
		{
			if( advanceToNextLevel == true )
			{
				//restartButton.setLocation( IwGxGetScreenWidth()/2 - IwGxGetScreenWidth()/4, IwGxGetScreenHeight()/2 + 120);
				//nextButton.setLocation( IwGxGetScreenWidth()/2 + IwGxGetScreenWidth()/4, IwGxGetScreenHeight()/2 + 120);
				//quitButton.setLocation( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 + 120 );

				//restartButton.setRenderSize( 100, 100 );
				//quitButton.setRenderSize( 100, 100 );
				//nextButton.setRenderSize( 100, 100 );

				restartButton.setLocation( IwGxGetScreenWidth()/2 - IwGxGetScreenWidth()/4, IwGxGetScreenHeight()/2 + height * .375);
				nextButton.setLocation( IwGxGetScreenWidth()/2 + IwGxGetScreenWidth()/4, IwGxGetScreenHeight()/2 + height * .375);
				quitButton.setLocation( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 + height * .375 );

				restartButton.setRenderSize( width * .208, width * .208 );
				quitButton.setRenderSize( width * .208, width * .208 );
				nextButton.setRenderSize( width * .208, width * .208 );
			}
			else if( advanceToNextLevel == false ) // positions with ONLY restart & quit for game over in story
			{
				//restartButton.setLocation( IwGxGetScreenWidth()/2 - 50, IwGxGetScreenHeight()/2 + 120 );
				//quitButton.setLocation( IwGxGetScreenWidth()/2 + IwGxGetScreenWidth()/4 - 50, IwGxGetScreenHeight()/2 + 120);

				//restartButton.setRenderSize( 100, 100 );
				//quitButton.setRenderSize( 100, 100 );

				restartButton.setLocation( IwGxGetScreenWidth()/2 - width*.104, IwGxGetScreenHeight()/2 + height * .375 );
				quitButton.setLocation( IwGxGetScreenWidth()/2 + IwGxGetScreenWidth()/4 - width*.104, IwGxGetScreenHeight()/2 + height * .375);

				restartButton.setRenderSize( width * .208, width * .208 );
				quitButton.setRenderSize( width * .208, width * .208 );
			}

			if( gameOver == true && savedAtScoreScreen == false )
			{
				playingStory = false;

				// Reset target episode to 1 and reset all scores
				targetEpisode = 1;
				Save();

				savedAtScoreScreen = true;

				// flurry log stop of episode-start-event
				if( hasFlurry )
				{
					s3eFlurryEndTimedEvent( timedEvent );
				}
			}

			// save game at score screen
			if( savedAtScoreScreen == false && gameOver == false )
			{
				if( episode >= 1 && episode <= 3 )
				{
					if( levelNumber == 4 )
					{
						// start at checkpoint
						startAtCheckpoint = true;
						printf("Saved starting at checkpoint \n");
						Save();

						savedAtScoreScreen = true;
					}

					if( levelNumber == 10 )
					{
						startAtCheckpoint = false;

						// increment target episode for saving, then decrement for continued gameplay
						targetEpisode++;
						Save();
						targetEpisode--;

						savedAtScoreScreen = true;
						
						printf("Reached level 10...\n");

						// flurry log stop of episode-start-event
						if( hasFlurry )
						{
							s3eFlurryEndTimedEvent( timedEvent );
						}

						// stop iAd
						if( hasIAd == true )
						{
							if( s3eIOSIAdGetInt( S3E_IOSIAD_RUNNING ) )
							{
								s3eIOSIAdStop();
								showingIAd = false;
							}
						}
					}
				}
				else
				{
					if( levelNumber == 6 )
					{
						// increment target episode for saving, then decrement for continued gameplay
						targetEpisode++;
						if( targetEpisode == 7 )
						{
							targetEpisode = 1;
						}
						Save();
						// revert back to old target episode
						if( targetEpisode == 1 )
						{
							targetEpisode = 6;
						}
						else
						{
							targetEpisode--;
						}
						

						savedAtScoreScreen = true;

						// flurry log stop of episode-start-event
						if( hasFlurry )
						{
							s3eFlurryEndTimedEvent( timedEvent );
						}
					}
				}
			}
		}
		else // positions for restart & quit for Any Other Mode. Challenge mode must have level menu
		{
			restartButton.setLocation( IwGxGetScreenWidth()/2 - 50, IwGxGetScreenHeight()/2 + 100 );
			quitButton.setLocation( IwGxGetScreenWidth()/2 + IwGxGetScreenWidth()/4 - 50, IwGxGetScreenHeight()/2 + 100);
		}
	}

	// update paused
	if( GameState == PAUSED ) // update the pause button even when paused
	{
		if( atTutorial == false )
		{
			resumeButton.setLocation( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );
			quitButton.setLocation( IwGxGetScreenWidth()/2 + IwGxGetScreenWidth()/4, IwGxGetScreenHeight()/2 );
			restartButton.setLocation( IwGxGetScreenWidth()/2 - IwGxGetScreenWidth()/4, IwGxGetScreenHeight()/2 );

			// these sizes are smaller in score screen
			//restartButton.setRenderSize( 128, 128 );
			//quitButton.setRenderSize( 128, 128 );

			restartButton.setRenderSize( width*.267, width*.267 );
			quitButton.setRenderSize( width*.267, width*.267 );
		}
		else if( atTutorial == true )
		{
			resumeButton.setLocation( IwGxGetScreenWidth()/2 - 50, IwGxGetScreenHeight()/2 );
			quitButton.setLocation( IwGxGetScreenWidth()/2 + IwGxGetScreenWidth()/4 - 50, IwGxGetScreenHeight()/2 );
		}
	}


	// UPDATE HUD
	if( GameState == PLAY_GAME || GameState == PLAY_TUTORIAL)
	{
		// update Level Bar 
		//progressBarFrameSprite.setPosition( 10 + 110/2, 35 + 20/2 );
		progressBarFrameSprite.setPosition( width * .135, height * .141 );

		if( storyMode == true )
		{
			//double percentComplete = (double)totalDropsCurrent / (double)storyLevelNumOfCompletionDrops;
			percentComplete = (double)storyModeTotalDropsCurrent / (double)storyModeRequiredDrops[levelNumber];
			if( percentComplete >= 1.0 ) // this prevents bar from overflowing
			{
				percentComplete = 1.0;

			}
			else
			{
				//progressBarFuzzySprite.setImage( spacebusImage );
			}
			int16 rectWidth = width * .229;
			int16 rectHeight = height * 0.063;
			int16 fillWidth = (int16)(percentComplete * rectWidth);
			progressBarSprite.setSize( fillWidth, rectHeight );
			//progressBarSprite.setPosition( 10 + fillWidth/2, 35 + rectHeight/2 );
			//progressBarFuzzySprite.setPosition( 10 + fillWidth, 35 + rectHeight/2 - 4 );
			//progressBarGlowSprite.setPosition( 10 + fillWidth, 35 + rectHeight/2 );

			progressBarSprite.setPosition( width*.021 + fillWidth/2, height*.109 + rectHeight/2 );
			progressBarFuzzySprite.setPosition( width*.021 + fillWidth, height*.109 + rectHeight/2 - height*.013 );
			progressBarGlowSprite.setPosition( width*.021 + fillWidth, height*.109 + rectHeight/2 );

			// show tutorial messages
			if( episode == 1 )
			{
				if( levelNumber >= 1 && levelNumber <= 3 )
				{
					// show tutorial match colors
					if( transition == false && triggeredShowTutorialMatchColors == false ) // this is the first action when game starts
					{
						s3eTimerSetTimer( 0, triggerShowTutorialMatchColors, 0 );
						triggeredShowTutorialMatchColors = true;
						showTutorialSprites[10] = true;
					}

					// hide tutorial match colors
					if( triggeredShowTutorialMatchColors == true && triggeredHideTutorialMatchColors == false )
					{
						s3eTimerSetTimer( 2500, triggerHideTutorialMatchColors, 0 );
						triggeredHideTutorialMatchColors = true;
					}

					// hide tutorial donotdie
					if( triggeredShowTutorialDoNotDie == true )
					{
						s3eTimerSetTimer( 1000, triggerHideTutorialDoNotDie, 0 );
						triggeredHideTutorialDoNotDie = true;
						triggeredShowTutorialDoNotDie = false;
					}

					if( selectedShadow != NULL && ( abs(deltaX1) >= 30 || abs(deltaY1) >= 30 ) ) // 30 is the units required to move a cube
					{
						// hide tutorial touch drag, show tap drop
						if( triggeredHideTutorialTouchDrag == false )
						{
							s3eTimerSetTimer( 0, triggerHideTutorialTouchDrag, 0 );
							triggeredHideTutorialTouchDrag = true;

							// show tutorial tap drop
							s3eTimerSetTimer( 0, triggerShowTutorialTapDrop, 0 );
							triggeredShowTutorialTapDrop = true;
							triggeredHideTutorialTapDrop = false;
							showTutorialSprites[1] = true;
						}
					}
				
					// show tutorial rotate
					if( triggeredHideTutorialTapDrop == true && numMovingCubesIndex > 1 )
					{
						if( triggeredShowTutorialRotate == false )
						{
							s3eTimerSetTimer( 0, triggerShowTutorialRotate, 0 );
							triggeredShowTutorialRotate = true;
							showTutorialSprites[3] = true;
						}

						// hide tutorial match colors sprite. Can do this anywhere after match colors has been shown and hidden
						showTutorialSprites[10] = false;
					}

					// show tutorial complete the side, shows when rotate has disappeared
					if( triggeredHideTutorialRotate == true && triggeredShowTutorialCompleteSide == false && triggeredHideTutorialCompleteSide == false ) // only enable complete side if Rotate button was pressed.
					{
						// trigger showing complete side tutorial message
						s3eTimerSetTimer( 2000, triggerShowTutorialCompleteSide, 0 );
						triggeredShowTutorialCompleteSide = true;
						showTutorialSprites[2] = true;
					}

					// show tutorial drag space to look for blinking marker
					if( triggeredHideTutorialCompleteSide == true && triggeredShowTutorialDragSpace == false && (cubeSpawning != DOUBLE_INCOLOR && cubeSpawning != DOUBLE_RANDOM ) && (cubeArrayMoving[0].direction != getActiveFaceSide() ) && numMovingCubesIndex > 0 && tutorialDragSpaceCount < 3)
					{					
						tutorialDragSpaceShown = true;
						s3eTimerSetTimer( 500, triggerShowTutorialDragSpace, 0 );
						triggeredShowTutorialDragSpace = true;
						triggeredHideTutorialDragSpace = false;
						showTutorialSprites[5] = true;
					}

					// hide tutorial drag space to look for blinking marker
					if( triggeredShowTutorialDragSpace == true && triggeredHideTutorialDragSpace == false && !((cubeSpawning != DOUBLE_INCOLOR && cubeSpawning != DOUBLE_RANDOM ) && (cubeArrayMoving[0].direction != getActiveFaceSide())) )
					{
						s3eTimerSetTimer( 0, triggerHideTutorialDragSpace, 0 );
						s3eTimerCancelTimer( triggerShowTutorialDragSpace, 0 );
						triggeredHideTutorialDragSpace = true;
						triggeredShowTutorialDragSpace = false;
					}

					// show tutorial perfect clear
					if( triggeredShowTutorialPerfectClear == false && enableTutorialPerfectClear == true && levelNumber >= 1 && levelNumber <= 3 && percentComplete > .999 )
					{
						s3eTimerSetTimer( 0, triggerShowTutorialPerfectClear, 0 );
						triggeredShowTutorialPerfectClear = true;
						triggeredHideTutorialPerfectClear = false;
						enableTutorialPerfectClear = false;
						showTutorialSprites[6] = true;
					}

					// show tutorial donotstack
					if( triggeredShowTutorialDoNotStack == false && enableTutorialDoNotStack == true )
					{
						s3eTimerSetTimer( 0, triggerShowTutorialDoNotStack, 0 );
						triggeredShowTutorialDoNotStack = true;
						triggeredHideTutorialDoNotStack = false;
						enableTutorialDoNotStack = false;
						showTutorialSprites[11] = true;

						printf("Should have triggered donotstack callback. \n");
					}

					// hide tutorial donotstack
					if( triggeredShowTutorialDoNotStack == true && triggeredHideTutorialDoNotStack == false )
					{
						s3eTimerSetTimer( 1000, triggerHideTutorialDoNotStack, 0 );
						triggeredHideTutorialDoNotStack = true;
						triggeredShowTutorialDoNotStack = false;
					}

					// show tutorial shift				
					// tutorialShiftEnable should be triggered based on timer, X-amount of seconds after every time they press the button
					if( cubeSpawning == DOUBLE_RANDOM && levelNumber <= 3 && tutorialPlaneShiftCount < 3 && tutorialShiftEnable == true )
					{
						/*
						bool showTutorialShift = false;
						bool breakOutOfLoop = false;

						for( int i = 0; i < 6; i++ )
						{
							for( int j = 0; j < numMovingCubesIndex; j++ )
							{
								// check to see if moving cube matches plane side in direction and color
								if( plane[i].direction == cubeArrayMoving[j].direction && plane[i].color == cubeArrayMoving[j].color )
								{
									showTutorialShift = false; // if they match, hide plane shift
									breakOutOfLoop = true;
									break;
								}
								else
								{
									// do nothing if plane and sides do not match. defaults to showing
									showTutorialShift = true;
								}
							}

							if( breakOutOfLoop == true )
							{
								// break out of plane loop if tutorial shift is to be hidden
								break;
							}
						}
						*/

						// show tutorial shift
						//if( showTutorialShift == true && triggeredShowTutorialShift == false ) // old condition.
						if( triggeredShowTutorialShift == false )
						{
							tutorialShiftEnable = false; // shift enable prevents erroneous checking inbetween frames
							s3eTimerSetTimer( 1000, triggerShowTutorialShift, 0 );
							triggeredShowTutorialShift = true;
							triggeredHideTutorialShift = false;
							showTutorialSprites[4] = true;
						}
					}
				} // end of level 1-1 to 1-3 tutorials

				// show tutorial defuse bombs				
				if( levelNumber >= 4 && tutorialBombDefuseCount < 2 )
				{
					// check for bombs
					bool landedBomb = false;
					for( int i = numOriginalCubes; i < numStaticCubes; i++ )
					{
						if( cubeArray[i].hasBomb == true && cubeArray[i].bomb.state == Bomb::TICKING )
						{
							landedBomb = true;
							break;
						}
					}

					// show the first tutorial bomb message
					if( landedBomb == true && tutorialBombDefuseCount == 0 )
					{
						if( triggeredShowTutorialDefuseBomb1 == false )
						{
							s3eTimerSetTimer( 0, triggerShowTutorialDefuseBomb1, 0 );
							triggeredShowTutorialDefuseBomb1 = true;
							triggeredHideTutorialDefuseBomb1 = false;
							showTutorialSprites[7] = true;

							printf("should've shown bomb tutorial.\n");
						}
					}

					// show the second tutorial bomb message
					if( landedBomb == true && tutorialBombDefuseCount == 1 )
					{
						if( triggeredShowTutorialDefuseBomb2 == false )
						{
							s3eTimerSetTimer( 0, triggerShowTutorialDefuseBomb2, 0 );
							triggeredShowTutorialDefuseBomb2 = true;
							triggeredHideTutorialDefuseBomb2 = false;
							showTutorialSprites[8] = true;
						}
					}
				}
			}
			
			// update tutorial message bubbles
			for( int i = 0; i < NUM_OF_TUTORIAL_MESSAGES; i++ )
			{
				switch( i )
				{
				case 0: // touch and drag
					if( showTutorialSprites[i] == true && numMovingCubesIndex > 0 )
					{
						int x;
						int y;	
						// convert 3d to 2d coordinates						
						IwGxWorldToScreenXY( x, y, modelMatrix1.TransformVec( (CIwVec3)cubeArrayMoving[0].shadow->position ) );
						//tutorialSprites[i].setPosition( x - 60, y - 60 );
						tutorialSprites[i].setPosition( x - width * .125, y - width * .125 );
					}
					break;
				case 1: // tap to drop
					if( showTutorialSprites[i] == true && numMovingCubesIndex > 0 )
					{
						int x;
						int y;
						// convert 3d to 2d coordinates
						IwGxWorldToScreenXY( x, y, modelMatrix1.TransformVec( (CIwVec3)cubeArrayMoving[0].shadow->position ) );
						//tutorialSprites[i].setPosition( x - 60, y );
						tutorialSprites[i].setPosition( x - width * .125, y );
					}
					break;
				case 2: // Complete the Side
					//tutorialSprites[i].setPosition( 170, 75 );
					tutorialSprites[i].setPosition( 170, 75 );
					break;
				case 3: // Rotate
					//tutorialSprites[i].setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );
					tutorialSprites[i].setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );
					break;
				case 4: // shift sides
					//tutorialSprites[i].setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );
					tutorialSprites[i].setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );
					break;
				case 5: // drag space
					//tutorialSprites[i].setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 - 25 );
					tutorialSprites[i].setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 - height * .078 );
					break;
				case 6: // Perfect Clear
					//tutorialSprites[i].setPosition( 135, 50 );
					tutorialSprites[i].setPosition( width * .281, height * .156 );
					break;
				case 7: // defuse the bomb
					if( showTutorialSprites[7] == true )
					{
						for( int j = numOriginalCubes; j < numStaticCubes; j++ )
						{
							if( cubeArray[j].hasBomb == true )
							{
								int x;
								int y;
								// convert 3d to 2d coordinates
								IwGxWorldToScreenXY( x, y, modelMatrix1.TransformVec( (CIwVec3)cubeArray[j].position ) );
								//tutorialSprites[i].setPosition( x - 50, y - 50 );
								tutorialSprites[i].setPosition( x - width * .104, y - width * .104 );
								break;
							}			
						}
					}
					break;
				case 8: // defuse the bomb 2
					if( showTutorialSprites[8] == true )
					{
						for( int j = numOriginalCubes; j < numStaticCubes; j++ )
						{
							if( cubeArray[j].hasBomb == true )
							{
								int x;
								int y;
								// convert 3d to 2d coordinates
								IwGxWorldToScreenXY( x, y, modelMatrix1.TransformVec( (CIwVec3)cubeArray[j].position ) );
								//tutorialSprites[i].setPosition( x - 50, y - 50 );
								tutorialSprites[i].setPosition( x - width * .104, y - width * .104 );
								break;
							}			
						}
					}
					break;
				case 9: // do not die
					//tutorialSprites[i].setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 - 25 );
					tutorialSprites[i].setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 - height * .078 );
					break;
				case 10: // match colors
					tutorialSprites[i].setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );
					break;
				case 11: // do not stack
					tutorialSprites[i].setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );
					break;
				}
			}

		}
		else if( challengeMode == true )
		{
			percentComplete = totalDropsCurrent * (1.0) / cmNumOfRequiredDrops[cmDifficultyLevel];
			if( percentComplete >= 1.0 ) // this prevents bar from overflowing
			{
				percentComplete = 1.0;
			}
			int16 rectWidth = 110;
			int16 rectHeight = 20;
			int16 fillWidth = (int16)(percentComplete * rectWidth);
			progressBarSprite.setSize( fillWidth, rectHeight );
			progressBarSprite.setPosition( 10 + fillWidth/2, 40 + rectHeight/2 );
		}
		else if( developerLevels == true )
		{
			percentComplete = totalDrops / 50.0;
			if( percentComplete >= 1.0 ) // this prevents bar from overflowing
			{
				percentComplete = 1.0;
			}
			int16 rectWidth = 110;
			int16 rectHeight = 20;
			int16 fillWidth = (int16)(percentComplete * rectWidth);
			progressBarSprite.setSize( fillWidth, rectHeight );
			progressBarSprite.setPosition( 10 + fillWidth/2, 40 + rectHeight/2 );
		}

		// Update ACTIVE SQUARE INDICATORS
		bool updateBlue = false;
		bool updateRed = false;
		bool updateGreen = false;
		bool updatePurple = false;
		bool updateOrange = false;
		bool updateYellow = false;

		// loop through moving cubes to determine if they exist
		for( int i = 0; i < numMovingCubesIndex; i++ )
		{
			if( cubeArrayMoving[i].color == Cube::BLUE )
			{
				if( episode <= 6 )
				{
					updateBlue = true;
				}
				else
				{
					// make sure square is updated ONCE per group
					if( cubeArrayMoving[i].distanceToLanding <= s*5 ) // the indicator is only rendered if within panic distance
						updateBlue = true;
				}
			}
			if( cubeArrayMoving[i].color == Cube::RED )
			{
				if( episode <= 6 )
				{
					updateRed = true;
				}
				else
				{
					// make sure square is updated ONCE per group
					if( cubeArrayMoving[i].distanceToLanding <= s*5 ) // the indicator is only rendered if within panic distance
						updateRed = true;	
				}	
			}
			if( cubeArrayMoving[i].color == Cube::PURPLE )
			{
				if( episode <= 6 )
				{
					updatePurple = true;
				}
				else
				{
					// make sure square is updated ONCE per group
					if( cubeArrayMoving[i].distanceToLanding <= s*5 ) // the indicator is only rendered if within panic distance
						updatePurple = true;
				}
			}
			if( cubeArrayMoving[i].color == Cube::ORANGE )
			{
				if( episode <= 6 )
				{
					updateOrange = true;
				}
				else
				{
					// make sure square is updated ONCE per group
					if( cubeArrayMoving[i].distanceToLanding <= s*5 ) // the indicator is only rendered if within panic distance
						updateOrange = true;			
				}
			}
			if( cubeArrayMoving[i].color == Cube::GREEN )
			{
				if( episode <= 6 )
				{
					updateGreen = true;
				}
				else
				{
					// make sure square is updated ONCE per group
					if( cubeArrayMoving[i].distanceToLanding <= s*5 ) // the indicator is only rendered if within panic distance
						updateGreen = true;	
				}
			}
			if( cubeArrayMoving[i].color == Cube::YELLOW )
			{
				if( episode <= 6 )
				{
					updateYellow = true;
				}
				else
				{
					// make sure square is updated ONCE per group
					if( cubeArrayMoving[i].distanceToLanding <= s*5 ) // the indicator is only rendered if within panic distance
						updateYellow = true;	
				}	
			}
		}
		// Update the SQUARE INDICATORS
		// searches through the planes to determine if that side is active
		for( int i = 0; i < 6; i++ )
		{
			int16 blinkSpeed;

			if( episode <= 6 )
			{
				blinkSpeed = 5; // this is actually not used. for episodes 1-3, the corresponding color increment is used
			}
			else
			{
				blinkSpeed = 25;
			}

			if( episode <= 6 )
			{
				if( plane[i].color == Cube::BLUE )
				{
					// Update the square indicators to tell what cubes are falling
					// originally the integer was used with the blueBlinkIncrements
					blueSquare.Update( plane[i].active, updateBlue, blueSolidIntensityIncrement ); // updates with boolean of whether or not plane is active
				}
				if( plane[i].color == Cube::RED )
				{
					redSquare.Update( plane[i].active, updateRed, redSolidIntensityIncrement  ); // updates with boolean of whether or not plane is active
				}
				if( plane[i].color == Cube::PURPLE )
				{
					purpleSquare.Update( plane[i].active, updatePurple, purpleSolidIntensityIncrement  ); // updates with boolean of whether or not plane is active
				}
				if( plane[i].color == Cube::ORANGE )
				{
					orangeSquare.Update( plane[i].active, updateOrange, orangeSolidIntensityIncrement  ); // updates with boolean of whether or not plane is active
				}
				if( plane[i].color == Cube::GREEN )
				{
					greenSquare.Update( plane[i].active, updateGreen, greenSolidIntensityIncrement  ); // updates with boolean of whether or not plane is active
				}
				if( plane[i].color == Cube::YELLOW )
				{
					yellowSquare.Update( plane[i].active, updateYellow, yellowSolidIntensityIncrement  ); // updates with boolean of whether or not plane is active
				}
			}
			else
			{
				if( plane[i].color == Cube::BLUE )
				{
					// Update the square indicators to tell what cubes are falling
					// originally the integer was used with the blueBlinkIncrements
					blueSquare.Update( plane[i].active, updateBlue, blinkSpeed ); // updates with boolean of whether or not plane is active
				}
				if( plane[i].color == Cube::RED )
				{
					redSquare.Update( plane[i].active, updateRed, blinkSpeed  ); // updates with boolean of whether or not plane is active
				}
				if( plane[i].color == Cube::PURPLE )
				{
					purpleSquare.Update( plane[i].active, updatePurple, blinkSpeed  ); // updates with boolean of whether or not plane is active
				}
				if( plane[i].color == Cube::ORANGE )
				{
					orangeSquare.Update( plane[i].active, updateOrange, blinkSpeed  ); // updates with boolean of whether or not plane is active
				}
				if( plane[i].color == Cube::GREEN )
				{
					greenSquare.Update( plane[i].active, updateGreen, blinkSpeed  ); // updates with boolean of whether or not plane is active
				}
				if( plane[i].color == Cube::YELLOW )
				{
					yellowSquare.Update( plane[i].active, updateYellow, blinkSpeed  ); // updates with boolean of whether or not plane is active
				}
			}
			
		}

		// Update Congrats Sprites
		//congratsSpriteGreat.setPosition( IwGxGetScreenWidth()/2 + 15, 0 + IwGxGetScreenHeight()/2 - 15 );		
		//congratsSpriteNice.setPosition( IwGxGetScreenWidth()/2 + 15, 0 + IwGxGetScreenHeight()/2 );
		//congratsSpriteComplete.setPosition( IwGxGetScreenWidth()/2 + 15, 0 + IwGxGetScreenHeight()/2 );
		//congratsSpriteSuper.setPosition( IwGxGetScreenWidth()/2 + 15, 0 + IwGxGetScreenHeight()/2 );

		congratsSpriteGreat.setPosition( IwGxGetScreenWidth()/2 + width*.031, 0 + IwGxGetScreenHeight()/2 - height*.047 );		
		congratsSpriteNice.setPosition( IwGxGetScreenWidth()/2 +  width*.031, 0 + IwGxGetScreenHeight()/2 );
		congratsSpriteComplete.setPosition( IwGxGetScreenWidth()/2 +  width*.031, 0 + IwGxGetScreenHeight()/2 );
		congratsSpriteSuper.setPosition( IwGxGetScreenWidth()/2 +  width*.031, 0 + IwGxGetScreenHeight()/2 );

		// Update BUTTON LOCATIONS
		// this location for the paused screen
		testButton.setLocation( IwGxGetScreenWidth() - testButton.hitboxWidth, 0 + testButton.hitboxHeight );
		
		//pauseButton.setLocation( 0 + 35, IwGxGetScreenHeight() - 35 );
		//rotateButton.setLocation( IwGxGetScreenWidth() - 40, IwGxGetScreenHeight() - 40 );
		//rightButton.setLocation( IwGxGetScreenWidth() - 25, IwGxGetScreenHeight() / 2 );
		//leftButton.setLocation( 0 + 25, IwGxGetScreenHeight() / 2 );
		//upButton.setLocation( IwGxGetScreenWidth() / 2, 0 + 25 );
		//downButton.setLocation( IwGxGetScreenWidth() / 2, IwGxGetScreenHeight() - 25 );

		pauseButton.setLocation( 0 + width*.073, IwGxGetScreenHeight() - height*.109 );
		rotateButton.setLocation( IwGxGetScreenWidth() - width*.083, IwGxGetScreenHeight() - height*.125 );
		rightButton.setLocation( IwGxGetScreenWidth() - width*.052, IwGxGetScreenHeight() / 2 );
		leftButton.setLocation( 0 + width*.052, IwGxGetScreenHeight() / 2 );
		upButton.setLocation( IwGxGetScreenWidth() / 2, 0 + height*.078 );
		downButton.setLocation( IwGxGetScreenWidth() / 2, IwGxGetScreenHeight() - height*.078 );

		// Tutorial HUD
		tutorialTouchDragSprite.setPosition( IwGxGetScreenWidth() - 80, 0 + 55 ); // gets rendered in tutorial mode only. renders over lives left
		tutorialTapDropSprite.setPosition( IwGxGetScreenWidth() - 80, 0 + 55 ); // gets rendered in tutorial mode only. renders over lives left
		tutorialRotateCubeSprite.setPosition( IwGxGetScreenWidth() - 80, 0 + 55 ); // gets rendered in tutorial mode only. renders over lives left
		tutorialCompleteSideSprite.setPosition( IwGxGetScreenWidth() - 80, 0 + 55 );
		tutorialRotateCameraSprite.setPosition( IwGxGetScreenWidth() - 80, 0 + 55 );
		tutorialFlipCubeSprite.setPosition( IwGxGetScreenWidth() - 80, 0 + 55 );
		tutorialLeftButton.setLocation( 100, 0 + IwGxGetScreenHeight() - 30 );
		tutorialRightButton.setLocation( 150, 0 + IwGxGetScreenHeight() - 30 );
		
		// tutorial HIGHLIGHTS
		tutorialRotateButtonHighlightSprite.setPosition( rotateButton.x, rotateButton.y );
		tutorialRightButtonHighlightSprite.setPosition( tutorialRightButton.x, tutorialRightButton.y );

		// tutorial: use passed-states to ENABLE highlights
		if( tutorialTouchDragPassed == true || 
			tutorialRotateCubePassed == true ||
			tutorialTapDropPassed == true ||
			tutorialCompleteSidePassed == true ||
			tutorialRotateCameraPassed == true ||
			tutorialFlipCubePassed == true ||
			tutorialCompleteSide2Passed == true	)
		{
			if( tutorialCompleteSide2Passed == false )
			{
				tutorialRightButtonHighlightEnabled = true; // enable right button highlight to be rendered
			}
			showCongratsSpriteComplete = true;
		}

		// grant tutorial completion for Flip Cubes
		if( tutorialNumber == 6 )
		{
			if( cubeArrayMoving[0].direction == 1 ) // there is only 1 set of moving cubes for this phase, so test the first cube in array
			{
				tutorialFlipCubePassed = true;
			}
		}

		if( GameState == PLAY_GAME )
		{
			rightButton.enabled = true; // flip cubes enabled
			leftButton.enabled = true; // flip cubes enabled
			upButton.enabled = true; // flip cubes enabled
			downButton.enabled = true; // flip cubes enabled
			rotateButton.enabled = true; // rotateButton enabled
		}
		else if( GameState == PLAY_TUTORIAL )
		{
			// Tutorial DISABLE BUTTONS ACCORDING TO PHASE
			switch( tutorialNumber )
			{
			case 1: // touch and drag
				rightButton.enabled = false;
				leftButton.enabled = false;
				upButton.enabled = false;
				downButton.enabled = false;
				rotateButton.enabled = false;
				break;
			case 2: // rotate cube
				rightButton.enabled = false;
				leftButton.enabled = false;
				upButton.enabled = false;
				downButton.enabled = false;
				rotateButton.enabled = true; // rotateButton enabled
				break;
			case 3: // tap to drop
				rightButton.enabled = false;
				leftButton.enabled = false;
				upButton.enabled = false;
				downButton.enabled = false;
				rotateButton.enabled = true; // rotateButton enabled
				break;
			case 4: // complete the side
				rightButton.enabled = false;
				leftButton.enabled = false;
				upButton.enabled = false;
				downButton.enabled = false;
				rotateButton.enabled = true; // rotateButton enabled
				break;
			case 5: // look around
				rightButton.enabled = false;
				leftButton.enabled = false;
				upButton.enabled = false;
				downButton.enabled = false;
				rotateButton.enabled = true; // rotateButton enabled
				break;
			case 6: // flip the cubes
				rightButton.enabled = true; // flip cubes enabled
				leftButton.enabled = true; // flip cubes enabled
				upButton.enabled = true; // flip cubes enabled
				downButton.enabled = true; // flip cubes enabled
				rotateButton.enabled = true; // rotateButton enabled
				break;
			case 7:// complete the side #2
				rightButton.enabled = true; // flip cubes enabled
				leftButton.enabled = true; // flip cubes enabled
				upButton.enabled = true; // flip cubes enabled
				downButton.enabled = true; // flip cubes enabled
				rotateButton.enabled = true; // rotateButton enabled
				break;
			}
		}

		//livesSprite.setPosition( IwGxGetScreenWidth() - 70, 50 );
		livesSprite.setPosition( IwGxGetScreenWidth() - width*.146, height*.156 );

		// FLOATING OBJECT update. This needs to be updated so that it is doing so in-game. Also need spawning algorithm/method and death alg./method
		if( testFO.activated == true )
		{
			testFO.Update( IwGxGetScreenWidth(), IwGxGetScreenHeight() );
		}
	}

	// update menuscreens
	// update trophies
	menuScreen[1].Update( trophies, highScore, timeSeconds, timeMinutes, timeHours );

	// UPDATE ALL MOTION
	//if( (RenderTime1 - RenderTime) == 1 ) // this tells the move() to how many times to execute per second
	// this is taken care of in the main. Update is already limited to 30 fps
	// UPDATE MENU
	if( GameState == AT_MENU || GameState == AT_HIGH_SCORE_MENU_SCREEN || GameState == AT_CREDITS_MENU_SCREEN || GameState == AT_TUTORIAL_MENU_SCREEN )
	{
		// Update menu cubes
		for( int i = 0; i < numOfActiveMenuCubes; i++ )
		{
			menuCubes[i].Update();
		}

		Bubbly.setPosition( 0, 0, 0 );
		/*
		menuTitleSprite.setPosition( IwGxGetScreenWidth()/2 + 10, menuTitleSprite.size.y/2 );
		menuTitleSprite2.setPosition( IwGxGetScreenWidth()/2 + 10, menuTitleSprite2.size.y/2 );
		menuTitleSprite3.setPosition( IwGxGetScreenWidth()/2 + 10, menuTitleSprite2.size.y/2 );
		menuTitleSprite4.setPosition( IwGxGetScreenWidth()/2 + 10, menuTitleSprite2.size.y/2 );
		*/
		menuTitleSprite.setPosition( width * .521, menuTitleSprite.size.y/2 );
		menuTitleSprite2.setPosition( width * .521, menuTitleSprite2.size.y/2 );
		menuTitleSprite3.setPosition( width * .521, menuTitleSprite2.size.y/2 );
		menuTitleSprite4.setPosition( width * .521, menuTitleSprite2.size.y/2 );

		
		// for testing
		// initialize game if cube/screen is turned past 90 degrees
		if( worldX > 1556 || worldX < -1556 )
		{
			/*
			GameState = PLAY_GAME;
			InitializeLevel( levelNumber );
			*/
		}

		// rotate the stars
		starRotationDelayTime++;
		
		if( starRotationDelayTime > 2048 )
			starRotationDelayTime %= 2048; // wrap the counter so doesn't overflow

		// increment the rotation counter of initial position
		// starRotationCounter is basically the netValue of what to rotate the star's original position by
		//if( starRotationDelayTime %2 == 1 )
			starRotationCounter++;
		
		// update stars
		for( int i = 0; i < numStars; i++ )
		{
			//if( starRotationDelayTime % 2 == 1 ) // one rotation every 2 frames
			{
				// transform the position and make it rotate around center
				CIwMat starRotation;
				starRotation.SetIdentity();
				
				//starRotation.SetRotY( stars[i].rotationSpeed );
				starRotation.SetRotY( stars[i].rotationSpeed * starRotationCounter );

				//stars[i].position = starRotation.TransformVec( stars[i].position );
				stars[i].position = starRotation.TransformVec( stars[i].initialPosition );
			}

			CIwSVec3 transformedPosition = (CIwSVec3)bobbleMatrixStars.TransformVec( stars[i].position );
			
			// wraps the counter so it doesn't overflow
			if( starRotationCounter > 4096 )
				starRotationCounter %= 4096; // since this is the net speed, make sure this # multiplied by rotationSpeed does not exceed integer limit. rotationSpeed is max at 2

			// update vertices
			for( int j = 0; j < 4; j++ )
			{
				starsVertexStream[i*4 + j] = stars[i].vertexstream[j] + transformedPosition;
				starsNormalStream[i*4 + j] = fuzzyNormals[j];
				starsUVStream[i*4 + j] = stars[i].uvstream[j];
			}
		} // end of for i = 0 to numStars
	}

	// GAMEPLAY STUFF
	// update gameplay
	if( GameState == PLAY_GAME || GameState == PLAY_TUTORIAL )
	{
		// allowing rotate button after cubes spawn
		if( completeComplete == true )
		{
			spawningSetCounter++;
		}
		if( spawningSetCounter >= 1 )
		{
			spawningSetCounter == 1; // after a set of cubes have spawned, 1 is the frame count that allows rotation to happen 
		}
		
		if( shadowIsTouched == true )
		{
			MoveShadows( -deltaX1, -deltaY1);
		}

		/*
		// Controls the Shadows
		int16 shadowDirection = 0;
		CIwSVec3 deltaTranslation(0, 0, 0);
		bool found = false;
		// moves the shadows with intersection, basically moving shadows on touch-drag
		for( int i = 0; i < numShadowsIndex; i++ )
		{
			// adding the shadowGroup's dropCubes == false condition prevents null glitch from occuring right when cube lands and can be moved off plane
			if( shadowArray[i].touched == true && found == false && shadowArray[i].shadowGroup->dropCubes == false ) // if a shadow is found to be touched, make sure all other shadows are searched again
			{
				shadowArray[i].setTouchIntersection( motionX1, motionY1 );
				shadowArray[i].convertToGridLocation( numCubesWidth, numCubesHeight, numCubesLength ); // the width and height set the upper bounds for translation
				shadowDirection = shadowArray[i].direction;
				deltaTranslation = shadowArray[i].getDeltaTranslation();

				i = -1; // starts looping through shadows from beginning
				found = true; // makes sure things don't get reset for a second time so there is no infinite loop

				// immediately disable the drop tap when a shadow is moved
				if( deltaTranslation.x != 0 || deltaTranslation.y != 0 || deltaTranslation.z != 0 )
					dropTap = false;
			}
			else if( shadowArray[i].touched == false && shadowArray[i].direction == shadowDirection ) // if shadows are every shadow on side that wasn't touched shadow
			{
				shadowArray[i].position = shadowArray[i].initialPosition + deltaTranslation; // translate the other shadows
			}
		}
		*/

		// update bomb spawning
		// 50/50 chance that bombs will be wtf bombs in ep 4-6

		// immediately spawn bombs when game starts back into level 4
		if( levelNumber == 4 )
		{
			if( episode == 1 )
			{
				// spawn single bomb at episode 1-4
				if( storyModeTotalDropsCurrent == 0 && bombInPlay == false )
				{
					spawnBomb = true;
				}
			} 
			else if( episode >= 2 && episode <= 3 )
			{
				// spawn multible bombs after episode1, on ep (2+) -4
				if( storyModeTotalDropsCurrent == 0 )
				{
					spawnBomb = true;
				}
			}
		}

		IwRandSeed((int32)s3eTimerGetMs());
		if( spawnBomb == true )
		{
			if( episode >= 1 && episode <= 3 )
			{
				bombType = FBOMB;
			}
			else if( episode >= 4 && episode <= 6 )
			{
				// for episodes 4 - 6, each episode has a certan percentage of spawning wtf or fbomb
				int bombTypeChance = IwRandMinMax(1,10+1);
				if( episode == 4 )
				{
					if( bombTypeChance >= 1 && bombTypeChance <= 5 )
					{
						bombType = WTFBOMB;
						bombAlertSprite.setImage( bombAlertImage_wtf );				
					}
					else
					{
						bombType = FBOMB;
						bombAlertSprite.setImage( bombAlertImage );
					}
				}
				else if( episode == 5 )
				{
					if( bombTypeChance >= 1 && bombTypeChance <= 6 )
					{
						bombType = WTFBOMB;
						bombAlertSprite.setImage( bombAlertImage_wtf );				
					}
					else
					{
						bombType = FBOMB;
						bombAlertSprite.setImage( bombAlertImage );
					}
				}
				else if( episode == 6 )
				{
					if( bombTypeChance >= 1 && bombTypeChance <= 7 )
					{
						bombType = WTFBOMB;
						bombAlertSprite.setImage( bombAlertImage_wtf );				
					}
					else
					{
						bombType = FBOMB;
						bombAlertSprite.setImage( bombAlertImage );
					}
				}
			}
		}
		
		// updates amount of time passed for drop tapping
		deltaTapMS = s3eTimerGetMs() - initialTapMS;
		if( deltaTapMS > 200 ) // within 100 milliseconds is the time to register a tap
			dropTap = false;

		// SPAWN CUBES
		if( GameState == PLAY_GAME && numOfLives > -1 && movingCubesAreRotating == false 
			&& TargetState != AT_SCORE_SCREEN ) // spawn cubes if lives are greater than zero
		{
			// This is for episode 1 tutorial, only start spawning cube when tutorial message Match Colors disappears
			if( episode == 1 && levelNumber == 1 )
			{
				if( enableFirstSpawning == true )
				{
					SpawnMovingSets(); // all buttons are deactivated until something spawns. Affected by spawningsetscounter or something.

					// update tutorial messages booleans
					if( episode == 1 && levelNumber == 1 && numMovingCubesIndex > 0 )
					{
						// show tutorial touch and drag
						if( triggeredShowTutorialTouchDrag == false )
						{
							s3eTimerSetTimer( 0, triggerShowTutorialTouchDrag, 0 );
							triggeredShowTutorialTouchDrag = true;
							showTutorialSprites[0] = true;
						}
					}
				}
			}
			else
			{
				SpawnMovingSets();
			}
		}
		else
		{
		}

		// ROTATE MOVING VERTICES
		if( rotateMovingVerticesRight == true )
		{
			RotateMovingCubesRight();
		}
		else if( rotateMovingVerticesLeft == true )
		{
			RotateMovingCubesLeft();
		}
		else if( rotateMovingVerticesUp == true )
		{
			RotateMovingCubesUp();
		}
		else if( rotateMovingVerticesDown == true )
		{
			RotateMovingCubesDown();
		}
		else if( rotateMovingVerticesClockwise == true )
		{
			RotateMovingCubesClockwise();
		}
		else if( rotateMovingVerticesCounterClockwise == true )
		{
			RotateMovingCubesCounterClockwise();
		}

		// ROTATE STATIC VERTICES
		if( rotateStaticVerticesRight == true )
		{
			RotateStaticCubesRight();
		}
		else if( rotateStaticVerticesLeft == true )
		{
			RotateStaticCubesLeft();
		}
		else if( rotateStaticVerticesUp == true )
		{
			RotateStaticCubesUp();
		}
		else if( rotateStaticVerticesDown == true )
		{
			RotateStaticCubesDown();
		}
		else if( rotateStaticVerticesClockwise == true )
		{
			RotateStaticCubesClockwise();
		}
		else if( rotateStaticVerticesCounterClockwise == true )
		{
			RotateStaticCubesCounterClockwise();
		}

		// MOVE and UPDATE the moving cubes
		// do not move if cubes are rotating b/c move updates their vertices, so no interpolation can be obtained
		if( movingCubesAreRotating == false )
		{
			// update bombs
			for( int i = numOriginalCubes; i < numStaticCubes; i++ )
			{
				if( cubeArray[i].hasBomb == true )
				{
					cubeArray[i].bomb.Update( cubeArray[i].position, modelMatrix1 );
				}
			}

			bool wasTouched = false;

			// MOVE the cubes in moving array and updates shadows
			for( int i = 0; i < numMovingCubesIndex; i++ )
			{
				Move( cubeArrayMoving + i, i ); // this automatically adds the cube to static array if it landed, and links the vertices for rendering
				UpdateShadow( shadowArray + i, i);

				// update bombs
				if( cubeArrayMoving[i].hasBomb == true )
				{
					cubeArrayMoving[i].bomb.Update( cubeArrayMoving[i].position, modelMatrix1 );
				}

				// if a cube goes from Moving to Static after landing on the static cubes
				if( cubeArrayMoving[i].isLanded == true )
				{
					
					/*
					// untouch shadow and retouch to avoid pointer conflicts
					if( selectedShadow != NULL )
					{
					//	if( selectedShadow->cube->ID != cubeArrayMoving[i].ID )
						{
							UntouchShadows(); // makes selectedShadow = null
							wasTouched = true;
						}
					}
					*/

					removeMovingCube( i );// remove from moving cube array if it landed after a move() iteration
					removeShadow(i);// this happens when a cube is landed, or dropped-from the touch remove event
					i--;

					// recalculate plane's layer levels, triggered by after explosion
					if( recalculateLayerLevels == true)
					{
						// recalculate the layer level for this plane side to make sure it's accurate				
						for( int i = 0; i < 6; i++ )// find the plane that is same direction as this cube
						{
							// reset layer level to start comparison and search for highest layer
							plane[i].highestLayerLevel = 0;

							for( int j = numOriginalCubes; j < numStaticCubes; j++ ) // compare against all static cube of same direction
							{
								// if the cube is on the same direction
								if( cubeArray[j].direction == plane[i].direction )
								{
									// highest layer level for plane warping
									// only count highest cube if it's not exploding
									if( cubeArray[j].exploding == false && cubeArray[j].exploded == false )
									{
										if( cubeArray[j].layerLevel > plane[i].highestLayerLevel )
										{
											plane[i].highestLayerLevel = cubeArray[j].layerLevel;
										}
									}
								}
							}
						}
						recalculateLayerLevels = false;
					}

					shakeCamera = true;
				} // end of removing landed cubes from moving array
			} // end of checking all moving cubes
		} // end of if cubes are rotating

		// safecheck CALCULATE PLANE'S COUNTS
		for( int i = 0; i < 6; i++ )
		{
			// reset plane's count for calculation
			plane[i].count = 0; 

			for( int j = numOriginalCubes; j < numStaticCubes; j++ )
			{
				if( cubeArray[j].layerLevel == 1 && cubeArray[j].color == plane[i].color && cubeArray[j].direction == plane[i].direction && plane[i].active == true)
				{
					plane[i].count++;
				}
			}
		}

		// QFI Algorithm to determine leven increase or decrease
		/*
		difficulty  planeSpawn  cubeSpawn		NumOfSides NumOfCubes
		1			SINGLE_RAN	SINGLE_RAN		1			1
		2			DOUBLE_ADJ	SINGLE_RAN		2			1
		3			DOUBLE_ADJ	DOUBLE_INC - 3	2			2
		4			DOUBLE_RAN	DOUBLE_RAN		2			2
		5			TRIPLE_RAN	DOUBLE_RAN		3			2
		6			QUAD_RAN	DOUBLE_RAN		4			2
		7			TRIPLE_RAN	TRIPLE_INC - 7	3			3
		8			TRIPLE_RAN	TRIPLE_RAN		3			
		9			QUAD_RAN	TRIPLE_RAN		4
		10			QUIN_RAN	TRIPLE_RAN		5
		11			SEXTUP_RAN	TRIPLE_RAN		6
		12			QUAD_RAN	QUAD_INC - 12	4
		13			QUAD_RAN	QUAD_RAN		4	
		14			QUIN_RAN	QUAD_RAN		5
		15			SEXTUP_RAN	QUAD_RAN		6	
		16			QUIN_RAN	QUIN_INC - 16	5
		17			QUIN_RAN	QUIN_RAN		5
		18			SEXTUP		QUIN_RAN		6
		19			SEXTUP		SEXTUP_INC - 19	6
		20			SEXTUP		SEXTUP_RAN		6
		*/

		// special case for INC spawns
		if( qfiMode == true )
		{
			if( difficulty == 3 || 
				difficulty == 7 ||
				difficulty == 12 ||
				difficulty == 16 ||
				difficulty == 19 ) // the numOfDropsRequired for performanceCheck for INC Spawns
			{
				// The first condition is for advancing levels. numOfDrops required for increasing levels is bigger than if testing for decrease in levels.
				// The value for performanceCheck for decreasing is significantly less in case player
				//	is not good enough, so it does not take too long to decrease another level if have to
				switch( difficulty ) 
				{
				case 3:
					if( targetDifficulty == difficulty || targetDifficulty > difficulty )
					{
						numOfDropsRequired = 18; // 2 INC, about 2 sides completed
					}
					else if( targetDifficulty < difficulty )
					{
						numOfDropsRequired = 16; 
					}
					break;
				case 7:
					if( targetDifficulty == difficulty || targetDifficulty > difficulty )
					{
						numOfDropsRequired = 27; // 3 INC,
					}
					else if( targetDifficulty < difficulty )
					{
						numOfDropsRequired = 16; 
					}
					break;
				case 12:
					if( targetDifficulty == difficulty || targetDifficulty > difficulty )
					{
						numOfDropsRequired = 36; // 4 INC
					}
					else if( targetDifficulty < difficulty )
					{
						numOfDropsRequired = 16; 
					}
					break;
				case 16:
					if( targetDifficulty == difficulty || targetDifficulty > difficulty )
					{
						numOfDropsRequired = 45; // 5 INC
					}
					else if( targetDifficulty < difficulty )
					{
						numOfDropsRequired = 16;
					}
					break;
				case 19:
					if( targetDifficulty == difficulty || targetDifficulty > difficulty )
					{
						numOfDropsRequired = 54; // 6 INC
					}
					else if( targetDifficulty < difficulty )
					{
						numOfDropsRequired = 16;
					}
					break;
				}
			}
			else // the numOfDropsRequired for performanceCheck for RANDOM cubeSpawns
			{
				switch( difficulty )
				{
				case 1:
					numOfDropsRequired = 9;
					break;
				default:
					numOfDropsRequired = 9;
					break;
				}
			}

			// signals for when the system should check for difficulty increase or decrease
			if( totalDropsCurrent >= numOfDropsRequired )
			{
				checkPerformance = true;
			}

			// FLOW INTERVALS
			// set the Flow bounds based on skill
			if( uAPMCurrent < 30 )
			{
				upperFlowBound = 0.42;
				lowerFlowBound = 0.35;
			}
			else if( skillIndex < 125 )
			{
				upperFlowBound = 0.35;
				lowerFlowBound = 0.30;
			}
			else if( skillIndexCurrent < 135 )
			{
				upperFlowBound = 0.35;
				lowerFlowBound = 0.30;
			}
			else if( skillIndexCurrent < 145 )
			{
				upperFlowBound = 0.32;
				lowerFlowBound = 0.25;
			}
			else if( skillIndexCurrent < 155 )
			{
				upperFlowBound = 0.27;
				lowerFlowBound = 0.20;
			}
			else if( skillIndexCurrent < 165 )
			{
				upperFlowBound = 0.22;
				lowerFlowBound = 0.15;
			}
			else
			{
				upperFlowBound = 0.17;
				lowerFlowBound = 0.10;
			}

			// Increase flow interval for the INC Sides/difficulty levels because they are easier
			if( difficulty == 3 || 
				difficulty == 7 ||
				difficulty == 12 ||
				difficulty == 16 ||
				difficulty == 19 )
			{
				upperFlowBound += 0.07; // increase by about .07 
				lowerFlowBound += 0.07;
			}

			// check for a difficulty change
			if( checkPerformance == true )
			{
				if( comfortIndexCurrent <= upperFlowBound && comfortIndexCurrent >= lowerFlowBound ) // if within FLOW interval
				{
					// DO NOTHING for now

					// Check if numOfDropsInFlowState
					inFlowState = true;

					if( totalDropsInFlowState >= 30 ) // if stayed in flow state for too long, reset qfi variables
					{
						ResetQFIVariablesCurrent();
					}
				}
				else if( comfortIndexCurrent >= upperFlowBound ) // if comfortIndex is ABOVE flow, too comfortable
				{
					inFlowState = false;

					// increase the target difficulty
					if( targetDifficultyReached == true ) // only increase if it wasn't increased / decreased before
					{
						// difficulty cap to limit QFI difficulty if necessary
						if( (targetDifficulty+1) <= qfiDifficultyCap )
						{
							targetDifficulty++;
							targetDifficultyReached = false;					
						}
					}

					if( targetDifficulty > 20 )
					{
						targetDifficulty = 20; // clamp at 20
						targetDifficultyReached = true;
					}

					SetTargetPlaneSpawning();
					SetTargetCubeSpawning();
				}
				else if( comfortIndexCurrent <= lowerFlowBound ) // if comfortIndex is BELOW flow, too challenging
				{
					inFlowState = false;

					// decrease the targetdifficulty
					if( targetDifficultyReached == true ) // only decrease if it wasn't increased / decreased before
					{
						if( difficulty == 7 ) // bypass any difficulty jumps that require an increase in plane count and go straight to same plane count
						{
							targetDifficulty = 5;
							targetDifficultyReached = false;
						}
						else if( difficulty == 12 )
						{
							targetDifficulty = 9;
							targetDifficultyReached = false;
						}
						else if( difficulty == 16 )
						{
							targetDifficulty = 14;
							targetDifficultyReached = false;
						}
						else
						{
							targetDifficulty--;
							targetDifficultyReached = false;
						}

						// decrease the cubeSpawn to decrease diff. once every time 
						switch( cubeSpawning )
						{
						case SINGLE_RANDOM:
							break;
						case DOUBLE_INCOLOR:
							cubeSpawning = SINGLE_RANDOM;
							break;
						case DOUBLE_RANDOM:
							cubeSpawning = DOUBLE_INCOLOR;
							break;
						case TRIPLE_RANDOM:
							cubeSpawning = DOUBLE_RANDOM;
							break;
						case QUADRUPLE_RANDOM:
							cubeSpawning = TRIPLE_RANDOM;
							break;
						case QUINTUPLE_RANDOM:
							cubeSpawning = QUADRUPLE_RANDOM;
							break;
						case SEXTUPLE_RANDOM:
							cubeSpawning = QUINTUPLE_RANDOM;
							break;				
						}
					} // end if the targetDifficulty was reduced by one
					else // Reduce cubeSpawning indefinitely
					{
						// decrease the cubeSpawn to decrease diff. once every time 
						switch( cubeSpawning )
						{
						case SINGLE_RANDOM:
							break;
						case DOUBLE_INCOLOR:
							cubeSpawning = SINGLE_RANDOM;
							break;
						case DOUBLE_RANDOM:
							cubeSpawning = DOUBLE_INCOLOR;
							break;
						case TRIPLE_RANDOM:
							cubeSpawning = DOUBLE_RANDOM;
							break;
						case QUADRUPLE_RANDOM:
							cubeSpawning = TRIPLE_RANDOM;
							break;
						case QUINTUPLE_RANDOM:
							cubeSpawning = QUADRUPLE_RANDOM;
							break;
						case SEXTUPLE_RANDOM:
							cubeSpawning = QUINTUPLE_RANDOM;
							break;				
						}
					}

					// resetting variables limits the amount of time cubeSpawning reduction happens
					ResetQFIVariablesCurrent();

					if( targetDifficulty < 1 )
					{
						targetDifficulty = 1;
						targetDifficultyReached = true;
					}

					SetTargetPlaneSpawning();
					SetTargetCubeSpawning();
				}

				// ensure that next time performance is checked is later
				checkPerformance = false;
			} // end of checkingperformance
		} // end of if qfiMode == true
		

		// update bomb explosion
		// Check bomb explode trigger
		// reset exploding directions
		for( int i = 0; i < 6; i++ )
		{
			bombDirectionIsExploding[i] = false;
		}

		// check which directions are exploding
		for( int i = numOriginalCubes; i < numStaticCubes; i++ )
		{
			if( bombType == FBOMB )
			{
				if( cubeArray[i].hasBomb == true )
				{
					// these are the states of the bomb where it should be starting to explode/already exploding
					if( cubeArray[i].bomb.state == Bomb::HEATING_UP ||
						cubeArray[i].bomb.state == Bomb::START_EXPLODING ||
						cubeArray[i].bomb.state == Bomb::EXPLODING)
					{
						int tempDir = cubeArray[i].direction;

						bombDirectionIsExploding[tempDir - 1] = true;

						if( bombTriggered[tempDir-1] == false && cubeArray[i].bomb.state == Bomb::HEATING_UP )
						{
							// reset material intensity for that direction
							explodingMaterialIntensity[tempDir-1] = 100;
							explodingUp[tempDir-1] = true;
							bombTriggered[tempDir-1] = true;
						}
					}
				}
			} // end of only fbomb type checking
			else if( bombType == WTFBOMB )
			{
				if( cubeArray[i].hasBomb == true )
				{
					// these are the states of the bomb where it should be starting to explode/already exploding
					if( cubeArray[i].bomb.state == Bomb::HEATING_UP ||
						cubeArray[i].bomb.state == Bomb::START_EXPLODING ||
						cubeArray[i].bomb.state == Bomb::EXPLODING)
					{
						// set every side to explode
						for( int j = 0; j < 6; j++ )
						{
							bombDirectionIsExploding[j] = true;

							if( bombTriggered[j] == false && cubeArray[i].bomb.state == Bomb::HEATING_UP )
							{
								// reset material intensity for that direction
								explodingMaterialIntensity[j] = 100;
								explodingUp[j] = true;
								bombTriggered[j] = true;
							}
						}

						break; // break out of the for loop b/c everything is already set once a bomb is set to explode
					}
				}
			}
		} // end of for loop to cycle through every cube to see if it has a bomb


		// set all cubes on that direction side to be exploding
		for( int i = 0; i < 6; i++ )
		{
			// get plane's direction
			int tempDir = plane[i].direction;

			// check if that plane is suppose to explode
			if( bombDirectionIsExploding[tempDir - 1] == true )
			{
				// explode all cubes with that side
				for( int j = numOriginalCubes; j < numStaticCubes; j++ )
				{
					// if cube is same direction as plane that is suppose to explode, explode it
					if( cubeArray[j].direction == tempDir && cubeArray[j].exploded == false )
					{
						cubeArray[j].exploding = true;
					}
				}
			}
		}

		// Story Mode updates for specifically disabling bomb if percentage complete reaches over 100% for progress bar
		if( storyMode == true )
		{
			// level up should happen on warp
			if( percentComplete >= 1.0 )
			{
				spawnBombMode = false;
				spawnBomb = false;
			}		
		}

		// check cubes for warping
		// this is where levelNumber increments
		CheckAndWarpCubes();		

		// check cubes for exploding
		CheckAndExplodeCubes();

		// update high score
		if( score > highScore )
		{
			highScore = score;
			SaveHighStats();
		}
		// update trophies
		if( highScore > 100000 )
		{
			if( trophies[0] == false )
			{
				showTrophySprite = true;

				trophies[0] = true;
				SaveHighStats();
			}

			
		}
		if( highScore > 500000 )
		{
			if( trophies[1] == false )
			{
				showTrophySprite = true;

				trophies[1] = true;
				SaveHighStats();
			}
		}
		if( highScore > 1000000 )
		{
			if( trophies[3] == false )
			{
				showTrophySprite = true;

				trophies[3] = true;
				SaveHighStats();
			}
		}
		
		// update time played
		timeFrames++;
		if( timeFrames >= RATE ) // this is fps
		{
			timeSeconds++;
			timeFrames = 0;
		}
		if( timeSeconds >= 60 )
		{
			timeMinutes++;
			timeSeconds = 0;
		}
		if( timeMinutes >= 60 )
		{
			timeHours++;
			timeMinutes = 0;
		}

		// REMOVE EXPLODED CUBES
		cubeIsExploding = false;

		// reset plane count check
		if( resetPlaneCount == true ) // this is for if everything explodes and all planes need resetting
		{
			for( int i = 0; i < 6; i++ )
			{
				plane[i].highestLayerLevel = 0;
			}
			resetPlaneCount = false;
		}
		

		// NO EXPLODING CUBES check
		for( int i = numOriginalCubes; i < numStaticCubes; i++ )
		{
			if( cubeArray[i].exploding == true && cubeArray[i].exploded == false )
			{
				cubeIsExploding = true;
				break;
			}
		}
		for( int i = numOriginalCubes; i < numStaticCubes; i++ )
		{
			if( cubeArray[i].material == Cube::WARPING_MATERIAL )
			{
				cubeIsWarping = true;
				break;
			}
		}

		// remove the exploded cubes
		if( cubeIsExploding == false ) // only remove it if there are no other simultaneously exploding cubes
		{
			for( int i = numOriginalCubes; i < numStaticCubes; i++ )
			{
				if( cubeArray[i].exploded == true )
				{					
					removeStaticCube( i );
					i--;				
				}
			}
		}
		

		// Wind system
		if( episode == 3 )
		{
			windSystem.Update( tt1 );
		}

		// make the stars spin
		// rotate the stars
		starRotationDelayTime++;
		
		if( starRotationDelayTime > 2048 )
			starRotationDelayTime %= 2048; // wrap the counter so doesn't overflow

		// increment the rotation counter of initial position
		// starRotationCounter is basically the netValue of what to rotate the star's original position by
		//if( starRotationDelayTime %2 == 1 ) ***
			starRotationCounter++;
		
		// update stars
		for( int i = 0; i < numStars; i++ )
		{
			//if( starRotationDelayTime % 2 == 1 ) // one rotation every 2 frames ***
			{
				// transform the position and make it rotate around center
				CIwMat starRotation;
				starRotation.SetIdentity();
				
				//starRotation.SetRotY( stars[i].rotationSpeed );
				starRotation.SetRotY( stars[i].rotationSpeed * starRotationCounter );

				//stars[i].position = starRotation.TransformVec( stars[i].position );
				stars[i].position = starRotation.TransformVec( stars[i].initialPosition );
			}

			CIwSVec3 transformedPosition = (CIwSVec3)bobbleMatrixStars.TransformVec( stars[i].position );
			
			// wraps the counter so it doesn't overflow
			if( starRotationCounter > 4096 )
				starRotationCounter %= 4096; // since this is the net speed, make sure this # multiplied by rotationSpeed does not exceed integer limit. rotationSpeed is max at 2

			// update vertices
			for( int j = 0; j < 4; j++ )
			{
				starsVertexStream[i*4 + j] = stars[i].vertexstream[j] + transformedPosition;
				starsNormalStream[i*4 + j] = fuzzyNormals[j];
				starsUVStream[i*4 + j] = stars[i].uvstream[j];
			}
			// episode 4 stars vertices
			if( episode == 4 || episode == 5 )
			{
				for( int j = 0; j < 4; j++ )
				{
					// scale the stars by the factor
					int STAR_SCALE_FACTOR = 2;
					stars[i].vertexstream[j].x *= STAR_SCALE_FACTOR;
					stars[i].vertexstream[j].y *= STAR_SCALE_FACTOR;

					if( i < 50 )
					{
						starsEp4VertexStream1[i*4+j] = stars[i].vertexstream[j] + transformedPosition;

						// set 1 set of uv streams
						starsEp4UVStream[i*4 + j ] = stars[i].uvstream[j];
					}
					else if( i < 100 )
					{
						starsEp4VertexStream2[(i-50)*4+j] = stars[i].vertexstream[j] + transformedPosition;
					}
					else if( i < 150 )
					{
						starsEp4VertexStream3[(i-100)*4+j] = stars[i].vertexstream[j] + transformedPosition;
					}
					else if( i < 200 )
					{
						starsEp4VertexStream4[(i-150)*4+j] = stars[i].vertexstream[j] + transformedPosition;
					}

					// reduce the stars by the factor
					stars[i].vertexstream[j].x /= STAR_SCALE_FACTOR;
					stars[i].vertexstream[j].y /= STAR_SCALE_FACTOR;
				}
			}
		}
		
		// SCORE update
		UpdateScore(); // really checks to see if it is over 9999. Score gets increased at CheckAndWarpCubes

		// AUTOSNAP for camera
		if( autosnap == true )
			AutoSnap();

		// SHAKE the camera
		if( shakeCamera == true )
			ShakeCamera();

		if( shakeCameraMedium == true )
			ShakeCameraMedium();

		if( shakeCameraGigantic == true )
			ShakeCameraGigantic();

		// CREATE VERTEX STREAM
		CreateVertexStream();
		CreateShadowVertexStream();

		// Update Shadow Blinking
		UpdateShadowBlinking();

		
		
		// Update QFI variables
		// Efficiency Index
		if( totalDrops != 0 ) // no division by zero
		{
			efficiencyIndex = (double)scoredDrops/(double)totalDrops;
		}
		else
		{
			efficiencyIndex = 0;
		}

		if( totalDropsCurrent != 0 ) // no division by zero
		{
			efficiencyIndexCurrent = (double)scoredDropsCurrent/(double)totalDropsCurrent;
		}
		else
		{
			efficiencyIndexCurrent = 0;
		}
		
		// Multitasking Index, they are not calculated for INCOLOR spawning because DTL may not be necessary to play well
		if( totalDroppedCubeSets != 0 ) // CUMULATIVE multitaskingIndex
		{
			averageDTL = totalDTL / totalDroppedCubeSets;
		}
		multitaskingIndex = averageDTL / startingHeight;

		if( totalDroppedCubeSetsCurrent != 0 ) // CURRENT multitaskingIndex
		{
			averageDTLCurrent = totalDTLCurrent / totalDroppedCubeSetsCurrent;
		}
		multitaskingIndexCurrent = averageDTLCurrent / startingHeight;
		 

		// Panic and Comfort levels
		//if( totalDroppedCubeSetsCurrent != 0 ) // only calculate comfort index after cube dropped once
		if( totalDroppedCubeSetsCurrent != 0 )
		{
			comfortIndexCurrent = multitaskingIndexCurrent - panicLimit;
		}
		else
		{
			comfortIndexCurrent = 0;
		}		

		if( totalDroppedCubeSets != 0 )
		{
			comfortIndex = multitaskingIndex - panicLimit;
		}
		else
		{
			comfortIndex = 0;
		}

		// multitasking index and comfort index are only calculated if the spawn types are RANDOM
		// otherwise you can just move and choose to not drop and let cubes fall if they spawn INCOLOR

		// APM
		// Start the timer for current apm calculation
		if( apmTime0Current == 0 && idleCounter == 0 ) // if timer was not running and cubes are in play, and there was an action
		{
			if( numMovingCubesIndex != 0 )
			{
				apmTime0Current = (int32)s3eTimerGetMs();
			}
		}

		// Start the timer for average apm calculation
		if( apmTime0 == 0 ) // if timer was not running and cubes are in play, start it
		{
			if( numMovingCubesIndex != 0 )
			{
				apmTime0 = (int32)s3eTimerGetMs();
			}
		}

		// Stop the timer for current apm calculation if no cubes in play
		if( numMovingCubesIndex == 0 )
		{
			apmTime0Current = 0;
			apmTotalTimeSavedCurrent = apmTotalTimeCurrent;
		}

		// Stop the timer for average apm calculation if no cubes in play
		if( numMovingCubesIndex == 0 )
		{
			apmTime0 = 0;
			apmTotalTimeSaved = apmTotalTime;
			
		}

		// Calculate Time passed for current apm calculation
		if( apmTime0Current > 0 ) // calculate time if timer is running
		{
			apmTime1Current = s3eTimerGetMs();
			apmTotalTimeCurrent = apmTotalTimeSavedCurrent + apmTime1Current - apmTime0Current; // for current/instantaneous apm
		}

		// Calculate Time passed for average apm calculation
		if( apmTime0 > 0 ) // calculate time if timer is running
		{
			apmTime1 = s3eTimerGetMs();
			apmTotalTime = apmTotalTimeSaved + apmTime1 - apmTime0; // for average apm]			
		}

		
		
		// Calculate the current apm
		if( apmInstantaneousTime > 0 )
		{
			//uAPMCurrentMilli = (double)totalActionsCurrent / apmCurrentTime; 
			uAPMInstantaneous = apmMilliInstantaneous * 1000 * 60; // 1000 scales milliseconds to seconds. 60 scales seconds to minute
		}

		// Calculate the average apm
		if( apmTotalTimeCurrent > 0 )
		{
			uAPMMilliCurrent = (double)totalActionsCurrent / apmTotalTimeCurrent; 
			
			uAPMCurrent = uAPMMilliCurrent * 1000 * 60;			
		}

	
		// Calculate the average apm
		if( apmTotalTime > 0 )
		{
			uAPMMilli = (double)totalActions / apmTotalTime; 
			
			uAPM = uAPMMilli * 1000 * 60;			
		}
		
		
		apmInterval = s3eTimerGetMs() - apmIntervalTime0; // increase interval if not dropped
		uAPMInstantaneous =	(1.0 / apmInterval) * 60000;
		

		// Calculate skill
		int16 numSpawningCubes = 0;

		switch( cubeSpawning )
		{
		case SINGLE_RANDOM:
			numSpawningCubes = 1;
			break;
		case DOUBLE_INCOLOR:
			numSpawningCubes = 2;
			break;
		case DOUBLE_RANDOM:
			numSpawningCubes = 2;
			break;
		case TRIPLE_INCOLOR:
			numSpawningCubes = 3;
			break;
		case TRIPLE_RANDOM: 
			numSpawningCubes = 3;
			break;
		case QUADRUPLE_INCOLOR:
			numSpawningCubes = 4;
			break;
		case QUADRUPLE_RANDOM:
			numSpawningCubes = 4;
			break;
		case QUINTUPLE_INCOLOR:
			numSpawningCubes = 5;
			break;
		case QUINTUPLE_RANDOM:
			numSpawningCubes = 5;
			break;
		case SEXTUPLE_INCOLOR:
			numSpawningCubes = 6;
			break;
		case SEXTUPLE_RANDOM:
			numSpawningCubes = 6;
			break;
		}

		// speed increments are the number of 200 units after the first 200
		// must increase skill by this amount as speed decreases
		int16 speedIncrements = INITIAL_SPEED / 200;
		double speedIncrementIndex = speedIncrements/4; // a maximum of spd of 800 equals 1
		
		
		// Calculate Skill + speedIncrementIndex*.2
		// efficiency is exponential while multitasking is linear. Still need to offset skill with the speed		
		performanceIndex = ( (efficiencyIndex*efficiencyIndex + numSpawningCubes*(.1*speedIncrementIndex))*100 + (multitaskingIndex + numSpawningCubes*.2 + (.2*speedIncrementIndex) )*100 );
		performanceIndexCurrent = ( (efficiencyIndexCurrent*efficiencyIndexCurrent + numSpawningCubes*(.1*speedIncrementIndex))*100 + (multitaskingIndexCurrent + numSpawningCubes*.2 + (.2*speedIncrementIndex) )*100 );

		if( difficulty >= 1 && difficulty <= 3 ) // normal apm if levels 1-3
		{
			skillIndex = (performanceIndex + uAPM) / 2;
		}
		else // double the APM if playing a mode where cubes are constantly in play
		{
			skillIndex = (performanceIndex + uAPM*4/3) / 2;
		}

		if( difficulty >= 1 && difficulty <= 3 ) // normal apm if levels 1-3
		{
			skillIndexCurrent = (performanceIndexCurrent + uAPMCurrent) / 2;
		}
		else // double the APM if playing a mode where cubes are constantly in play
		{
			skillIndexCurrent = (performanceIndexCurrent + uAPMCurrent*4/3) / 2;
		}
		
		skillIndexRatio = 1 / 80.0 * skillIndex - 1.0;

		// Ends the Game if no more lives left, and back to normal camera
		if( numOfLives <= -1 )
		{
			
		}
	}	// end of play_game updates
	else if( GameState == GAME_OVER )
	{

	}

	// misc updates
	if( GameState == AT_SCORE_SCREEN )
	{

	}

	// Story Mode updates
	if( storyMode == true )
	{
			
	}
	// Challenge Mode updates
	if( challengeMode == true )
	{
		// reset drops if incrementing speed level
		if( totalDrops >= cmNumOfRequiredDrops[cmDifficultyLevel]*5 )
		{
			totalDropsCurrent = cmNumOfRequiredDrops[cmDifficultyLevel]; // clamp the totaldropscurrent if on last level. this is being used for progress bar
			cmSpeedLevel = 6;
		}
		else if( totalDropsCurrent >= cmNumOfRequiredDrops[cmDifficultyLevel] )
		{
			totalDropsCurrent %= cmNumOfRequiredDrops[cmDifficultyLevel];
			cmSpeedLevel++;
		}

		switch( cmSpeedLevel )
		{
		case 1:
			INITIAL_SPEED = 200;
			break;
		case 2:
			INITIAL_SPEED = 400;
			break;
		case 3:
			INITIAL_SPEED = 600;
			break;
		case 4:
			INITIAL_SPEED = 800;
			break;
		default:
			INITIAL_SPEED = 1000;
			break;
		}
	}


	// Stop the timer for PAUSED state apm calculation
	if( GameState == PAUSED )
	{
		apmTime0Current = 0;
		apmTotalTimeSavedCurrent = apmTotalTimeCurrent;

		apmTime0 = 0;
		apmTotalTimeSaved = apmTotalTime;
	}

	// Reset tutorial Highlights if exited tutorial mode
	if( GameState != PLAY_TUTORIAL )
	{
		tutorialTouchDragPassed = false;
		tutorialRotateCubePassed = false;
		tutorialTapDropPassed = false;
		tutorialCompleteSidePassed = false;
		tutorialRotateCameraPassed = false;
		tutorialFlipCubePassed = false;
		tutorialCompleteSide2Passed = false;		

		tutorialRightButtonHighlightEnabled = false; // enable right button highlight to be rendered
	}

	
	if( GameState == AT_MENU )
	{
		if( isTouched == true || isTouched1 == true ) // isTouched1 is for the multitouchbutton function
		{
			bool initialPressed = false;
			for( int i = 0; i < numOfActiveMenuCubes; i++ )
			{
				if( menuCubes[i].button.initialPressed == true )
				{
					initialPressed = true;
				}
			}

			// rotate the menu only if none of the buttons were pressed but screen is still touched
			if( initialPressed == false && enableNewStoryConfirmationScreen == false )
			{
				// make the swipe glow if swiping
				if( deltaX1 != 0 )
				{
					swipeArrowsSprite.setImage( swipeGlowImage );
				}
				
				for( int i = 0; i < numOfActiveMenuCubes; i++ )
				{
					menuCubes[i].grabAndSetSwipe( deltaX1 );
				}

				swipeVelocity = (deltaX1 - deltaX1Two) / 2;
				if( swipeVelocity >= 20 )
				{
					swipeVelocity = 20;
				}
				else if( swipeVelocity <= -20 )
				{
					swipeVelocity = -20;
				}
			}	
		}
		else // if there is no touch on screen
		{
			// set the swipe image to not glow
			swipeArrowsSprite.setImage( swipeArrowsImage );

			if( abs(swipeVelocity) < 10 ) // the terminating condition if swipe velocity dips below limit, start using menuCube's autosnap
			{
				// this resets the deltaX1 and stuff. Need to put these lines also when first touch
				for( int i = 0; i < numOfActiveMenuCubes; i++ )
				{
					menuCubes[i].releaseSwipe();
				}
				
				deltaX1 = 0;
				deltaX1Two = 0;
			}
			else if( swipeVelocity != 0 )
			{
				deltaX1 += swipeVelocity;

				for( int i = 0; i < numOfActiveMenuCubes; i++ )
				{
					menuCubes[i].grabAndSetSwipe( deltaX1 );
				}

				if( swipeVelocity < 0 )
				{
					swipeVelocity += 1;
				}
				else if( swipeVelocity > 0 )
				{
					swipeVelocity -= 1;
				}
			}
		}

		deltaX1Two = deltaX1;
	}
	

	
	// DEBUG
	int32 currentHeap = s3eMemoryGetInt(S3E_MEMORY_HEAP);  // Current Heap
    int32 heapSize = s3eMemoryGetInt(S3E_MEMORY_SIZE); // Total size of the current heap
    int32 heapFree = s3eMemoryGetInt(S3E_MEMORY_FREE); // Total amount of free space left on the current heap
    int32 heapUsed = s3eMemoryGetInt(S3E_MEMORY_USED); // Free memory minus heap size

	
	//RenderTime = RenderTime1;
	//RenderTime1 = s3eTimerGetMs() / 40; // the denominator represents the factor to divide by to create the desired FPS, or updates per second
									// the 40 represents how many MS intervals to update one time
									// 40 ms per update = 1000 ms for 25 updates = 25 updates per second
									// 25 ms per update = 1000 ms for 40 updates = 40 updates per second

	RealTime = RealTime1;
	RealTime1 = s3eTimerGetMs() / 1000;	

	if (RealTime1 - RealTime == 1) // when there is a difference of 1 after integer division, one real second has passed.
	{
		//printf("GameState is: %d, ScoreState is: %d \n", PLAY_GAME, AT_SCORE_SCREEN);
		//printf("Current state is: %d, Target State is %d \n", GameState, TargetState );
		//printf("The cube's distanceToLanding is %d \n", cubeArrayMoving[0].distanceToLanding);
		//printf("bombfrequency is %d \n", bombFrequency );
		//printf("height is: %d, landing mark is: %d \n", fallMatrix.GetTrans().z, -s*8 );
		//printf("speed is %d: \n", INITIAL_SPEED );
		//printf("WorldX is: %d, worldY is: %d \n", worldX, worldY );
		//printf("drops left: %d \n", 100 - totalDrops );
		//printf("instantaneous apm is %f \n", uAPMInstantaneous );
		//printf("            efficiency is %f \n            current apm is %f \n            average apm is %f. \n            multitasking is %f \n            current comfort Index is %f. \n            averageComfortIndex is %f \n", efficiencyIndex, uAPMCurrent, uAPM, multitaskingIndex, comfortIndexCurrent, comfortIndex);
		//printf("            skill is %f \n\n", skillIndex );
		
		//printf("Time is %d. ", RealTime1 );

		//printf("apm is %f. comfortIndex is %f. upperFlowBound is %f. lowerFlowBound is %f \n", uAPMCurrent, comfortIndexCurrent, upperFlowBound, lowerFlowBound );
		//printf("TargetDiffReached: %d, Difficulty is: %d  TargetDifficulty is: %d  Drops Left Before Performance Check: %d \n\n", targetDifficultyReached, difficulty, targetDifficulty, numOfDropsRequired - totalDropsCurrent );
		
		//printf("current multitasking is: %f \n", multitaskingIndexCurrent );
		//printf("comfort index is: %f \n", comfortIndex );

		//printf("currentHeap is %d. heapSize is %d. heapFree is %d. heapUsed is %d \n", currentHeap, heapSize, heapFree, heapUsed );		
		//printf("Skill is: %f. Skill index ratio is: %d \n", skillIndex, (int16)(skillIndexRatio * 100) );
		//printf(" Efficiency is: %f \n", efficiencyIndex);
		//printf("time is: %d hours, %d minutes, %d seconds \n", timeHours, timeMinutes, timeSeconds);

		//printf("Starting at checkpoint is %d \n", startAtCheckpoint );
	}
	
	// Update IwGx state time stamp
	IwGxTickUpdate(); // all UV animations will advance one frame for each call to IwGxTickUpdate
	return true;
}

void Render()
{
	// Clear the screen
	IwGxClear(IW_GX_COLOUR_BUFFER_F | IW_GX_DEPTH_BUFFER_F);

	

	// lighting
	if( episode == 3 )
	{
		lightDir = CIwSVec3( 0, 0, 1 );
		lightDir.Normalise();
		//lightDir = tt1.TransformVec( lightDir );
		CIwSVec3 lightPos = CIwSVec3(10*s*-1, 10*s*-1, 5*s*-1);
		IwGxSetLightPos( 1, &lightPos );
	}
	else
	{
		lightDir = CIwSVec3( 1, 1, 1 );
		lightDir.Normalise();
		CIwSVec3 lightPos = CIwSVec3(0, 0, 0);
		IwGxSetLightPos( 1, &lightPos );
	}

	IwGxSetLightDirn(1, &lightDir);
	

	// Start with no lighting
	if( lighting == false )
		IwGxLightingOff();
	else
		IwGxLightingOn();
	if( GameState == AT_LOADING_BACKGROUND )
	{
		splashSprite.Render();
	}
	else if( GameState == AT_SPLASH )
	{
		splashSprite.Render();
	}
	else if( GameState == AT_TITLE )
	{
		titleSprite.Render();
	}
	else if( GameState == AT_LOADING_MENU )
	{
		// here
		DisplayLoadingWithoutRefresh();
	}
	else if( GameState == AT_LOADING_LEVEL )
	{
		// here
		DisplayLoadingWithoutRefresh();
	}
	else if( GameState == CHOOSE_DIFFICULTY )
	{
		difficultyStartButton.setLocation(128 - 64, 64 );
		difficultyEasyButton.setLocation( 256 - 64, 64 );
		difficultyMediumButton.setLocation( 384 - 64, 64 );
		difficultyHardButton.setLocation( 480 - 64, 64 );

		difficultyStartButton.Render();
		difficultyEasyButton.Render();
		difficultyMediumButton.Render();
		difficultyHardButton.Render();

		testButton.setLocation( 480 - 64, 256 );
		testButton.Render();

		IwGxFontSetCol(0xffccffff);
		IwGxFontSetRect( CIwRect( 0 + 50, 0 + 235, 480, 200 ) );
		CIwGxFontPreparedData difficultyData;
	
		// int16 testNumber = 80;
		char difficultyChar[200] = "";
		//strcat( str, " Today is a good day.");	

		string planeSp;
		string cubeSp;
		string speed;

		switch( planeSpawning )
		{
		case SINGLE_RANDOM:
			planeSp = "1 R";
			break;
		case DOUBLE_ADJACENT:
			planeSp = "2 ADJ";
			break;
		case DOUBLE_RANDOM:
			planeSp = "2 R";
			break;
		case TRIPLE_RANDOM:
			planeSp = "3 R";
			break;
		case QUADRUPLE_RANDOM:
			planeSp = "4 R";
			break;
		case QUINTUPLE_RANDOM: 
			planeSp = "5 R";
			break;
		case SEXTUPLE:
			planeSp = "6 R";
			break;
		}
	
		switch( cubeSpawning )
		{
		case SINGLE_RANDOM:
			cubeSp = "1 R";
			break;
		case DOUBLE_INCOLOR:
			cubeSp = "2 INC";
			break;
		case DOUBLE_RANDOM:
			cubeSp = "2 R";
			break;
		case TRIPLE_INCOLOR:
			cubeSp = "3 INC";
			break;
		case TRIPLE_RANDOM: 
			cubeSp = "3 R";
			break;
		case QUADRUPLE_INCOLOR:
			cubeSp = "4 INC";
			break;
		case QUADRUPLE_RANDOM:
			cubeSp = "4 R";
			break;
		case QUINTUPLE_INCOLOR:
			cubeSp = "5 INC";
			break;
		case QUINTUPLE_RANDOM:
			cubeSp = "5 R";
			break;
		case SEXTUPLE_INCOLOR:
			cubeSp = "6 INC";
			break;
		case SEXTUPLE_RANDOM:
			cubeSp = "6 R";
			break;
		}

		switch( INITIAL_SPEED )
		{
		case 100:
			speed = "100";
			break;
		case 200:
			speed = "200";
			break;
		case 300:
			speed = "300";
			break;
		case 400:
			speed = "400";
			break;
		case 600:
			speed = "600";
			break;
		case 800:
			speed = "800";
		}

		std::ostringstream sout2; // creating an output string stream
		sout2 << "P: " << planeSp << "   S: " << cubeSp << "  " << INITIAL_SPEED; // sending an integer into string stream
		string difficultyString = sout2.str();// retrieving the string from the string stream

		strcat( difficultyChar, difficultyString.c_str() ); // converting the string to cstring
		//Draw the text
		IwGxFontPrepareText( difficultyData, difficultyChar);
		IwGxFontDrawText( difficultyData );
	}
	else if( GameState == AT_MENU || 
		GameState == AT_CHALLENGE_MENU_SCREEN ||
		GameState == AT_HIGH_SCORE_MENU_SCREEN ||
		GameState == AT_CREDITS_MENU_SCREEN ||
		GameState == AT_TUTORIAL_MENU_SCREEN)
	{
		// render version number
		CIwGxFontPreparedData versionData;
		char versionChar[100] = "";

		std::ostringstream ostream; // creating an output string stream
		// set current version
		// version number
		ostream << "1.14";

		strcat( versionChar, (ostream.str()).c_str() ); // converting the string to cstring
		//Draw the text
		//IwGxFontPrepareText( versionData, versionChar);
		//IwGxFontSetRect( CIwRect(IwGxGetScreenWidth() - 35, IwGxGetScreenHeight() - 35, IwGxGetScreenWidth(), IwGxGetScreenHeight()) );
		//IwGxFontDrawText( versionData );


		// let menu transition keep on fading in as menu is being displayed
		// render until frameCounter == end then stop

		// render Background first
		IwGxSetModelMatrix(&bobbleMatrixBackground); // this sets the transform matrix for rendered model.
		sphere->Render(); // sphere is background
		//redCube->Render();

		for( int i = 0; i < numOfActiveMenuCubes; i++ )
		{
			menuCubes[i].Render();
		}

		// if the second sprite is waiting to be rendered and first sprite has not looped once
		if( menuTitleSprite.loopCount != 1 && menuTitleSprite2.frameCounter == 0 )
		{
			menuTitleSprite.Render();		
		}
		else if( menuTitleSprite2.loopCount != 1 && menuTitleSprite3.frameCounter == 0  )
		{
			menuTitleSprite2.Render();
		}
		else if( menuTitleSprite3.loopCount != 1 && menuTitleSprite4.frameCounter == 0  )
		{
			menuTitleSprite3.Render();
		}
		else
		{
			menuTitleSprite4.Render();

			// if fourth sprite ends looping
			if( menuTitleSprite4.loopCount >= 1 )
			{
				// reset both sprites
				menuTitleSprite.resetAndPlayAnimation();
				menuTitleSprite2.resetAndPlayAnimation();
				menuTitleSprite3.resetAndPlayAnimation();
				menuTitleSprite4.resetAndPlayAnimation();
			}
		}

		swipeArrowsSprite.Render();
		Bubbly.Render();

		// render stars for menu
		IwGxSetMaterial( starMaterial[0] );			

		IwGxSetColStream( NULL ); // col stream overrides material. Take note.
		IwGxSetModelMatrix( &bobbleMatrixStars ); // uses tt1
		IwGxSetColStream( NULL );
		IwGxSetUVStream( starsUVStream );
		IwGxSetNormStream( starsNormalStream, numStars * 4 );

		CIwSVec3 viewSpaceLocation = (CIwSVec3)IwGxGetWorldViewMatrix().TransformVec( tt1.TransformVec( CIwSVec3(0, 0, 0) ));
		//CIwSVec3 viewSpaceLocation = (CIwSVec3)tt1.TransformVec( CIwSVec3(0, 0, 0) );
		//CIwSVec3 viewSpaceLocation = (CIwSVec3)IwGxGetModelMatrix().TransformVec( modelMatrix1.TransformVec( CIwSVec3(0, 0, 0) ));
		IwGxSetViewSpaceOrg(&viewSpaceLocation);
		IwGxSetVertStreamViewSpace( starsVertexStream, numStars * 4 );

		IwGxDrawPrims( IW_GX_QUAD_LIST,NULL, numStars * 4 );

		if( showQuestionMarkScreen == true )
		{
			questionMarkScreen.Render();
		}

		/*
		// show iAd - move this from not in menu, but into game
		if( hasIAd == true )
		{
			if( s3eIOSIAdGetInt( S3E_IOSIAD_RUNNING ) == 1 &&  s3eIOSIAdGetInt( S3E_IOSIAD_BANNER_LOADED ) == 1 )
			{
				s3eIOSIAdSetInt( S3E_IOSIAD_BANNER_SHOW, 1 );
			}
			else
			{
				s3eIOSIAdSetInt( S3E_IOSIAD_BANNER_SHOW, 0 );
			}
		}
		*/

		// also ping a website for connection to see if iAd should continue rendering
	} // end of AT_MENU
	else if( GameState == PLAY_GAME || GameState == PLAY_TUTORIAL || GameState == PAUSED || GameState == AT_SCORE_SCREEN ) // render the game regardless of paused or not
	{

		// render Background first
		IwGxSetModelMatrix(&bobbleMatrixBackground); // this sets the transform matrix for rendered model.
		if( episode == 1 )
		{
			sphere->Render(); // sphere is background
		}
		else if( episode == 2 )
		{
			sphere2->Render();
		}
		else if( episode == 3 )
		{
			IwGxSetModelMatrix( &(rumbleMatrix * bobbleMatrixBackground * fallMatrix) );
			sphere3->Render();

			windSystem.Render();
		}
		else if( episode == 4 )
		{
			/*
			CIwMat rotateCorrectionX;
			CIwMat rotateCorrectionY;
			CIwMat rotateCorrectionZ;

			rotateCorrectionX.SetRotX( ep4RotateCounter++ );
			rotateCorrectionY.SetRotY( ep4RotateCounter++ );
			rotateCorrectionZ.SetRotZ( ep4RotateCounter++ );
			*/

			CIwMat rotateCorrection;
			rotateCorrection.SetRotY( 200 );

			IwGxSetModelMatrix( &(rotateCorrection * rumbleMatrix * bobbleMatrixBackground));
			sphere4->Render();
		}
		else if( episode == 5 )
		{
			CIwMat rotateCorrection;
			rotateCorrection.SetRotY( 200 );

			IwGxSetModelMatrix( &(bobbleMatrixBackground * rotateCorrection) );
			sphere5->Render();
		}
		else if( episode == 6 )
		{
			sphere6->Render();
		}
		else
		{
			sphere->Render(); // sphere is background
		}

			
		//testSprite.Render();
		// render LIFE
		
		//lifeTwo.Render();
		//lifeThree.Render();

		// render Bomb Defused
		// Render Congrats, only for play game
		if( showBombDefusedSprite == true )
		{
			bombDefusedSprite.Render();

			if( bombDefusedSprite.loopCount == 1 )
			{
				showBombDefusedSprite = false;
				bombDefusedSprite.resetAndPlayAnimation();
			}
		}

		// render Minus One Fuzzy
		for( int i = 0; i < 6; i++ )
		{
			for( int j = 0; j < 9; j++ )
			{
				if( minusOneFuzzy[i][j] == true )
				{
					minusOneFuzzySprite[i][j].Render();

					// check if sprite finished rendering, then reset the boolean for rendering
					if( minusOneFuzzySprite[i][j].loopCount == 1 )
					{
						minusOneFuzzy[i][j] = false;
						minusOneFuzzySprite[i][j].resetAndPlayAnimation();
					}
				}
			}
		}

		// render PLUS POINTS
		//pointSprites[0][0].Render();
		for( int i = 0; i < 7; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				if( pointSprites[i][j].type != PointSprite::NONE ) // if the type of point sprites is not none, render it
				{
					pointSprites[i][j].Render();

					// check if the sprite finished rendering, then reset its type
					if( pointSprites[i][j].finishedRendering() == true )
					{
						pointSprites[i][j].setType( PointSprite::NONE );
						pointSprites[i][j].resetAndPlayAnimation(); // need to do this to reset counters
					}
				}
			}
		}

		

		// render ONLY PlayGame state or if Paused in PlayGame state
		if( GameState == PLAY_GAME || ( GameState == PAUSED && atTutorial == false ) || (GameState == AT_SCORE_SCREEN && atTutorial == false ) )
		{
			// Render Level Up and Congrats Sprites
			if( showCongratsSpriteLevelUp == true )
			{
				congratsSpriteLevelUp.Render();

				// immediately turn off level up when started rendering perk
				levelUp = false;

				if( congratsSpriteLevelUp.loopCount == 1 )
				{
					showCongratsSpriteLevelUp = false;
					congratsSpriteLevelUp.resetAndPlayAnimation();

					if( episode >= 1 && episode <= 3 )
					{
						if( levelNumber == 4 || levelNumber == 7 )
						{
							// the target state is set in checkandwarpcubes, should be targetstate = at_score_screen
							transition = true;
							transitionIsSet = false;	
						}
					}
				}
			}

			// Render Congrats, only for play game
			if( showCongratsSpriteGreat == true )
			{
				congratsSpriteGreat.Render();

				if( congratsSpriteGreat.loopCount == 1 )
				{
					showCongratsSpriteGreat = false;
					congratsSpriteGreat.resetAndPlayAnimation();

					if( levelUp == true )
					{
						showCongratsSpriteLevelUp = true;
						if( levelNumber != 10 )
						{
							playLevelUpSound();
						}
					}
				}
			}
			else if( showCongratsSpriteSuper == true )
			{
				congratsSpriteSuper.Render();

				if( congratsSpriteSuper.loopCount == 1 )
				{
					showCongratsSpriteSuper = false;
					congratsSpriteSuper.resetAndPlayAnimation();
					
					if( levelUp == true )
					{
						showCongratsSpriteLevelUp = true;
						if( levelNumber != 10 )
						{
							playLevelUpSound();
						}
					}
				}
			}
			else if( showCongratsSpriteNice == true )
			{
				congratsSpriteNice.Render();

				if( congratsSpriteNice.loopCount == 1 )
				{
					showCongratsSpriteNice = false;
					congratsSpriteNice.resetAndPlayAnimation();
					
					if( levelUp == true )
					{
						showCongratsSpriteLevelUp = true;
						if( levelNumber != 10 )
						{
							playLevelUpSound();
						}
					}
				}
			}
			// complete perk rendered after the white fadeout
			
			if( showTrophySprite == true )
			{
				trophySprite.Render();

				if( trophySprite.loopCount == 1 )
				{
					showTrophySprite = false;
					trophySprite.resetAndPlayAnimation();
				}
			}

			/*
			// render rectangle
			// get percentage of game completed.
			double percentComplete = totalDrops / 200.0;
			int16 rectWidth = 110;
			int16 rectHeight = 20;
			int16 fillWidth = (int16)(percentComplete * rectWidth);
			CIwColour currentColor = Iw2DGetColour();

			Iw2DSetColour( 0xff00ff00 ); // set green
			Iw2DFillRect( CIwSVec2( 20, 40), CIwSVec2( fillWidth, rectHeight ) ); // fill rectangle
			Iw2DSetColour( 0xffccffff );
			Iw2DDrawRect( CIwSVec2( 20, 40), CIwSVec2(rectWidth, rectHeight) ); // draw rectangle

			Iw2DSetColour( currentColor );
			*/

			// render Progress bar
			progressBarSprite.Render();
			progressBarFrameSprite.Render();

			if( percentComplete >= 1.0 )
			{
				progressBarGlowSprite.Render();
			}

			progressBarFuzzySprite.Render();
			
			if( storyMode == true )
			{
				// render Level number for story mode
				IwGxFontSetCol(0xffccffff); // yellow, when setting it's abgr

				//Set the formatting rect - this controls where the text appears and what it is formatted against
				//IwGxFontSetRect( CIwRect( 10, 50, (int16)IwGxGetScreenWidth()-10, (int16)IwGxGetScreenHeight()-50) );
				IwGxFontSetRect( CIwRect( width*.021, height*.156, (int16)IwGxGetScreenWidth()-width*.021, (int16)IwGxGetScreenHeight()-height*.156) );

				CIwGxFontPreparedData levelData;
				char levelStr[100] = "Level ";

				std::ostringstream levelSout; // creating an output string stream

				// print episode and level number, but clamp the levelNumber display
				if( levelNumber >= 10 )
				{
					levelSout << episode << "-Complete!";
				}
				else if( episode >= 4 && episode <= 6 )
				{
					if( levelNumber >= 6 )
					{
						levelSout << episode << "-Complete!";
					}
					else
					{
						levelSout << episode << "-" << levelNumber;
					}
				}
				else
				{
					levelSout << episode << "-" << levelNumber;
				}

				string level = levelSout.str();// retrieving the string from the string stream
				strcat( levelStr, level.c_str() ); // converting the string to cstring

				// draw the shadow
				IwGxFontSetCol(0xff990033); // setting it's abgr
				IwGxFontPrepareText( levelData, levelStr);
				IwGxFontDrawText( levelData );

				//Draw the text
				IwGxFontSetCol(0xffccffff); // yellow, when setting it's abgr
				IwGxFontSetRect( CIwRect( width*.021 - width*.002, height*.156 - height*.006, (int16)IwGxGetScreenWidth()-width*.021, (int16)IwGxGetScreenHeight()-height*.156) );
				IwGxFontPrepareText( levelData, levelStr);
				IwGxFontDrawText( levelData );


				// render ep3 timer
				if( episode == 3 && levelNumber >= 7 && levelNumber <= 9 && ep3TimerStart == true )
				{

					//Set the formatting rect - this controls where the text appears and what it is formatted against					

					CIwGxFontPreparedData ep3TimerData;
					char ep3TimerStr[100] = "";

					std::ostringstream ep3sout; // creating an output string stream

					// format string with a zero in front of seconds if less than 10
					if( ep3Seconds < 0 )
					{
						ep3sout << ep3Seconds/60 << ":00";
					}
					else if( ep3Seconds%60 < 10 )
					{
						ep3sout << ep3Seconds/60 << ":0" << ep3Seconds%60; //<< ":0" << ep3Frames/3 % 10;
					}
					else
					{
						ep3sout << ep3Seconds/60 << ":" << ep3Seconds%60;// << ":0" << ep3Frames/3 % 10;
					}
				

					string ep3TimerString = ep3sout.str();// retrieving the string from the string stream
					strcat( ep3TimerStr, ep3TimerString.c_str() ); // converting the string to cstring

					IwGxFontSetFont( ocr20 );
					
					//Draw the shadow
					IwGxFontSetCol(0xff000000); // orange, when setting it's abgr
					//IwGxFontSetRect( CIwRect( IwGxGetScreenWidth()/2 - 25, 0 + 30, 100, 100 ) );
					IwGxFontSetRect( CIwRect( IwGxGetScreenWidth()/2 - width*.052, 0 + height*.094, width, height ) );
					IwGxFontPrepareText( ep3TimerData, ep3TimerStr);
					IwGxFontDrawText( ep3TimerData );

					// draw the text
					IwGxFontSetCol(0xffccccff); // setting it's abgr
					//IwGxFontSetRect( CIwRect( IwGxGetScreenWidth()/2 - 25 -1, 0 + 30-2, 100, 100 ) );
					IwGxFontSetRect( CIwRect( IwGxGetScreenWidth()/2 - width*.052 - width*.002, 0 + height*.094-height*.006, width, height ) );
					IwGxFontDrawText( ep3TimerData );

					IwGxFontSetFont( hobo16 );
					
				}
			}
			// render STARS for challenge mode 
			if( challengeMode == true )
			{
				IwGxFontSetCol(0xffccffff); // yellow, when setting it's abgr

				//Set the formatting rect - this controls where the text appears and what it is formatted against
				IwGxFontSetRect( CIwRect( 10, 50, (int16)IwGxGetScreenWidth()-10, (int16)IwGxGetScreenHeight()-50) );

				CIwGxFontPreparedData levelData;
				char levelStr[100] = "";

				std::ostringstream levelSout; // creating an output string stream

				levelSout << cmSpeedLevel - 1 << " Stars";

				string level = levelSout.str();// retrieving the string from the string stream
				strcat( levelStr, level.c_str() ); // converting the string to cstring

				//Draw the text
				IwGxFontPrepareText( levelData, levelStr);
				IwGxFontDrawText( levelData );
			}


			// render Bomb Alert if there is bombs
			if( bombsLanded == true )
			{
				bombAlertSprite.Render();
			}

			// render Square Indicator. Only render if playing game
			blueSquare.Render();
			redSquare.Render();
			purpleSquare.Render();
			orangeSquare.Render();
			greenSquare.Render();
			yellowSquare.Render();

			// render plus one fuzzy
			if( showPlusOneFuzzy == true )
			{
				plusOneFuzzySprite.Render();

				if( plusOneFuzzySprite.loopCount == 1 )
				{
					showPlusOneFuzzy = false;
					plusOneFuzzySprite.resetAndPlayAnimation();
				}
			}
			
			
			// render LIVES. Only render for play_game
			livesSprite.Render();

			
		} // end of rendering lives and score for Play_Game

		CIwColour fullColor = {255, 255, 255, 255};
		Iw2DSetColour( fullColor );

		// render BUTTONS
		IwGxSetNormStream( NULL );		

		if( GameState == PLAY_TUTORIAL && tutorialNumber == 2 && tutorialRotateButtonHighlightEnabled == true ) // render highlight behind rotate
		{
			tutorialRotateButtonHighlightSprite.Render();
		}

		rotateButton.Render();

		if( GameState == PLAY_GAME || GameState == PLAY_TUTORIAL ) // only render Pause button if GameState = PLAYGAME or TUTORIAL. Not while PAUSED state.
		{
			IwGxSetNormStream( NULL );
			pauseButton.Render();
		}

		IwGxSetNormStream( NULL );
		rightButton.Render();

		IwGxSetNormStream( NULL );
		leftButton.Render();

		IwGxSetNormStream( NULL );
		upButton.Render();

		IwGxSetNormStream( NULL );
		downButton.Render();

		// floatingobject
		if( testFO.activated == true )
			testFO.Render();

		// CUBE2	
		// draw the cubes
		/*
		CIwMaterial* cubeMaterial = IW_GX_ALLOC_MATERIAL();
		cubeMaterial->SetAlphaMode( CIwMaterial::NONE ); // BLUE SOLID
		cubeMaterial->SetColAmbient( 30, 60, 150, 255 ); 
		cubeMaterial->SetColDiffuse( 30, 60, 150, 255 );
		cubeMaterial->SetColSpecular( 127,127,127 );
		cubeMaterial->SetSpecularPower( 15 );
		//cubeMaterial->SetShadeMode( CIwMaterial::SHADE_GOURAUD );
		IwGxSetMaterial( cubeMaterial );
		IwGxSetColStream( NULL ); // col stream overrides material. Take note.
		//IwGxSetVertStreamWorldSpace( cubeTransformed2, 24 ); // light does not move in World Space
		IwGxSetModelMatrix( &modelMatrix1 ); // use Model space b/c of light reflections during rotation
		*/
		//IwGxSetNormStream( cubeNormals2, numStaticCubes * 24 );
		//IwGxSetVertStream( cubeTranslated2, numStaticCubes * 24 ); // use Model space b/c of light reflections during rotation
		//IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, numStaticCubes * 24 );
		//IwGxSetNormStream( movingToStaticNormals, movingToStaticIndex * 24 );
		//IwGxSetVertStream( movingToStaticVertices, movingToStaticIndex * 24 ); // use Model space b/c of light reflections during rotation
		//IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, movingToStaticIndex * 24 );

		
		// Render the Cubes
		// CIwMaterial* blueSolidMaterial = IW_GX_ALLOC_MATERIAL();
		blueSolidMaterial->SetAlphaMode( alphaValue_cube ); // BLUE SOLID
		blueSolidMaterial->SetColAmbient( 150, 150, 150, 255 ); 
		blueSolidMaterial->SetColDiffuse( 150, 150, 150, 255 );
		blueSolidMaterial->SetColSpecular( 127,127,127 );
		blueSolidMaterial->SetSpecularPower( 15 );
		blueSolidMaterial->SetTexture( cubeTextureBlue );
		IwGxSetUVStream( blueSolidUVStream );

		IwGxSetMaterial( blueSolidMaterial );
		IwGxSetColStream( NULL );
		IwGxSetModelMatrix( &modelMatrix1 ); // use Model space b/c of light reflections during rotation, this is tt1

		IwGxSetNormStream( cubeNormals2, blueSolidIndex * 24 );
		IwGxSetVertStream( blueSolidVertices, blueSolidIndex * 24 ); // use Model space b/c of light reflections during rotation
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, blueSolidIndex * 24 );

		//CIwMaterial* greenSolidMaterial = IW_GX_ALLOC_MATERIAL();
		greenSolidMaterial->SetAlphaMode( alphaValue_cube ); // green SOLID
		greenSolidMaterial->SetColAmbient( 255, 255, 255, 255 ); 
		greenSolidMaterial->SetColDiffuse( 255, 255, 255, 255 );
		greenSolidMaterial->SetColSpecular( 127,127,127 );
		greenSolidMaterial->SetSpecularPower( 15 );
		greenSolidMaterial->SetTexture( cubeTextureGreen );
		IwGxSetUVStream( greenSolidUVStream );

		IwGxSetMaterial( greenSolidMaterial );
		IwGxSetColStream( NULL );
		IwGxSetModelMatrix( &modelMatrix1 ); // use Model space b/c of light reflections during rotation, this is tt1

		IwGxSetNormStream( cubeNormals2, greenSolidIndex * 24 );
		IwGxSetVertStream( greenSolidVertices, greenSolidIndex * 24 ); // use Model space b/c of light reflections during rotation
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, greenSolidIndex * 24 );

		//CIwMaterial* purpleSolidMaterial = IW_GX_ALLOC_MATERIAL();
		purpleSolidMaterial->SetAlphaMode( alphaValue_cube ); // PURPLE SOLID
		purpleSolidMaterial->SetColAmbient( 255, 255, 255, 255 ); 
		purpleSolidMaterial->SetColDiffuse( 255, 255, 255, 255 );
		purpleSolidMaterial->SetColSpecular( 127,127,127 );
		purpleSolidMaterial->SetSpecularPower( 15 );
		purpleSolidMaterial->SetTexture( cubeTexturePurple );
		IwGxSetUVStream( purpleSolidUVStream );

		IwGxSetMaterial( purpleSolidMaterial );
		IwGxSetColStream( NULL );
		IwGxSetModelMatrix( &modelMatrix1 ); // use Model space b/c of light reflections during rotation, this is tt1

		IwGxSetNormStream( cubeNormals2, purpleSolidIndex * 24 );
		IwGxSetVertStream( purpleSolidVertices, purpleSolidIndex * 24 ); // use Model space b/c of light reflections during rotation
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, purpleSolidIndex * 24 );

		//CIwMaterial* redSolidMaterial = IW_GX_ALLOC_MATERIAL();
		redSolidMaterial->SetAlphaMode( alphaValue_cube ); // RED SOLID
		redSolidMaterial->SetColAmbient( 255, 255, 255, 255 );
		redSolidMaterial->SetColDiffuse( 255, 255, 255, 255 );
		redSolidMaterial->SetColSpecular( 127,127,127 );
		redSolidMaterial->SetSpecularPower( 15 );
		redSolidMaterial->SetTexture( cubeTextureRed );
		IwGxSetUVStream( redSolidUVStream );

		IwGxSetMaterial( redSolidMaterial );
		IwGxSetColStream( NULL );
		IwGxSetModelMatrix( &modelMatrix1 ); // use Model space b/c of light reflections during rotation, this is tt1

		IwGxSetNormStream( cubeNormals2, redSolidIndex * 24 );
		IwGxSetVertStream( redSolidVertices, redSolidIndex * 24 ); // use Model space b/c of light reflections during rotation
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, redSolidIndex * 24 );

		//CIwMaterial* yellowSolidMaterial = IW_GX_ALLOC_MATERIAL();
		yellowSolidMaterial->SetAlphaMode( alphaValue_cube ); // YELLOW SOLID
		yellowSolidMaterial->SetColAmbient( 255, 255, 255, 255 );
		yellowSolidMaterial->SetColDiffuse( 255, 255, 255, 255 );
		yellowSolidMaterial->SetColSpecular( 127,127,127 );
		yellowSolidMaterial->SetSpecularPower( 15 );
		yellowSolidMaterial->SetTexture( cubeTextureYellow );
		IwGxSetUVStream( yellowSolidUVStream );

		IwGxSetMaterial( yellowSolidMaterial );
		IwGxSetColStream( NULL );
		IwGxSetModelMatrix( &modelMatrix1 ); // use Model space b/c of light reflections during rotation, this is tt1

		IwGxSetNormStream( cubeNormals2, yellowSolidIndex * 24 );
		IwGxSetVertStream( yellowSolidVertices, yellowSolidIndex * 24 ); // use Model space b/c of light reflections during rotation
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, yellowSolidIndex * 24 );

		//CIwMaterial* orangeSolidMaterial = IW_GX_ALLOC_MATERIAL();
		orangeSolidMaterial->SetAlphaMode( alphaValue_cube ); // ORANGE SOLID
		orangeSolidMaterial->SetColAmbient( 255, 255, 255, 255 );
		orangeSolidMaterial->SetColDiffuse( 255, 255, 255, 255 );
		orangeSolidMaterial->SetColSpecular( 127,127,127 );
		orangeSolidMaterial->SetSpecularPower( 15 );
		orangeSolidMaterial->SetTexture( cubeTextureOrange );
		IwGxSetUVStream( orangeSolidUVStream );

		IwGxSetMaterial( orangeSolidMaterial );
		IwGxSetColStream( NULL );
		IwGxSetModelMatrix( &modelMatrix1 ); // use Model space b/c of light reflections during rotation, this is tt1

		IwGxSetNormStream( cubeNormals2, orangeSolidIndex * 24 );
		IwGxSetVertStream( orangeSolidVertices, orangeSolidIndex * 24 ); // use Model space b/c of light reflections during rotation
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, orangeSolidIndex * 24 );

		// SHADOW TEXTURES

		// CIwMaterial* blueSolidMaterial = IW_GX_ALLOC_MATERIAL();
		blueTransMaterial->SetAlphaMode( alphaValue_cubeTransparent ); // BLUE TRANSPARENT
		blueTransMaterial->SetColAmbient( blueTransIntensity, blueTransIntensity, blueTransIntensity, 255 ); 
		blueTransMaterial->SetColDiffuse( blueTransIntensity, blueTransIntensity, blueTransIntensity, 255 );
		blueTransMaterial->SetColSpecular( 127,127,127 );
		blueTransMaterial->SetSpecularPower( 15 );
		blueTransMaterial->SetTexture( cubeTextureBlue );
		IwGxSetUVStream( blueTransUVStream );

		IwGxSetMaterial( blueTransMaterial );
		IwGxSetColStream( NULL );
		IwGxSetModelMatrix( &modelMatrix1 ); // use Model space b/c of light reflections during rotation, this is tt1

		IwGxSetNormStream( cubeNormals2, blueTransIndex * 24 );
		IwGxSetVertStream( blueTransVertices, blueTransIndex * 24 ); // use Model space b/c of light reflections during rotation
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, blueTransIndex * 24 );

		//CIwMaterial* greenTransMaterial = IW_GX_ALLOC_MATERIAL();
		greenTransMaterial->SetAlphaMode( alphaValue_cubeTransparent ); // green TRANSPARENT
		greenTransMaterial->SetColAmbient( greenTransIntensity, greenTransIntensity, greenTransIntensity, 255 ); 
		greenTransMaterial->SetColDiffuse( greenTransIntensity, greenTransIntensity, greenTransIntensity, 255 );
		greenTransMaterial->SetColSpecular( 127,127,127 );
		greenTransMaterial->SetSpecularPower( 15 );
		greenTransMaterial->SetTexture( cubeTextureGreen );
		IwGxSetUVStream( greenTransUVStream );

		IwGxSetMaterial( greenTransMaterial );
		IwGxSetColStream( NULL );
		IwGxSetModelMatrix( &modelMatrix1 ); // use Model space b/c of light reflections during rotation, this is tt1

		IwGxSetNormStream( cubeNormals2, greenTransIndex * 24 );
		IwGxSetVertStream( greenTransVertices, greenTransIndex * 24 ); // use Model space b/c of light reflections during rotation
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, greenTransIndex * 24 );

		//CIwMaterial* purpleTransMaterial = IW_GX_ALLOC_MATERIAL();
		purpleTransMaterial->SetAlphaMode( alphaValue_cubeTransparent ); // PURPLE TRANSPARENT
		purpleTransMaterial->SetColAmbient( purpleTransIntensity, purpleTransIntensity, purpleTransIntensity, 255 ); 
		purpleTransMaterial->SetColDiffuse( purpleTransIntensity, purpleTransIntensity, purpleTransIntensity, 255 );
		purpleTransMaterial->SetColSpecular( 127,127,127 );
		purpleTransMaterial->SetSpecularPower( 15 );
		purpleTransMaterial->SetTexture( cubeTexturePurple );
		IwGxSetUVStream( purpleTransUVStream );

		IwGxSetMaterial( purpleTransMaterial );
		IwGxSetColStream( NULL );
		IwGxSetModelMatrix( &modelMatrix1 ); // use Model space b/c of light reflections during rotation, this is tt1

		IwGxSetNormStream( cubeNormals2, purpleTransIndex * 24 );
		IwGxSetVertStream( purpleTransVertices, purpleTransIndex * 24 ); // use Model space b/c of light reflections during rotation
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, purpleTransIndex * 24 );

		//CIwMaterial* redTransMaterial = IW_GX_ALLOC_MATERIAL();
		redTransMaterial->SetAlphaMode( alphaValue_cubeTransparent ); // RED TRANSPARENT
		redTransMaterial->SetColAmbient( redTransIntensity, redTransIntensity, redTransIntensity, 255 );
		redTransMaterial->SetColDiffuse( redTransIntensity, redTransIntensity, redTransIntensity, 255 );
		redTransMaterial->SetColSpecular( 127,127,127 );
		redTransMaterial->SetSpecularPower( 15 );
		redTransMaterial->SetTexture( cubeTextureRed );
		IwGxSetUVStream( redTransUVStream );

		IwGxSetMaterial( redTransMaterial );
		IwGxSetColStream( NULL );
		IwGxSetModelMatrix( &modelMatrix1 ); // use Model space b/c of light reflections during rotation, this is tt1

		IwGxSetNormStream( cubeNormals2, redTransIndex * 24 );
		IwGxSetVertStream( redTransVertices, redTransIndex * 24 ); // use Model space b/c of light reflections during rotation
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, redTransIndex * 24 );

		//CIwMaterial* yellowTransMaterial = IW_GX_ALLOC_MATERIAL();
		yellowTransMaterial->SetAlphaMode( alphaValue_cubeTransparent ); // YELLOW TRANSPARENT
		yellowTransMaterial->SetColAmbient( yellowTransIntensity, yellowTransIntensity, yellowTransIntensity, 255 );
		yellowTransMaterial->SetColDiffuse( yellowTransIntensity, yellowTransIntensity, yellowTransIntensity, 255 );
		yellowTransMaterial->SetColSpecular( 127,127,127 );
		yellowTransMaterial->SetSpecularPower( 15 );
		yellowTransMaterial->SetTexture( cubeTextureYellow );
		IwGxSetUVStream( yellowTransUVStream );

		IwGxSetMaterial( yellowTransMaterial );
		IwGxSetColStream( NULL );
		IwGxSetModelMatrix( &modelMatrix1 ); // use Model space b/c of light reflections during rotation, this is tt1

		IwGxSetNormStream( cubeNormals2, yellowTransIndex * 24 );
		IwGxSetVertStream( yellowTransVertices, yellowTransIndex * 24 ); // use Model space b/c of light reflections during rotation
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, yellowTransIndex * 24 );

		//CIwMaterial* orangeTransMaterial = IW_GX_ALLOC_MATERIAL();
		orangeTransMaterial->SetAlphaMode( alphaValue_cubeTransparent ); // ORANGE TRANSPARENT
		orangeTransMaterial->SetColAmbient( orangeTransIntensity, orangeTransIntensity, orangeTransIntensity, 255 );
		orangeTransMaterial->SetColDiffuse( orangeTransIntensity, orangeTransIntensity, orangeTransIntensity, 255 );
		orangeTransMaterial->SetColSpecular( 127,127,127 );
		orangeTransMaterial->SetSpecularPower( 15 );
		orangeTransMaterial->SetTexture( cubeTextureOrange );
		IwGxSetUVStream( orangeTransUVStream );

		IwGxSetMaterial( orangeTransMaterial );
		IwGxSetColStream( NULL );
		IwGxSetModelMatrix( &modelMatrix1 ); // use Model space b/c of light reflections during rotation, this is tt1

		IwGxSetNormStream( cubeNormals2, orangeTransIndex * 24 );
		IwGxSetVertStream( orangeTransVertices, orangeTransIndex * 24 ); // use Model space b/c of light reflections during rotation
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, orangeTransIndex * 24 );

		

		// draw the static side1
		if( episode >= 3 && episode <= 6  )
		{
			side1Material->SetAlphaMode( CIwMaterial::ALPHA_NONE );		
			nullMaterial->SetAlphaMode(  CIwMaterial::ALPHA_NONE );
		}
		else
		{
			side1Material->SetAlphaMode( alphaValue_side );
			nullMaterial->SetAlphaMode(  alphaValue_side );
		}
		if( plane[0].active == true )
			IwGxSetMaterial( side1Material );
		else
			IwGxSetMaterial( nullMaterial );
		IwGxSetColStream( NULL );
		IwGxSetModelMatrix( &modelMatrix1 ); // uses tt1

		IwGxSetUVStream( planesUVStream );
		IwGxSetNormStream( staticSide1Normals, numStaticSides1Index * 4 );
		IwGxSetVertStream( staticSide1VerticesTranslated, numStaticSides1Index * 4 ); // use Model space b/c of light reflections during rotation
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, numStaticSides1Index * 4 );

		// draw the static side2
		if( episode >= 3 && episode <= 6 )
		{
			side2Material->SetAlphaMode( CIwMaterial::ALPHA_NONE );		
		}
		else
		{
			side2Material->SetAlphaMode( alphaValue_side );
		}
		if( plane[1].active == true )
			IwGxSetMaterial( side2Material );
		else
			IwGxSetMaterial( nullMaterial );
		IwGxSetColStream( NULL );
		IwGxSetModelMatrix( &modelMatrix1 ); // uses tt1

		IwGxSetUVStream( planesUVStream );
		IwGxSetNormStream( staticSide2Normals, numStaticSides2Index * 4 );
		IwGxSetVertStream( staticSide2VerticesTranslated, numStaticSides2Index * 4 ); // use Model space b/c of light reflections during rotation
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, numStaticSides2Index * 4 );

		// draw the static side3
		if( episode >= 3 && episode <= 6 )
		{
			side3Material->SetAlphaMode( CIwMaterial::ALPHA_NONE );		
		}
		else
		{
			side3Material->SetAlphaMode( alphaValue_side );
		}
		if( plane[2].active == true )
			IwGxSetMaterial( side3Material );
		else
			IwGxSetMaterial( nullMaterial );
		IwGxSetColStream( NULL );
		IwGxSetModelMatrix( &modelMatrix1 ); // uses tt1

		IwGxSetUVStream( planesUVStream );
		IwGxSetNormStream( staticSide3Normals, numStaticSides3Index * 4 );
		IwGxSetVertStream( staticSide3VerticesTranslated, numStaticSides3Index * 4 ); // use Model space b/c of light reflections during rotation
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, numStaticSides3Index * 4 );
		
		// draw the static side4
		if( episode >= 3 && episode <= 6 )
		{
			side4Material->SetAlphaMode( CIwMaterial::ALPHA_NONE );		
		}
		else
		{
			side4Material->SetAlphaMode( alphaValue_side );
		}
		if( plane[3].active == true )
			IwGxSetMaterial( side4Material );
		else
			IwGxSetMaterial( nullMaterial );
		IwGxSetColStream( NULL );
		IwGxSetModelMatrix( &modelMatrix1 ); // uses tt1

		IwGxSetUVStream( planesUVStream );
		IwGxSetNormStream( staticSide4Normals, numStaticSides4Index * 4 );
		IwGxSetVertStream( staticSide4VerticesTranslated, numStaticSides4Index * 4 ); // use Model space b/c of light reflections during rotation
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, numStaticSides4Index * 4 );

		// draw the static side5
		if( episode >= 3 && episode <= 6 )
		{
			side5Material->SetAlphaMode( CIwMaterial::ALPHA_NONE );		
		}
		else
		{
			side5Material->SetAlphaMode( alphaValue_side );
		}
		if( plane[4].active == true )
			IwGxSetMaterial( side5Material );
		else
			IwGxSetMaterial( nullMaterial );
		IwGxSetColStream( NULL );
		IwGxSetModelMatrix( &modelMatrix1 ); // uses tt1

		IwGxSetUVStream( planesUVStream );
		IwGxSetNormStream( staticSide5Normals, numStaticSides5Index * 4 );
		IwGxSetVertStream( staticSide5VerticesTranslated, numStaticSides5Index * 4 ); // use Model space b/c of light reflections during rotation
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, numStaticSides5Index * 4 );

		// draw the static side6
		if( episode >= 3 && episode <= 6 )
		{
			side6Material->SetAlphaMode( CIwMaterial::ALPHA_NONE );		
		}
		else
		{
			side6Material->SetAlphaMode( alphaValue_side );
		}
		if( plane[5].active == true )
			IwGxSetMaterial( side6Material );
		else
			IwGxSetMaterial( nullMaterial );
		IwGxSetColStream( NULL );
		IwGxSetModelMatrix( &modelMatrix1 ); // uses tt1

		IwGxSetUVStream( planesUVStream );
		IwGxSetNormStream( staticSide6Normals, numStaticSides6Index * 4 );
		IwGxSetVertStream( staticSide6VerticesTranslated, numStaticSides6Index * 4 ); // use Model space b/c of light reflections during rotation
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, numStaticSides1Index * 4 );


		/* should be obsolete. Should be taken care of in material vertex stream
		// draw the moving cubes
		CIwMaterial* cubeMaterialMoving = IW_GX_ALLOC_MATERIAL();
		cubeMaterialMoving->SetAlphaMode( CIwMaterial::ADD );
		cubeMaterialMoving->SetColAmbient( 127, 5, 0, 255 );
		cubeMaterialMoving->SetColDiffuse( 127, 5, 0, 255 );
		cubeMaterialMoving->SetColSpecular( 127,127,127 );
		cubeMaterialMoving->SetSpecularPower( 15 );
		IwGxSetMaterial( cubeMaterialMoving );
		IwGxSetColStream( NULL ); // col stream overrides material. Take note.
		
		IwGxSetNormStream( cubeMovingNormals2, numMovingCubesIndex * 24 );
		IwGxSetVertStream( cubeMovingTranslated2, numMovingCubesIndex * 24 );
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, numMovingCubesIndex * 24 );
		*/
		

		// draw the shadows
		/*
		CIwMaterial* shadowMaterial = IW_GX_ALLOC_MATERIAL();
		shadowMaterial->SetAlphaMode( CIwMaterial::NONE ); // BLUE
		shadowMaterial->SetColAmbient( 80, 100, 200, 255 );
		shadowMaterial->SetColDiffuse( 80, 100, 200, 255 );
		IwGxSetMaterial( shadowMaterial );
		IwGxSetColStream( NULL ); // col stream overrides material. Take note.

		//IwGxSetNormStream( shadowNormalsFaceSide1, 4 );
		//IwGxSetVertStream( shadowVerticesFaceSide1, 4 );		
		//IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, 4 );
		//IwGxSetNormStream( shadowNormals, numShadowsIndex * 4 );
		//IwGxSetVertStream( shadowVerticesTranslated, numShadowsIndex * 4 );
		//IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, numShadowsIndex * 4 );
		*/


		// BLUE BLINKING
		blueSolidShadowMaterial->SetAlphaMode( alphaValue_shadow ); // BLUE SOLID SHADOW
		blueSolidShadowMaterial->SetColAmbient( blueSolidIntensity + upperLimitAddon, blueSolidIntensity + upperLimitAddon, blueSolidIntensity + upperLimitAddon, 255 );
		blueSolidShadowMaterial->SetColDiffuse( blueSolidIntensity + upperLimitAddon, blueSolidIntensity + upperLimitAddon, blueSolidIntensity + upperLimitAddon, 255 );
		blueSolidShadowMaterial->SetTexture( shadowTextureBlue );
		IwGxSetUVStream( shadowUVStream );

		IwGxSetMaterial( blueSolidShadowMaterial );
		IwGxSetColStream( NULL ); // col stream overrides material. Take note.
		IwGxSetModelMatrix( &modelMatrix1 ); // uses tt1

		IwGxSetNormStream( blueSolidShadowNormals, blueSolidShadowIndex * 24 );
		IwGxSetVertStream( blueSolidShadowVertices, blueSolidShadowIndex * 24 );
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, blueSolidShadowIndex * 24 );

		
		// RED BLINKING
		//CIwMaterial* redSolidShadowMaterial = IW_GX_ALLOC_MATERIAL();
		redSolidShadowMaterial->SetAlphaMode( alphaValue_shadow ); // red SOLID SHADOW
		redSolidShadowMaterial->SetColAmbient( redSolidIntensity + upperLimitAddon, redSolidIntensity + upperLimitAddon, redSolidIntensity + upperLimitAddon, 255 );
		redSolidShadowMaterial->SetColDiffuse( redSolidIntensity + upperLimitAddon, redSolidIntensity + upperLimitAddon, redSolidIntensity + upperLimitAddon, 255 );
		redSolidShadowMaterial->SetTexture( shadowTextureRed );
		IwGxSetUVStream( shadowUVStream );

		IwGxSetMaterial( redSolidShadowMaterial );
		IwGxSetColStream( NULL ); // col stream overrides material. Take note.
		IwGxSetModelMatrix( &modelMatrix1 ); // uses tt1

		IwGxSetNormStream( redSolidShadowNormals, redSolidShadowIndex * 24 );
		IwGxSetVertStream( redSolidShadowVertices, redSolidShadowIndex * 24 );
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, redSolidShadowIndex * 24 );

		
		// GREEN BLINKING
		//CIwMaterial* greenSolidShadowMaterial = IW_GX_ALLOC_MATERIAL();
		greenSolidShadowMaterial->SetAlphaMode( alphaValue_shadow ); // GREEN SOLID SHADOW
		greenSolidShadowMaterial->SetColAmbient( greenSolidIntensity + upperLimitAddon, greenSolidIntensity + upperLimitAddon, greenSolidIntensity + upperLimitAddon, 255 );
		greenSolidShadowMaterial->SetColDiffuse( greenSolidIntensity + upperLimitAddon, greenSolidIntensity + upperLimitAddon, greenSolidIntensity + upperLimitAddon, 255 );
		greenSolidShadowMaterial->SetTexture( shadowTextureGreen );
		IwGxSetUVStream( shadowUVStream );

		IwGxSetMaterial( greenSolidShadowMaterial );
		IwGxSetColStream( NULL ); // col stream overrides material. Take note.
		IwGxSetModelMatrix( &modelMatrix1 ); // uses tt1

		IwGxSetNormStream( greenSolidShadowNormals, greenSolidShadowIndex * 24 );
		IwGxSetVertStream( greenSolidShadowVertices, greenSolidShadowIndex * 24 );
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, greenSolidShadowIndex * 24 );

		
		// PURPLE BLINKING
		//CIwMaterial* purpleSolidShadowMaterial = IW_GX_ALLOC_MATERIAL();
		purpleSolidShadowMaterial->SetAlphaMode( alphaValue_shadow ); // PURPLE SOLID SHADOW
		purpleSolidShadowMaterial->SetColAmbient( purpleSolidIntensity + upperLimitAddon, purpleSolidIntensity + upperLimitAddon, purpleSolidIntensity + upperLimitAddon, 255 );
		purpleSolidShadowMaterial->SetColDiffuse( purpleSolidIntensity + upperLimitAddon, purpleSolidIntensity + upperLimitAddon, purpleSolidIntensity + upperLimitAddon, 255 );
		purpleSolidShadowMaterial->SetTexture( shadowTexturePurple );
		IwGxSetUVStream( shadowUVStream );

		IwGxSetMaterial( purpleSolidShadowMaterial );
		IwGxSetColStream( NULL ); // col stream overrides material. Take note.
		IwGxSetModelMatrix( &modelMatrix1 ); // uses tt1

		IwGxSetNormStream( purpleSolidShadowNormals, purpleSolidShadowIndex * 24 );
		IwGxSetVertStream( purpleSolidShadowVertices, purpleSolidShadowIndex * 24 );
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, purpleSolidShadowIndex * 24 );

		
		// ORANGE BLINKING
	    //CIwMaterial* orangeSolidShadowMaterial = IW_GX_ALLOC_MATERIAL();
		orangeSolidShadowMaterial->SetAlphaMode( alphaValue_shadow ); // ORANGE SOLID SHADOW
		orangeSolidShadowMaterial->SetColAmbient( orangeSolidIntensity + upperLimitAddon, orangeSolidIntensity + upperLimitAddon, orangeSolidIntensity + upperLimitAddon, 255 );
		orangeSolidShadowMaterial->SetColDiffuse( orangeSolidIntensity + upperLimitAddon, orangeSolidIntensity + upperLimitAddon, orangeSolidIntensity + upperLimitAddon, 255 );
		orangeSolidShadowMaterial->SetTexture( shadowTextureOrange );
		IwGxSetUVStream( shadowUVStream );

		IwGxSetMaterial( orangeSolidShadowMaterial );
		IwGxSetColStream( NULL ); // col stream overrides material. Take note.
		IwGxSetModelMatrix( &modelMatrix1 ); // uses tt1

		IwGxSetNormStream( orangeSolidShadowNormals, orangeSolidShadowIndex * 24 );
		IwGxSetVertStream( orangeSolidShadowVertices, orangeSolidShadowIndex * 24 );
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, orangeSolidShadowIndex * 24 );

		
		// YELLOW BLINKING
		//CIwMaterial* yellowSolidShadowMaterial = IW_GX_ALLOC_MATERIAL();
		yellowSolidShadowMaterial->SetAlphaMode( alphaValue_shadow ); // YELLOW SOLID SHADOW
		yellowSolidShadowMaterial->SetColAmbient( yellowSolidIntensity + upperLimitAddon, yellowSolidIntensity + upperLimitAddon, yellowSolidIntensity + upperLimitAddon, 255 );
		yellowSolidShadowMaterial->SetColDiffuse( yellowSolidIntensity + upperLimitAddon, yellowSolidIntensity + upperLimitAddon, yellowSolidIntensity + upperLimitAddon, 255 );
		yellowSolidShadowMaterial->SetTexture( shadowTextureYellow );
		IwGxSetUVStream( shadowUVStream );

		IwGxSetMaterial( yellowSolidShadowMaterial );
		IwGxSetColStream( NULL ); // col stream overrides material. Take note.
		IwGxSetModelMatrix( &modelMatrix1 ); // uses tt1

		IwGxSetNormStream( yellowSolidShadowNormals, yellowSolidShadowIndex * 24 );
		IwGxSetVertStream( yellowSolidShadowVertices, yellowSolidShadowIndex * 24 );
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, yellowSolidShadowIndex * 24 );

		
		// Transparent Shadow Material
		blueTransShadowMaterial->SetAlphaMode( alphaValue_shadowTransparent ); // blue Trans SHADOW
		if( selectedShadow != NULL ) // makes the blinking shadow a different color when touched
		{
			if( selectedShadow->cube->color == Cube::BLUE )
			{
				// if the shadow is touched, it blinks brighter as well as faster
				blueTransShadowMaterial->SetColAmbient( blueSolidIntensity + 50, blueSolidIntensity + 50, blueSolidIntensity + 50, 255 );
				blueTransShadowMaterial->SetColDiffuse( blueSolidIntensity + 50, blueSolidIntensity + 50, blueSolidIntensity + 50, 255 );
			}
			else
			{
				blueTransShadowMaterial->SetColAmbient( blueSolidIntensity - lowerLimit, blueSolidIntensity - lowerLimit, blueSolidIntensity - lowerLimit, 255 );
				blueTransShadowMaterial->SetColDiffuse( blueSolidIntensity - lowerLimit, blueSolidIntensity - lowerLimit, blueSolidIntensity - lowerLimit, 255 );
			}
		}
		else
		{
			blueTransShadowMaterial->SetColAmbient( blueSolidIntensity - lowerLimit, blueSolidIntensity - lowerLimit, blueSolidIntensity - lowerLimit, 255 );
			blueTransShadowMaterial->SetColDiffuse( blueSolidIntensity - lowerLimit, blueSolidIntensity - lowerLimit, blueSolidIntensity - lowerLimit, 255 );
		}
		
		IwGxSetMaterial( blueTransShadowMaterial );
		IwGxSetColStream( NULL ); // col stream overrides material. Take note.
		IwGxSetModelMatrix( &modelMatrix1 ); // uses tt1

		IwGxSetNormStream( blueSolidShadowNormals, blueSolidShadowIndex * 24 );
		IwGxSetVertStream( blueTransShadowVertices, blueSolidShadowIndex * 24 );
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, blueSolidShadowIndex * 24 );

		redTransShadowMaterial->SetAlphaMode( alphaValue_shadowTransparent ); // RED Trans SHADOW
		if( selectedShadow != NULL ) // makes the blinking shadow a different color when touched
		{
			if( selectedShadow->cube->color == Cube::RED )
			{
				// if the shadow is touched, it blinks brighter as well as faster
				redTransShadowMaterial->SetColAmbient( redSolidIntensity + 50, redSolidIntensity + 50, redSolidIntensity + 50, 255 );
				redTransShadowMaterial->SetColDiffuse( redSolidIntensity + 50, redSolidIntensity + 50, redSolidIntensity + 50, 255 );
			}
			else
			{
				redTransShadowMaterial->SetColAmbient( redSolidIntensity - lowerLimit, redSolidIntensity - lowerLimit, redSolidIntensity - lowerLimit, 255 );
				redTransShadowMaterial->SetColDiffuse( redSolidIntensity - lowerLimit, redSolidIntensity - lowerLimit, redSolidIntensity - lowerLimit, 255 );
			}
		}
		else
		{
			redTransShadowMaterial->SetColAmbient( redSolidIntensity - lowerLimit, redSolidIntensity - lowerLimit, redSolidIntensity - lowerLimit, 255 );
			redTransShadowMaterial->SetColDiffuse( redSolidIntensity - lowerLimit, redSolidIntensity - lowerLimit, redSolidIntensity - lowerLimit, 255 );
		}		
		IwGxSetMaterial( redTransShadowMaterial );
		IwGxSetColStream( NULL ); // col stream overrides material. Take note.
		IwGxSetModelMatrix( &modelMatrix1 ); // uses tt1

		IwGxSetNormStream( redSolidShadowNormals, redSolidShadowIndex * 24 );
		IwGxSetVertStream( redTransShadowVertices, redSolidShadowIndex * 24 );
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, redSolidShadowIndex * 24 );

		greenTransShadowMaterial->SetAlphaMode( alphaValue_shadowTransparent ); // green Trans SHADOW
		if( selectedShadow != NULL ) // makes the blinking shadow a different color when touched
		{
			if( selectedShadow->cube->color == Cube::GREEN )
			{
				// if the shadow is touched, it blinks brighter as well as faster
				greenTransShadowMaterial->SetColAmbient( greenSolidIntensity + 50, greenSolidIntensity + 50, greenSolidIntensity + 50, 255 );
				greenTransShadowMaterial->SetColDiffuse( greenSolidIntensity + 50, greenSolidIntensity + 50, greenSolidIntensity + 50, 255 );
			}
			else
			{
				greenTransShadowMaterial->SetColAmbient( greenSolidIntensity - lowerLimit, greenSolidIntensity - lowerLimit, greenSolidIntensity - lowerLimit, 255 );
				greenTransShadowMaterial->SetColDiffuse( greenSolidIntensity - lowerLimit, greenSolidIntensity - lowerLimit, greenSolidIntensity - lowerLimit, 255 );
			}
		}
		else
		{
			greenTransShadowMaterial->SetColAmbient( greenSolidIntensity - lowerLimit, greenSolidIntensity - lowerLimit, greenSolidIntensity - lowerLimit, 255 );
			greenTransShadowMaterial->SetColDiffuse( greenSolidIntensity - lowerLimit, greenSolidIntensity - lowerLimit, greenSolidIntensity - lowerLimit, 255 );
		}		
		IwGxSetMaterial( greenTransShadowMaterial );
		IwGxSetColStream( NULL ); // col stream overrides material. Take note.
		IwGxSetModelMatrix( &modelMatrix1 ); // uses tt1

		IwGxSetNormStream( greenSolidShadowNormals, greenSolidShadowIndex * 24 );
		IwGxSetVertStream( greenTransShadowVertices, greenSolidShadowIndex * 24 );
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, greenSolidShadowIndex * 24 );

		orangeTransShadowMaterial->SetAlphaMode( alphaValue_shadowTransparent ); // orange Trans SHADOW
		if( selectedShadow != NULL ) // makes the blinking shadow a different color when touched
		{
			if( selectedShadow->cube->color == Cube::ORANGE )
			{
				// if the shadow is touched, it blinks brighter as well as faster
				orangeTransShadowMaterial->SetColAmbient( orangeSolidIntensity + 50, orangeSolidIntensity + 50, orangeSolidIntensity + 50, 255 );
				orangeTransShadowMaterial->SetColDiffuse( orangeSolidIntensity + 50, orangeSolidIntensity + 50, orangeSolidIntensity + 50, 255 );
			}
			else
			{
				orangeTransShadowMaterial->SetColAmbient( orangeSolidIntensity - lowerLimit, orangeSolidIntensity - lowerLimit, orangeSolidIntensity - lowerLimit, 255 );
				orangeTransShadowMaterial->SetColDiffuse( orangeSolidIntensity - lowerLimit, orangeSolidIntensity - lowerLimit, orangeSolidIntensity - lowerLimit, 255 );
			}
		}
		else
		{
			orangeTransShadowMaterial->SetColAmbient( orangeSolidIntensity - lowerLimit, orangeSolidIntensity - lowerLimit, orangeSolidIntensity - lowerLimit, 255 );
			orangeTransShadowMaterial->SetColDiffuse( orangeSolidIntensity - lowerLimit, orangeSolidIntensity - lowerLimit, orangeSolidIntensity - lowerLimit, 255 );
		}	
		IwGxSetMaterial( orangeTransShadowMaterial );
		IwGxSetColStream( NULL ); // col stream overrides material. Take note.
		IwGxSetModelMatrix( &modelMatrix1 ); // uses tt1

		IwGxSetNormStream( orangeSolidShadowNormals, orangeSolidShadowIndex * 24 );
		IwGxSetVertStream( orangeTransShadowVertices, orangeSolidShadowIndex * 24 );
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, orangeSolidShadowIndex * 24 );

		yellowTransShadowMaterial->SetAlphaMode( alphaValue_shadowTransparent ); // yellow Trans SHADOW
		if( selectedShadow != NULL ) // makes the blinking shadow a different color when touched
		{
			if( selectedShadow->cube->color == Cube::YELLOW )
			{
				// if the shadow is touched, it blinks brighter as well as faster
				yellowTransShadowMaterial->SetColAmbient( yellowSolidIntensity + 50, yellowSolidIntensity + 50, yellowSolidIntensity + 50, 255 );
				yellowTransShadowMaterial->SetColDiffuse( yellowSolidIntensity + 50, yellowSolidIntensity + 50, yellowSolidIntensity + 50, 255 );
			}
			else
			{
				yellowTransShadowMaterial->SetColAmbient( yellowSolidIntensity - lowerLimit, yellowSolidIntensity - lowerLimit, yellowSolidIntensity - lowerLimit, 255 );
				yellowTransShadowMaterial->SetColDiffuse( yellowSolidIntensity - lowerLimit, yellowSolidIntensity - lowerLimit, yellowSolidIntensity - lowerLimit, 255 );
			}
		}
		else
		{
			yellowTransShadowMaterial->SetColAmbient( yellowSolidIntensity - lowerLimit, yellowSolidIntensity - lowerLimit, yellowSolidIntensity - lowerLimit, 255 );
			yellowTransShadowMaterial->SetColDiffuse( yellowSolidIntensity - lowerLimit, yellowSolidIntensity - lowerLimit, yellowSolidIntensity - lowerLimit, 255 );
		}
		IwGxSetMaterial( yellowTransShadowMaterial );
		IwGxSetColStream( NULL ); // col stream overrides material. Take note.
		IwGxSetModelMatrix( &modelMatrix1 ); // uses tt1

		IwGxSetNormStream( yellowSolidShadowNormals, yellowSolidShadowIndex * 24 );
		IwGxSetVertStream( yellowTransShadowVertices, yellowSolidShadowIndex * 24 );
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, yellowSolidShadowIndex * 24 );

		purpleTransShadowMaterial->SetAlphaMode( alphaValue_shadowTransparent ); // purple Trans SHADOW
		if( selectedShadow != NULL ) // makes the blinking shadow a different color when touched
		{
			if( selectedShadow->cube->color == Cube::PURPLE )
			{
				// if the shadow is touched, it blinks brighter as well as faster
				purpleTransShadowMaterial->SetColAmbient( purpleSolidIntensity + 50, purpleSolidIntensity + 50, purpleSolidIntensity + 50, 255 );
				purpleTransShadowMaterial->SetColDiffuse( purpleSolidIntensity + 50, purpleSolidIntensity + 50, purpleSolidIntensity + 50, 255 );
			}
			else
			{
				purpleTransShadowMaterial->SetColAmbient( purpleSolidIntensity - lowerLimit, purpleSolidIntensity - lowerLimit, purpleSolidIntensity - lowerLimit, 255 );
				purpleTransShadowMaterial->SetColDiffuse( purpleSolidIntensity - lowerLimit, purpleSolidIntensity - lowerLimit, purpleSolidIntensity - lowerLimit, 255 );
			}
		}
		else
		{
			purpleTransShadowMaterial->SetColAmbient( purpleSolidIntensity - lowerLimit, purpleSolidIntensity - lowerLimit, purpleSolidIntensity - lowerLimit, 255 );
			purpleTransShadowMaterial->SetColDiffuse( purpleSolidIntensity - lowerLimit, purpleSolidIntensity - lowerLimit, purpleSolidIntensity - lowerLimit, 255 );
		}
		IwGxSetMaterial( purpleTransShadowMaterial );
		IwGxSetColStream( NULL ); // col stream overrides material. Take note.
		IwGxSetModelMatrix( &modelMatrix1 ); // uses tt1

		IwGxSetNormStream( purpleSolidShadowNormals, purpleSolidShadowIndex * 24 );
		IwGxSetVertStream( purpleTransShadowVertices, purpleSolidShadowIndex * 24 );
		IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, purpleSolidShadowIndex * 24 );
		

		// warping material
		for( int i = 0; i < 6; i++ )
		{
			if( warpingMaterialIndex[i] != 0 ) // if the warping material stream is not empty, render it
			{
				warpingMaterial[i]->SetAlphaMode( alphaValue_warpingMaterial );
				warpingMaterial[i]->SetColAmbient( warpingMaterialIntensity[i], warpingMaterialIntensity[i], warpingMaterialIntensity[i], 255 );
				warpingMaterial[i]->SetColDiffuse( warpingMaterialIntensity[i], warpingMaterialIntensity[i], warpingMaterialIntensity[i], 255 );
				//warpingMaterial[i]->SetColAmbient( 50, 60, 70, 255 );
				//warpingMaterial[i]->SetColDiffuse( 50, 60, 70, 255 );
				warpingMaterial[i]->SetTexture( warpingTextureGolden );
				IwGxSetUVStream( warpingMaterialUVStream[i] );

				IwGxSetMaterial( warpingMaterial[i] );
				IwGxSetColStream( NULL ); // col stream overrides material. Take note.
				IwGxSetModelMatrix( &modelMatrix1 ); // uses tt1

				IwGxSetNormStream( cubeNormals2, warpingMaterialIndex[i] * 24 );
				IwGxSetVertStream( warpingMaterialVertexStream[i], warpingMaterialIndex[i] * 24 );
				IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, warpingMaterialIndex[i] * 24 );
			}
		}

		// exploding material
		for( int i = 0; i < 6; i++ )
		{
			if( explodingMaterialIndex[i] != 0 ) // if the exploding material stream is not empty, render it
			{
				explodingMaterial[i]->SetAlphaMode( alphaValue_explodingMaterial );
				explodingMaterial[i]->SetColAmbient( explodingMaterialIntensity[i], explodingMaterialIntensity[i], explodingMaterialIntensity[i], 255 );
				explodingMaterial[i]->SetColDiffuse( explodingMaterialIntensity[i], explodingMaterialIntensity[i], explodingMaterialIntensity[i], 255 );
				//explodingMaterial[i]->SetColAmbient( 50, 60, 70, 255 );
				//explodingMaterial[i]->SetColDiffuse( 50, 60, 70, 255 );
				explodingMaterial[i]->SetTexture( explodingTextureRed );
				IwGxSetUVStream( explodingMaterialUVStream[i] );

				IwGxSetMaterial( explodingMaterial[i] );
				IwGxSetColStream( NULL ); // col stream overrides material. Take note.
				IwGxSetModelMatrix( &modelMatrix1 ); // uses tt1

				IwGxSetNormStream( cubeNormals2, explodingMaterialIndex[i] * 24 );
				IwGxSetVertStream( explodingMaterialVertexStream[i], explodingMaterialIndex[i] * 24 );
				IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, explodingMaterialIndex[i] * 24 );
			}
		}

		// RENDER FUZZIES and BOMBS from static array
		for( int i = numOriginalCubes; i < numStaticCubes; i++ )
		{
			// if the cube has a bomb
			if( cubeArray[i].hasBomb == true )
			{
				// if the cube is exploding and is cooling down / glowing down, render explosion
				if( cubeArray[i].exploding == true &&  explodingUp[ cubeArray[i].direction -1 ] == false )
				{
					cubeArray[i].bomb.Render();
				}
				else if( cubeArray[i].exploded == false ) // any other time, render the fuzzy if there is a fuzzy in it
				{
					cubeArray[i].bomb.Render();
				}
			}
			// if cube has a fuzzy
			else if( cubeArray[i].hasFuzzy == true )
			{
				if( cubeArray[i].fuzzyExplodeMaterial->IsAnim() == true )
				{
					if( cubeArray[i].fuzzyExplodeMaterial->GetAnimCelID() >= cubeArray[i].fuzzyExplodeMaterial->GetAnimCelNum()-1 )
					{
						cubeArray[i].fuzzyExplodeMaterial->PauseAnim();
						// do not render fuzzy if reached end of animation
					}
					else
					{
						IwGxSetMaterial( cubeArray[i].fuzzyExplodeMaterial );
						IwGxSetColStream( NULL );
						IwGxSetUVStream( fuzzyUVExplodeStream );
						IwGxSetNormStream( fuzzyNormals, 4 );

						CIwSVec3 viewSpaceLocation = (CIwSVec3)IwGxGetWorldViewMatrix().TransformVec( modelMatrix1.TransformVec( cubeArray[i].position ));
						IwGxSetViewSpaceOrg(&viewSpaceLocation);
						IwGxSetVertStreamViewSpace( fuzzyVertices, 4 );

						IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, 4 );
					}
				}
				else if( cubeArray[i].exploded == false ) // any other time, render the fuzzy if there is a fuzzy in it
				{
					if( cubeArray[i].fuzzyMaterial != NULL )
					{
						IwGxSetMaterial( cubeArray[i].fuzzyMaterial );
						//CIwColour c = { 255, 255, 255, 255 };
						IwGxSetColStream( NULL );
						IwGxSetUVStream( fuzzyUVStream );
						IwGxSetNormStream( fuzzyNormals, 4 );

						CIwSVec3 viewSpaceLocation = (CIwSVec3)IwGxGetWorldViewMatrix().TransformVec( modelMatrix1.TransformVec( cubeArray[i].position ));
						IwGxSetViewSpaceOrg(&viewSpaceLocation);
						IwGxSetVertStreamViewSpace( fuzzyVertices, 4 );

						IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, 4 );
					}
				}
			}
			
		}

		// RENDER FUZZIES from Moving array
		for( int i = 0; i < numMovingCubesIndex; i++ )
		{
			if( cubeArrayMoving[i].hasBomb == true )
			{
				cubeArrayMoving[i].bomb.Render();
			}
			// if cube has a fuzzy
			else if( cubeArrayMoving[i].hasFuzzy == true )
			{
				IwGxSetMaterial( cubeArrayMoving[i].fuzzyMaterial );
				IwGxSetColStream( NULL );
				IwGxSetUVStream( fuzzyUVStream );
				IwGxSetNormStream( fuzzyNormals, 4 );

				CIwSVec3 viewSpaceLocation = (CIwSVec3)IwGxGetWorldViewMatrix().TransformVec( modelMatrix1.TransformVec( cubeArrayMoving[i].position ));
				IwGxSetViewSpaceOrg(&viewSpaceLocation);
				IwGxSetVertStreamViewSpace( fuzzyVertices, 4 );

				IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, 4 );
			}
		}
		
		// render stars for story mode
		if( episode == 1 )
		{
			IwGxSetMaterial( starMaterial[0] );
		}
		else if( episode == 2 )
		{
			IwGxSetMaterial( starMaterial[1] );
		}
		else if( episode == 6 )
		{
			IwGxSetMaterial( starMaterial[0] );
		}

		IwGxSetColStream( NULL ); // col stream overrides material. Take note.
		IwGxSetModelMatrix( &tt1 ); // uses tt1
		IwGxSetColStream( NULL );
		IwGxSetUVStream( starsUVStream );
		IwGxSetNormStream( starsNormalStream, numStars * 4 );

		CIwSVec3 viewSpaceLocation = (CIwSVec3)IwGxGetWorldViewMatrix().TransformVec( tt1.TransformVec( CIwSVec3(0, 0, 0) ));
		//CIwSVec3 viewSpaceLocation = (CIwSVec3)tt1.TransformVec( CIwSVec3(0, 0, 0) );
		//CIwSVec3 viewSpaceLocation = (CIwSVec3)IwGxGetModelMatrix().TransformVec( modelMatrix1.TransformVec( CIwSVec3(0, 0, 0) ));
		IwGxSetViewSpaceOrg(&viewSpaceLocation);
		IwGxSetVertStreamViewSpace( starsVertexStream, numStars * 4 );

		if( episode == 1 || episode == 2 || episode == 6 )
		{
			IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, numStars * 4 );
		}

		// render stars for episode 4
		// RED stars
		if( episode == 4 || episode == 5 )
		{
			if( episode == 4 )
			{
				IwGxSetMaterial( starMaterial[2] );
			}
			else if( episode == 5 )
			{
				IwGxSetMaterial( starMaterial[6] );
			}
		
			IwGxSetColStream( NULL ); // col stream overrides material. Take note.
			IwGxSetModelMatrix( &tt1 ); // uses tt1
			IwGxSetColStream( NULL );
			IwGxSetUVStream( starsEp4UVStream );
			IwGxSetNormStream( starsNormalStream, numStars/4 * 4 );

			if( episode == 4 )
			{
				viewSpaceLocation = (CIwSVec3)IwGxGetWorldViewMatrix().TransformVec( (rumbleMatrix*tt1).TransformVec( CIwSVec3(0, 0, 0) ));
			}
			else if( episode == 5 )
			{
				viewSpaceLocation = (CIwSVec3)IwGxGetWorldViewMatrix().TransformVec( (tt1).TransformVec( CIwSVec3(0, 0, 0) ));
			}

			IwGxSetViewSpaceOrg(&viewSpaceLocation);
			IwGxSetVertStreamViewSpace( starsEp4VertexStream1, numStars/4 * 4 );	
			IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, numStars/4 * 4 );
		

			// GREEN Stars
			if( episode == 4 )
			{
				IwGxSetMaterial( starMaterial[3] );
			}
			else if( episode == 5 )
			{
				IwGxSetMaterial( starMaterial[6] );
			}
		
			IwGxSetColStream( NULL ); // col stream overrides material. Take note.
			IwGxSetModelMatrix( &tt1 ); // uses tt1
			IwGxSetColStream( NULL );
			IwGxSetUVStream( starsEp4UVStream );
			IwGxSetNormStream( starsNormalStream, numStars/4 * 4 );

			if( episode == 4 )
			{
				viewSpaceLocation = (CIwSVec3)IwGxGetWorldViewMatrix().TransformVec( (rumbleMatrix*tt1).TransformVec( CIwSVec3(0, 0, 0) ));
			}
			else if( episode == 5 )
			{
				viewSpaceLocation = (CIwSVec3)IwGxGetWorldViewMatrix().TransformVec( (tt1).TransformVec( CIwSVec3(0, 0, 0) ));
			}

			IwGxSetViewSpaceOrg(&viewSpaceLocation);
			IwGxSetVertStreamViewSpace( starsEp4VertexStream2, numStars/4 * 4 );
			IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, numStars/4 * 4 );

			// BLUE Stars
			if( episode == 4 )
			{
				IwGxSetMaterial( starMaterial[4] );
			}
			else if( episode == 5 )
			{
				IwGxSetMaterial( starMaterial[6] );
			}

			IwGxSetColStream( NULL ); // col stream overrides material. Take note.
			IwGxSetModelMatrix( &tt1 ); // uses tt1
			IwGxSetColStream( NULL );
			IwGxSetUVStream( starsEp4UVStream );
			IwGxSetNormStream( starsNormalStream, numStars/4 * 4 );

			if( episode == 4 )
			{
				viewSpaceLocation = (CIwSVec3)IwGxGetWorldViewMatrix().TransformVec( (rumbleMatrix*tt1).TransformVec( CIwSVec3(0, 0, 0) ));
			}
			else if( episode == 5 )
			{
				viewSpaceLocation = (CIwSVec3)IwGxGetWorldViewMatrix().TransformVec( (tt1).TransformVec( CIwSVec3(0, 0, 0) ));
			}

			IwGxSetViewSpaceOrg(&viewSpaceLocation);
			IwGxSetVertStreamViewSpace( starsEp4VertexStream3, numStars/4 * 4 );
			IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, numStars/4 * 4 );


			// YELLOW stars
			if( episode == 4 )
			{
				IwGxSetMaterial( starMaterial[5] );
			}
			else if( episode == 5 )
			{
				IwGxSetMaterial( starMaterial[6] );
			}

			IwGxSetColStream( NULL ); // col stream overrides material. Take note.
			IwGxSetModelMatrix( &tt1 ); // uses tt1
			IwGxSetColStream( NULL );
			IwGxSetUVStream( starsEp4UVStream );
			IwGxSetNormStream( starsNormalStream, numStars/4 * 4 );

			if( episode == 4 )
			{
				viewSpaceLocation = (CIwSVec3)IwGxGetWorldViewMatrix().TransformVec( (rumbleMatrix*tt1).TransformVec( CIwSVec3(0, 0, 0) ));
			}
			else if( episode == 5 )
			{
				viewSpaceLocation = (CIwSVec3)IwGxGetWorldViewMatrix().TransformVec( (tt1).TransformVec( CIwSVec3(0, 0, 0) ));
			}
			
			IwGxSetViewSpaceOrg(&viewSpaceLocation);
			IwGxSetVertStreamViewSpace( starsEp4VertexStream4, numStars/4 * 4 );
			IwGxDrawPrims( IW_GX_QUAD_LIST, NULL, numStars/4 * 4 );
		}

		// render tutorial message bubbles
		if( episode == 1 )
		{
			for( int i = 0; i < NUM_OF_TUTORIAL_MESSAGES; i++ )
			{
				// position condition is for sprite not rendering before it's been set
				if( showTutorialSprites[i] == true && (tutorialSprites[i].position.x != 0 && tutorialSprites[i].position.y != 0 ) )
				{
					tutorialSprites[i].Render();
				}
			}
		}

		// Render score screen
		// Render At Score Screen elements
		if( GameState == AT_SCORE_SCREEN )
		{
			// show score
			scoreScreenSprite.Render();
			IwGxFlush();

			restartButton.Render();
			if( storyMode == true && advanceToNextLevel == true )
			{
				nextButton.Render();
			}
			quitButton.Render();

			if( showScore == true )
			{
				showAndPlayScore();
			}

			if( showFuzziness == true )
			{
				showAndPlayFuzziness();
			}

			if( showSkillTitle == true )
			{
				showAndPlaySkillTitle();
			}

			for( int j = 0; j < 3; j++ )
			{
				if( showPixieDust[j] == true )
				{
					pixieSprite[j].Render();

					if( pixieSprite[j].loopCount == 1 )
					{
						showPixieDust[j] = false;
						pixieSprite[j].resetAndPlayAnimation();
					}
				}
			}

			if( showGameOver == true )
			{
				gameOverSprite.Render();
			}

			// Render Quit Confirmation Screen if enabled
			if( enableQuitConfirmationScreen == true )
			{
				quitConfirmationScreen.Render();
			}
		}

		// render lives text
		IwGxFlush();
		IwGxFontSetCol(0xffccffff);
		//IwGxFontSetRect( CIwRect( IwGxGetScreenWidth() - 50, 0 + 30, 100, 100 ) );
		IwGxFontSetRect( CIwRect( IwGxGetScreenWidth() - width*.104, 0 + height*.094, width, height ) );
		CIwGxFontPreparedData livesData;
	
		// int16 testNumber = 80;
		char lives[100] = "x ";
		//strcat( str, " Today is a good day.");	
	
		std::ostringstream sout2; // creating an output string stream
		sout2 << numOfLives;				// sending an integer into string stream
		string livesString = sout2.str();// retrieving the string from the string stream

		strcat( lives, livesString.c_str() ); // converting the string to cstring

		// draw the shadow
		IwGxFontSetCol(0xff990033); // setting it's abgr
		IwGxFontPrepareText( livesData, lives);
		IwGxFontDrawText( livesData );

		//Draw the text
		IwGxFontSetCol(0xffccffff);
		//IwGxFontSetRect( CIwRect( IwGxGetScreenWidth() - 50 -1, 30 -2, 100, 100 ) );
		IwGxFontSetRect( CIwRect( IwGxGetScreenWidth() - width*.104 - width*.002, height*.094 - height*.006, width, height ) );
		IwGxFontPrepareText( livesData, lives);
		IwGxFontDrawText( livesData );


		// render SCORE
			//Set font colour to grey
		//IwGxFontSetCol(0xff808080);
		IwGxFontSetCol(0xffccffff); // yellow, when setting it's abgr

		//Set the formatting rect - this controls where the text appears and what it is formatted against
		//IwGxFontSetRect( CIwRect( 10, 0, (int16)IwGxGetScreenWidth()-10, (int16)IwGxGetScreenHeight()-50) );
		IwGxFontSetRect( CIwRect( width*.021, 0, (int16)IwGxGetScreenWidth(), (int16)IwGxGetScreenHeight()) );

		CIwGxFontPreparedData data;
	
		// int16 testNumber = 80;
		char str[100] = "";
		//strcat( str, " Today is a good day.");	
	
		// STRINGS
		//std::cout << "hi";
		//std::string a("hello");
		//strcpy( str, a.c_str() );

		std::ostringstream sout; // creating an output string stream
		sout << score;	 
				
			//<< " D:" << difficulty
			//<< "\n C:" << comfortIndexCurrent
			//<< "\n U: " << upperFlowBound
			//<< "\n L: " << lowerFlowBound 
					// sending an integer into string stream
		string scoreString = sout.str();// retrieving the string from the string stream
		strcat( str, scoreString.c_str() ); // converting the string to cstring

		// draw shadow
		IwGxFontSetCol(0xff990033); // setting it's abgr
		IwGxFontPrepareText( data, str);
		IwGxFontDrawText( data );

		//Draw the text
		IwGxFontSetCol(0xffccffff); // yellow, when setting it's abgr
		//IwGxFontSetRect( CIwRect( 10 -1, 0 -2, (int16)IwGxGetScreenWidth()-10, (int16)IwGxGetScreenHeight()-50) );
		IwGxFontSetRect( CIwRect( width*.021 - width*.002, 0 - height*.006, (int16)IwGxGetScreenWidth(), (int16)IwGxGetScreenHeight()) );
		IwGxFontPrepareText( data, str);
		IwGxFontDrawText( data );

		// Render Paused Screen elements
		if( GameState == PAUSED )
		{
			pausedBackgroundSprite.Render();
			IwGxFlush();

			IwGxFontSetCol(0xffccffff);
			IwGxFontSetRect( CIwRect( 0 + 20, 0 + 200, 480, 200 ) );
			CIwGxFontPreparedData statisticsData;
	
			// int16 testNumber = 80;
			char statisticsChar[100] = "";
			//strcat( str, " Today is a good day.");	
	
			std::ostringstream sout2; // creating an output string stream
			/*
			sout2 << "    e:" << efficiencyIndexCurrent
				<< "    c:" << comfortIndexCurrent
				<< "    p:" << performanceIndexCurrent
				<< "\n    s:" << skillIndex
				<< "    a:" << uAPMCurrent
				<< "    d:" << difficulty;
				*/

			//sout2 << "   s: " << skillIndex
			//sout2	<< "   Fuzziness: " << (int16)(skillIndexRatio * 100);
			//sout2	<< "   Fuzziness: " << (int16)(efficiencyIndex * 100);

				
				
				// sending an integer into string stream
			string statisticsString = sout2.str();// retrieving the string from the string stream

			strcat( statisticsChar, statisticsString.c_str() ); // converting the string to cstring
			//Draw the text
			IwGxFontPrepareText( statisticsData, statisticsChar);
			IwGxFontDrawText( statisticsData );

			/*
			CIwTexture* t;
			t = new CIwTexture;
			t->LoadFromFile( "cubeTextureBlue.png");
			CIw2DImage* i;
			i = Iw2DCreateImage(t->GetImage());
			Iw2DDrawImage( i, CIwSVec2(0,0) );
			*/

			restartButton.Render();
			resumeButton.Render();
			quitButton.Render();
			
			// Render Quit Confirmation Screen if enabled
			if( enableQuitConfirmationScreen == true )
			{
				quitConfirmationScreen.Render();
			}
			
			//testButton.Render();			

				
			// Draw the statistics on paused screen. Hide for now.
			//IwGxFontDrawText( statisticsData );
		}

		if( showCongratsSpriteComplete == true )
		{
			congratsSpriteComplete.Render();

			if( congratsSpriteComplete.loopCount == 1 )
			{
				showCongratsSpriteComplete = false;
				congratsSpriteComplete.resetAndPlayAnimation();
			}
		}
		
		if( hasIAd == true )
		{
			if( showingIAd == false ) // only show iAd if it wasn't already showing
			{
				if( s3eIOSIAdGetInt( S3E_IOSIAD_RUNNING ) == 1 &&  s3eIOSIAdGetInt( S3E_IOSIAD_BANNER_LOADED ) == 1 )
				{
					s3eIOSIAdSetInt( S3E_IOSIAD_BANNER_SHOW, 1 );

					// iad messes up the screen, so resetting orientation fixes it.
					//IwGxSetScreenOrient( IW_GX_ORIENT_NONE );

					showingIAd = true;
				}
				else
				{
					s3eIOSIAdSetInt( S3E_IOSIAD_BANNER_SHOW, 0 );
					showingIAd = false;
				}
			}
			else if( showingIAd == true ) // if an ad was showing but no loaded ad...
			{
				if( s3eIOSIAdGetInt( S3E_IOSIAD_BANNER_LOADED ) == 0 )
				{
					s3eIOSIAdSetInt( S3E_IOSIAD_BANNER_SHOW, 0 );
					showingIAd = false;
				}
			}
		}

	} // end of rendering gamestate = play_game	
	/*
	else if( GameState == SHOW_UI )
	{
		//Render the UI
		IwGetUIView()->Render();
	}
	*/

	// render the tutorial pics above menu
	if( GameState == PLAY_TUTORIAL )
	{
		// Render the Left and Right buttons
		CIwColour fullColor = {255, 255, 255, 255};
		Iw2DSetColour( fullColor );
		IwGxSetNormStream( NULL );

		// Render the Congrats Sprites
		if( showCongratsSpriteNice == true && showCongratsSpriteComplete == false )
		{
			congratsSpriteNice.Render();

			// check if the sprite finished rendering, then reset its type
			if( congratsSpriteNice.loopCount >= congratsSpriteNice.repeatCount )
			{
				showCongratsSpriteNice = false;
				congratsSpriteNice.resetAndPlayAnimation();
			}
		}
		else if( showCongratsSpriteComplete == true )
		{
			showCongratsSpriteNice = false;
			congratsSpriteNice.resetAndPlayAnimation();
		}

		if( showCongratsSpriteComplete == true )
		{
			congratsSpriteComplete.Render(); // reset in arrowButton release functions
		}

		

		// Render the Right Button HIGHLIGHT Sprite
		if( tutorialRightButtonHighlightEnabled == true )
		{
			tutorialRightButtonHighlightSprite.Render();
		}

		tutorialLeftButton.Render();
		tutorialRightButton.Render();

		// Render the description for tutorial pages
		CIwGxFontPreparedData preparedDataTutorialNum;
		char cstringTutorialNum[10] = "";
		string stringTutorialNum = "";

		if( tutorialNumber == 1 ) // TOUCH AND DRAG
		{
			stringTutorialNum = "1/7";
		}
		else if( tutorialNumber == 2 ) // TAP TO DROP
		{
			stringTutorialNum = "2/7";
		}
		else if( tutorialNumber == 3 ) // ROTATE CUBE
		{
			stringTutorialNum = "3/7";
		}
		else if( tutorialNumber == 4 ) // COMPLETE SIDE
		{
			stringTutorialNum = "4/7";
		}
		else if( tutorialNumber == 5 ) // ROTATE CAMERA / LOOK AROUND
		{
			stringTutorialNum = "5/7";
		}
		else if( tutorialNumber == 6 ) // FLIP CUBE
		{
			stringTutorialNum = "6/7";
		}
		else if( tutorialNumber == 7 ) // COMPLETE A SIDE AGAIN WITH FLIPPING
		{
			stringTutorialNum = "7/7";
		}

		strcat( cstringTutorialNum, stringTutorialNum.c_str() ); // converting the string to cstring

		//Draw the text
		IwGxFontSetCol(0xffccffff);
		IwGxFontSetRect( CIwRect( 110, IwGxGetScreenHeight() - 80, 200, 100 ) );
		IwGxFontPrepareText( preparedDataTutorialNum, cstringTutorialNum);
		IwGxFontDrawText( preparedDataTutorialNum );

		if( tutorialNumber == 1 ) // TOUCH AND DRAG
		{
			tutorialTouchDragSprite.Render();

			// Display INSTRUCTIONS
			CIwGxFontPreparedData preparedDataTouchDrag;
			CIwGxFontPreparedData preparedDataTouchDragNum;

			char cstringTouchDrag[100] = "";
			char cstringTouchDragNum[5] = "1.";

			string stringTouchDrag;

			if( tutorialTouchDragPassed == false )
			{
				stringTouchDrag = "1. Touch and Drag: \nTouch and drag the Blinking Marker to \nmove it.";// retrieving the string from the string stream
			}
			else
			{
				stringTouchDrag = "1. Touch and Drag: \nCompleted!";// retrieving the string from the string stream
			}

			strcat( cstringTouchDrag, stringTouchDrag.c_str() ); // converting the string to cstring

			//Draw the text
			IwGxFontSetCol(0xffccffff);
			IwGxFontSetRect( CIwRect( 20, 10, 180, 100 ) );
			IwGxFontPrepareText( preparedDataTouchDrag, cstringTouchDrag);
			IwGxFontDrawText( preparedDataTouchDrag );

			// draw the Num matching sprite
			IwGxFontSetCol(0xffccffff);
			IwGxFontSetRect( CIwRect( IwGxGetScreenWidth() - 150, 0, 200, 100 ) );
			IwGxFontPrepareText( preparedDataTouchDragNum, cstringTouchDragNum );
			IwGxFontDrawText( preparedDataTouchDragNum );
		}
		else if( tutorialNumber == 2 ) // ROTATE CUBE
		{
			tutorialRotateCubeSprite.Render();

			CIwGxFontPreparedData preparedDataRotateCube;
			CIwGxFontPreparedData preparedDataRotateCubeNum;

			char cstringRotateCube[100] = "";
			char cstringRotateCubeNum[5] = "2.";

			string stringRotateCube;
			
			if( tutorialRotateCubePassed == false )
			{
				stringRotateCube = "2. Rotate the Cube: \nPress the \nRotate button \nto rotate the \ncubes.";// retrieving the string from the string stream
			}
			else
			{
				stringRotateCube = "2. Rotate the Cube: \nCompleted!";// retrieving the string from the string stream
			}

			strcat( cstringRotateCube, stringRotateCube.c_str() ); // converting the string to cstring

			//Draw the text
			IwGxFontSetCol(0xffccffff);
			IwGxFontSetRect( CIwRect( 20, 10, 220, 100 ) );
			IwGxFontPrepareText( preparedDataRotateCube, cstringRotateCube);
			IwGxFontDrawText( preparedDataRotateCube );

			// draw the Num matching sprite
			IwGxFontSetCol(0xffccffff);
			IwGxFontSetRect( CIwRect( IwGxGetScreenWidth() - 150, 0, 200, 100 ) );
			IwGxFontPrepareText( preparedDataRotateCubeNum, cstringRotateCubeNum );
			IwGxFontDrawText( preparedDataRotateCubeNum );
		}
		else if( tutorialNumber == 3 ) // TAP TO DROP
		{
			tutorialTapDropSprite.Render();

			CIwGxFontPreparedData preparedDataTapDrop;
			CIwGxFontPreparedData preparedDataTapDropNum;

			char cstringTapDrop[100] = "";
			char cstringTapDropNum[5] = "3.";
			
			string stringTapDrop;

			if( tutorialTapDropPassed == false )
			{
				stringTapDrop = "3. Drop the Cubes: \nQuickly tap the Blinking Marker \nto drop the \ncubes.";// retrieving the string from the string stream
			}
			else
			{
				stringTapDrop = "3. Drop the Cubes: \nCompleted!";// retrieving the string from the string stream
			}

			strcat( cstringTapDrop, stringTapDrop.c_str() ); // converting the string to cstring

			//Draw the text
			IwGxFontSetCol(0xffccffff);
			IwGxFontSetRect( CIwRect( 20, 10, 180, 100 ) );
			IwGxFontPrepareText( preparedDataTapDrop, cstringTapDrop);
			IwGxFontDrawText( preparedDataTapDrop );

			// draw the Num matching sprite
			IwGxFontSetCol(0xffccffff);
			IwGxFontSetRect( CIwRect( IwGxGetScreenWidth() - 150, 0, 200, 100 ) );
			IwGxFontPrepareText( preparedDataTapDropNum, cstringTapDropNum );
			IwGxFontDrawText( preparedDataTapDropNum );
		}
		else if( tutorialNumber == 4 ) // COMPLETE A SIDE
		{
			tutorialCompleteSideSprite.Render();

			CIwGxFontPreparedData preparedDataCompleteSide;
			CIwGxFontPreparedData preparedDataCompleteSideNum;

			char cstringCompleteSide[100] = "";
			char cstringCompleteSideNum[5] = "4.";
			
			string stringCompleteSide;

			if( tutorialCompleteSidePassed == false )
			{
				stringCompleteSide = "4. Complete the Side: \nMove and Drop the cubes to \nfill the \nbottom layer \nof the Blue \nsurface. ";// retrieving the string from the string stream
			}
			else
			{
				stringCompleteSide = "4. Complete the Side: \nCompleted!";// retrieving the string from the string stream
			}

			strcat( cstringCompleteSide, stringCompleteSide.c_str() ); // converting the string to cstring

			//Draw the text
			IwGxFontSetCol(0xffccffff);
			IwGxFontSetRect( CIwRect( 20, 10, 220, 100 ) );
			IwGxFontPrepareText( preparedDataCompleteSide, cstringCompleteSide);
			IwGxFontDrawText( preparedDataCompleteSide );

			// draw the Num matching sprite
			IwGxFontSetCol(0xffccffff);
			IwGxFontSetRect( CIwRect( IwGxGetScreenWidth() - 150, 0, 200, 100 ) );
			IwGxFontPrepareText( preparedDataCompleteSideNum, cstringCompleteSideNum );
			IwGxFontDrawText( preparedDataCompleteSideNum );
		}
		else if( tutorialNumber == 5 ) // ROTATE CAMERA
		{
			tutorialRotateCameraSprite.Render();

			CIwGxFontPreparedData preparedDataRotateCamera;
			CIwGxFontPreparedData preparedDataRotateCameraNum;

			char cstringRotateCamera[100] = "";
			char cstringRotateCameraNum[5] = "5.";

			string stringRotateCamera;
			
			if( tutorialRotateCameraPassed == false )
			{
				stringRotateCamera = "5. Look around in 3D Space: \nTouch and \nDrag outside \nof the Big \nCube to look \naround.";// retrieving the string from the string stream
			}
			else
			{
				stringRotateCamera = "5. Look around in 3D Space: \nCompleted!";// retrieving the string from the string stream
			}

			strcat( cstringRotateCamera, stringRotateCamera.c_str() ); // converting the string to cstring

			//Draw the text
			IwGxFontSetCol(0xffccffff);
			IwGxFontSetRect( CIwRect( 20, 10, 270, 100 ) );
			IwGxFontPrepareText( preparedDataRotateCamera, cstringRotateCamera);
			IwGxFontDrawText( preparedDataRotateCamera );

			// draw the Num matching sprite
			IwGxFontSetCol(0xffccffff);
			IwGxFontSetRect( CIwRect( IwGxGetScreenWidth() - 150, 0, 200, 100 ) );
			IwGxFontPrepareText( preparedDataRotateCameraNum, cstringRotateCameraNum );
			IwGxFontDrawText( preparedDataRotateCameraNum );
		}
		else if( tutorialNumber == 6 ) // FLIP A CUBE
		{
			tutorialFlipCubeSprite.Render();

			CIwGxFontPreparedData preparedDataFlipCube;
			CIwGxFontPreparedData preparedDataFlipCubeNum;

			char cstringFlipCube[200] = "";
			char cstringFlipCubeNum[5] = "6.";

			string stringFlipCube;
			
			if( tutorialFlipCubePassed == false )
			{
				stringFlipCube = "6. Moving to Another Surface: \nUse the \n Red Buttons \n    to move \ncubes to the \nblue side.";// retrieving the string from the string stream
			}
			else
			{
				stringFlipCube = "6. Moving to Another Surface: \nCompleted!";// retrieving the string from the string stream
			}

			strcat( cstringFlipCube, stringFlipCube.c_str() ); // converting the string to cstring

			//Draw the text
			IwGxFontSetCol(0xffccffff);
			IwGxFontSetRect( CIwRect( 20, 0, 200, 100 ) );
			IwGxFontPrepareText( preparedDataFlipCube, cstringFlipCube);
			IwGxFontDrawText( preparedDataFlipCube );

			// draw the Num matching sprite
			IwGxFontSetCol(0xffccffff);
			IwGxFontSetRect( CIwRect( IwGxGetScreenWidth() - 150, 0, 200, 100 ) );
			IwGxFontPrepareText( preparedDataFlipCubeNum, cstringFlipCubeNum );
			IwGxFontDrawText( preparedDataFlipCubeNum );
		}
		else if( tutorialNumber == 7 ) // COMPLETE A SIDE WITH FLIPPING
		{
			
			CIwGxFontPreparedData preparedDataCompleteSideRandomSpawn;
			CIwGxFontPreparedData preparedDataCompleteSideRandomSpawnNum;

			char cstringCompleteSideRandomSpawn[200] = "";
			//char cstringCompleteSideRandomSpawnNum[5] = "6.";

			string stringCompleteSideRandomSpawn;
			
			if( tutorialCompleteSide2Passed == false )
			{
				stringCompleteSideRandomSpawn = "7. Complete the Side:       Move the Blue cubes to Blue side. Then drop them to fill the Blue surface!";// retrieving the string from the string stream
			}
			else
			{
				stringCompleteSideRandomSpawn = "7. Complete the Side: \nCompleted!";// retrieving the string from the string stream
			}

			strcat( cstringCompleteSideRandomSpawn, stringCompleteSideRandomSpawn.c_str() ); // converting the string to cstring

			//Draw the text
			IwGxFontSetCol(0xffccffff);
			IwGxFontSetRect( CIwRect( 7, 10, 460, 200 ) );
			IwGxFontPrepareText( preparedDataCompleteSideRandomSpawn, cstringCompleteSideRandomSpawn);
			IwGxFontDrawText( preparedDataCompleteSideRandomSpawn );
			

			// draw the Num matching sprite // do not need a Sprite here yet. No need for Number matching sprite
			//IwGxFontSetCol(0xffccffff);
			//IwGxFontSetRect( CIwRect( IwGxGetScreenWidth() - 150, 0, 200, 100 ) );
			//IwGxFontPrepareText( preparedDataCompleteSideRandomSpawnNum, cstringCompleteSideRandomSpawnNum );
			//IwGxFontDrawText( preparedDataCompleteSideRandomSpawnNum );
		}
	} // end of rendering at play_game
	
	// render menu screens on top

	// render new story confirmation
	if( enableNewStoryConfirmationScreen == true )
	{
		newStoryConfirmationScreen.Render();
	}
	
	if( GameState == AT_CHALLENGE_MENU_SCREEN || GameState == AT_MENU )
	{
		menuScreen[0].Render();
	}
	if( GameState == AT_HIGH_SCORE_MENU_SCREEN || GameState == AT_MENU )
	{
		menuScreen[1].Render();	
		IwGxFlush();
		
		if( showTrophyMessage == true )
		{
			trophyMessageBackgroundSprite.Render();
			IwGxFlush();

			
			// Create the text descriptions for obtaining trophies
			IwGxFontSetCol(0xffccffff); // yellow, when setting it's abgr
			//Set the formatting rect - this controls where the text appears and what it is formatted against
			//IwGxFontSetRect( CIwRect(0, IwGxGetScreenHeight()/2 - 50, IwGxGetScreenWidth(), IwGxGetScreenHeight()) );
			IwGxFontSetRect( CIwRect(0, IwGxGetScreenHeight()/2 - height*.156, IwGxGetScreenWidth(), IwGxGetScreenHeight()) );
			CIwGxFontPreparedData trophyData;
		
			// trophyCString located in release high score buttons

			//Draw the text - just for testing. replaced with images!
			//IwGxFontPrepareText( trophyData, trophyCString);
			//IwGxFontDrawText( trophyData );

			// render trophy message sprite
			// show trophy message sprite
			if( showTrophyMessage == true )
			{
				trophyMessageSprite.Render();
			}
			// the image of the sprite is set in release of trophy buttons
		}
	}
	if( GameState == AT_CREDITS_MENU_SCREEN || GameState == AT_MENU )
	{
		menuScreen[2].Render();
	}
	if( GameState == AT_TUTORIAL_MENU_SCREEN || GameState == AT_MENU )
	{
		menuScreen[3].Render();
	}

	// render transition
	if( renderTransition == true )
	{
		transitionObject.Render();
		renderTransition = false;
	}


	// CAMERA
	// sets the viewing matrix for the camera
	IwGxSetViewMatrix(&view);

	// for iw2d
	// Iw2DSurfaceShow();

	// End drawing
	IwGxFlush();

	// Swap buffers
	IwGxSwapBuffers();	

	/* UGH not working...
	if( autosnap == false && getActiveFaceSide() == 5 && rotateEnabled == false )
	{
		CorrectAutoSnap();
	}
	*/
	

} // end of render


void ShutDown()
{
	//delete IwGetUIController();
    //delete IwGetUIView();

	// Deletes current static and moving cubes
	Reset();

	if( levelDataLoaded == true )
	{
		TerminateLevelData();
	}

	if( menuDataTerminated == false )
	{
		TerminateMenuData();
	}
				
	delete sideBlueMaterial;
	delete sideRedMaterial;
	delete sideGreenMaterial;
	delete sideOrangeMaterial;
	delete sidePurpleMaterial;
	delete sideYellowMaterial;

	delete side1Material;
	delete side2Material;
	delete side3Material;
	delete side4Material;
	delete side5Material;
	delete side6Material;
	delete nullMaterial;

	delete side1TempMaterial;
	delete side2TempMaterial;
	delete side3TempMaterial;
	delete side4TempMaterial;
	delete side5TempMaterial;
	delete side6TempMaterial;

	delete blueSolidMaterial;
	delete greenSolidMaterial;
	delete redSolidMaterial;
	delete orangeSolidMaterial;
	delete yellowSolidMaterial;
	delete purpleSolidMaterial;

	delete blueTransMaterial;
	delete greenTransMaterial;
	delete redTransMaterial;
	delete orangeTransMaterial;
	delete yellowTransMaterial;
	delete purpleTransMaterial;

	delete blueSolidShadowMaterial;
	delete redSolidShadowMaterial;
	delete greenSolidShadowMaterial;
	delete yellowSolidShadowMaterial;
	delete purpleSolidShadowMaterial;
	delete orangeSolidShadowMaterial;

	delete blueTransShadowMaterial;
	delete redTransShadowMaterial;
	delete greenTransShadowMaterial;
	delete yellowTransShadowMaterial;
	delete purpleTransShadowMaterial;
	delete orangeTransShadowMaterial;

	
	for( int i = 0; i< NUM_STAR_TEXTURES; i++ )
	{
		delete starTexture[i]; 
		delete starMaterial[i];
	}

	
	for( int i = 0; i < numStars; i++ )
	{
		stars[i].Terminate();
	}
	for( int i = 0; i < numStars; i++ )
	{
		stars.pop_back();
	}

	for( int i = 0; i < 6; i++ )
	{
		if( sphereLoaded[i] == true )
		{
			TerminateEpisode( i+1 );
			sphereLoaded[i] = false;
		}
	}
	//delete redCube;

	//IwGetResManager()->DestroyGroup(menuDataGroup);
	
	// empty remaining arrays of cubes and fuzzy material and textures
	// call Reset() to do this
	Reset();

	IwGxTerminate();
	Iw2DTerminate();
	IwGraphicsTerminate();

	IwGxFontTerminate();
	//IwResManagerTerminate();
} // end of shutdown



// The MAIN function
int main()
{
	// initialize the application.
	Init();
	
	// this is the standard loop for all applications
	while (1)
	{
		s3eDeviceYield(0); // this is like SLEEP. sets the Framerate
		s3eKeyboardUpdate(); // updates keyboard, or something.
		//s3ePointerUpdate();

		bool result = true;
		
		RenderTime = RenderTime1;
		RenderTime1 = s3eTimerGetMs() / 33;
		if( RenderTime1 - RenderTime == 1 )
		{
			result = Update(); // this is just weird way of updating, using a boolean

			if (
				(result == false) ||
				(s3eKeyboardGetState(s3eKeyEsc) & S3E_KEY_STATE_DOWN)
				||
				(s3eKeyboardGetState(s3eKeyLSK) & S3E_KEY_STATE_DOWN)
				||
				(s3eDeviceCheckQuitRequest())
				)
			break; // this exits the program if ESC button is pressed for device
	
			//if( (RenderTime1 - RenderTime) == 1 ) // locks the FPS
			Render(); // this updates the actual rendering of the polygon/model
		}
	}

	ShutDown(); // terminates all allocated memory and stuff when exiting

}

// Constructors for the header file
// Not necessary
FuzzyCubes::FuzzyCubes(void)
{
}
FuzzyCubes::~FuzzyCubes(void)
{
}

// spawns One setType of cubes
void SpawnMovingCubes(int16 faceSide, int16 cubeSetType, int16 startingHeight)
{
	// this is center position. 
	// so if the width is even, the "center" is on the left unit of middle
	CIwSVec3 position(0, 0, 0);
	if( numCubesWidth % 2 == 1 ) // if the number of static rubix cubes is ODD, center this way
	{
		// if ODD, do nothing. Cube already centered
		position.x = 0;
		position.y = 0;
		position.z = 0;
	}
	if( numCubesWidth % 2 == 0 ) // if the number of static rubix cubes is EVEN, center this way
	{
		// if EVEN, set to upper-back-left cube as center
		position.x = -s/2;
		position.y = -s/2;
		position.z = s/2;
	}

	int16 direction = faceSide;
	int16 sideLength = s;
	int16 distanceToLanding = 0; // needs to be calculated
	int16 speed = 0;
	int16 acceleration = 0;
	int16 material = Cube::SOLID_RED;
	IwRandSeed( (int32)s3eTimerGetMs() );
	int16 color = Cube::RED;
	int16 numOfConnectedColorRequired = 10;
	int16 activeSide = Cube::NONE; // active side is in reference to static rubix, the surface it is headed towards.
	bool isLanded = false;

	Cube cube1(s);
	Cube cube2(s);
	Cube cube3(s);
	Cube cube4(s);

	//Cube cube1( position, direction, sideLength, distanceToLanding, speed, acceleration, material, color, numOfConnectedColorRequired, activeSide, isLanded );
	//Cube cube2( position, direction, sideLength, distanceToLanding, speed, acceleration, material, color, numOfConnectedColorRequired, activeSide, isLanded );
	//Cube cube3( position, direction, sideLength, distanceToLanding, speed, acceleration, material, color, numOfConnectedColorRequired, activeSide, isLanded );
	//Cube cube4( position, direction, sideLength, distanceToLanding, speed, acceleration, material, color, numOfConnectedColorRequired, activeSide, isLanded );

	if( cubeSetType == SINGLE )
	{		
		// inputting faceside is 1-6
		switch( faceSide )
		{
		case 1:
			activeSide = Cube::NEG_Z;
			position.z += -1*startingHeight;
			break;
		case 2:
			activeSide = Cube::POS_X;
			position.x += startingHeight;
			break;
		case 3:
			activeSide = Cube::POS_Z;
			position.z += startingHeight;
			break;
		case 4:
			activeSide = Cube::NEG_X;
			position.x += -1*startingHeight;
			break;
		case 5:
			activeSide = Cube::NEG_Y;
			position.y += -1*startingHeight;
			break;
		case 6:
			activeSide = Cube::POS_Y;
			position.y += startingHeight;
			break;
		default:
			break;
		}

		// initialize the cube belonging to the set
		cube1.position = position; 
		cube1.initialPosition = position;
		cube1.direction = direction;
		cube1.sideLength = sideLength;
		cube1.distanceToLanding = distanceToLanding;
		cube1.speed = speed;
		cube1.acceleration = acceleration;
		cube1.material = material;
		cube1.color = color;
		cube1.numOfConnectedColorRequired = numOfConnectedColorRequired;
		cube1.activeSide = activeSide;
		cube1.isLanded = isLanded;
		// reset position
		if( numCubesWidth % 2 == 1 ) // if the number of static rubix cubes is ODD, center this way
		{
			// if ODD, do nothing. Cube already centered
		}
		if( numCubesWidth % 2 == 0 ) // if the number of static rubix cubes is EVEN, center this way
		{
			// if EVEN, set to upper-back-left cube as center
			position.x = -s/2;
			position.y = -s/2;
			position.z = s/2;
		}

		// add to array
		cubeArrayMoving[numMovingCubesIndex] = cube1;
		numMovingCubesIndex++;

		
		

		// Link to array of translated vertices for Moving Cubes
		// The setting of vertices needs to happen starting in a saved location in the array
		// The saved location is numMovingCubesIndex, but need to go back steps after it was incremented
		// after adding the cube(s), to place in correct array location
		for( int i = (numMovingCubesIndex - 1); i < numMovingCubesIndex; i++ ) // should only loop One time for each cube
		{
			for( int j = 0; j < 24; j++ )
			{
				cubeMovingTranslated2[i*24 + j].x = cubeMovingVertices2[i*24 + j].x + cube1.position.x;
				cubeMovingTranslated2[i*24 + j].y = cubeMovingVertices2[i*24 + j].y + cube1.position.y;
				cubeMovingTranslated2[i*24 + j].z = cubeMovingVertices2[i*24 + j].z + cube1.position.z;
			}
		}
	}
	else if( cubeSetType == DOUBLE )
	{
		// inputting faceside is 1-6
		switch( faceSide ) // for Cube 1
		{
		case 1:
			activeSide = Cube::NEG_Z;
			position.z += -1*startingHeight;
			break;
		case 2:
			activeSide = Cube::POS_X;
			position.x += startingHeight;
			break;
		case 3:
			activeSide = Cube::POS_Z;
			position.z += startingHeight;
			break;
		case 4:
			activeSide = Cube::NEG_X;
			position.x += -1*startingHeight;
			break;
		case 5:
			activeSide = Cube::NEG_Y;
			position.y += -1*startingHeight;
			break;
		case 6:
			activeSide = Cube::POS_Y;
			position.y += startingHeight;
			break;
		default:
			break;
		}

		// initialize the cube belonging to the set
		cube1.position = position;
		cube1.initialPosition = position;
		cube1.direction = direction;
		cube1.sideLength = sideLength;
		cube1.distanceToLanding = distanceToLanding;
		cube1.speed = speed;
		cube1.acceleration = acceleration;
		cube1.material = material;
		cube1.color = color;
		cube1.numOfConnectedColorRequired = numOfConnectedColorRequired;
		cube1.activeSide = activeSide;
		cube1.isLanded = isLanded;

		// reset position
		if( numCubesWidth % 2 == 1 ) // if the number of static rubix cubes is ODD, center this way
		{
			// if ODD, do nothing. Cube already centered
			position.x = 0;
			position.y = 0;
			position.z = 0;
		}
		if( numCubesWidth % 2 == 0 ) // if the number of static rubix cubes is EVEN, center this way
		{
			// if EVEN, set to upper-back-left cube as center
			position.x = -s/2;
			position.y = -s/2;
			position.z = s/2;
		}

		// add to array
		cubeArrayMoving[numMovingCubesIndex] = cube1;
		numMovingCubesIndex++;

		
		

		// Link to array of translated vertices for Moving Cubes
		// The setting of vertices needs to happen starting in a saved location in the array
		// The saved location is numMovingCubesIndex, but need to go back steps after it was incremented
		// after adding the cube(s), to place in correct array location
		for( int i = (numMovingCubesIndex - 1); i < numMovingCubesIndex; i++ ) // should only loop One time for each cube
		{
			for( int j = 0; j < 24; j++ )
			{
				cubeMovingTranslated2[i*24 + j].x = cubeMovingVertices2[i*24 + j].x + cube1.position.x;
				cubeMovingTranslated2[i*24 + j].y = cubeMovingVertices2[i*24 + j].y + cube1.position.y;
				cubeMovingTranslated2[i*24 + j].z = cubeMovingVertices2[i*24 + j].z + cube1.position.z;
			}
		}

		// inputting faceside is 1-6
		switch( faceSide ) // for Cube 2
		{
		case 1:
			activeSide = Cube::NEG_Z;
			position.z += -1*startingHeight;
			position.x += sideLength;
			break;
		case 2:
			activeSide = Cube::POS_X;
			position.x += startingHeight;
			position.z += sideLength;
			break;
		case 3:
			activeSide = Cube::POS_Z;
			position.z += startingHeight;
			position.x += -1*sideLength;
			break;
		case 4:
			activeSide = Cube::NEG_X;
			position.x += -1*startingHeight;
			position.z += -1*sideLength;
			break;
		case 5:
			activeSide = Cube::NEG_Y;
			position.y += -1*startingHeight;
			position.x += sideLength;
			break;
		case 6:
			activeSide = Cube::POS_Y;
			position.y += startingHeight;
			position.x += sideLength; // keep mirror of x for side 6 because in case of 2x2x2 scenario. want blocks to stay hovered
			break;
		default:
			break;
		}

		// initialize the cube belonging to the set
		cube2.position = position; 
		cube2.initialPosition = position;
		cube2.direction = direction;
		cube2.sideLength = sideLength;
		cube2.distanceToLanding = distanceToLanding;
		cube2.speed = speed;
		cube2.acceleration = acceleration;
		cube2.material = material;
		cube2.color = color;
		cube2.numOfConnectedColorRequired = numOfConnectedColorRequired;
		cube2.activeSide = activeSide;
		cube2.isLanded = isLanded;

		// reset position
		if( numCubesWidth % 2 == 1 ) // if the number of static rubix cubes is ODD, center this way
		{
			// if ODD, do nothing. Cube already centered
			position.x = 0;
			position.y = 0;
			position.z = 0;
		}
		if( numCubesWidth % 2 == 0 ) // if the number of static rubix cubes is EVEN, center this way
		{
			// if EVEN, set to upper-back-left cube as center
			position.x = -s/2;
			position.y = -s/2;
			position.z = s/2;
		}

		// add to array
		cubeArrayMoving[numMovingCubesIndex] = cube2;
		numMovingCubesIndex++;
		

		// Link to array of translated vertices for Moving Cubes
		// The setting of vertices needs to happen starting in a saved location in the array
		// The saved location is numMovingCubesIndex, but need to go back steps after it was incremented
		// after adding the cube(s), to place in correct array location
		for( int i = (numMovingCubesIndex - 1); i < numMovingCubesIndex; i++ ) // should only loop One time for each cube
		{
			for( int j = 0; j < 24; j++ )
			{
				cubeMovingTranslated2[i*24 + j].x = cubeMovingVertices2[i*24 + j].x + cube2.position.x;
				cubeMovingTranslated2[i*24 + j].y = cubeMovingVertices2[i*24 + j].y + cube2.position.y;
				cubeMovingTranslated2[i*24 + j].z = cubeMovingVertices2[i*24 + j].z + cube2.position.z;
			}
		}
	}
	else if( cubeSetType == TRIPLE_CORNER )
	{
		// inputting faceside is 1-6
		switch( faceSide ) // for Cube 1
		{
		case 1:
			activeSide = Cube::NEG_Z;
			position.z += -1*startingHeight;
			break;
		case 2:
			activeSide = Cube::POS_X;
			position.x += startingHeight;
			break;
		case 3:
			activeSide = Cube::POS_Z;
			position.z += startingHeight;
			break;
		case 4:
			activeSide = Cube::NEG_X;
			position.x += -1*startingHeight;
			break;
		case 5:
			activeSide = Cube::NEG_Y;
			position.y += -1*startingHeight;
			break;
		case 6:
			activeSide = Cube::POS_Y;
			position.y += startingHeight;
			break;
		default:
			break;
		}

		// initialize the cube belonging to the set
		cube1.position = position; 
		cube1.initialPosition = position;
		cube1.direction = direction;
		cube1.sideLength = sideLength;
		cube1.distanceToLanding = distanceToLanding;
		cube1.speed = speed;
		cube1.acceleration = acceleration;
		cube1.material = material;
		cube1.color = color;
		cube1.numOfConnectedColorRequired = numOfConnectedColorRequired;
		cube1.activeSide = activeSide;
		cube1.isLanded = isLanded;

		// reset position
		if( numCubesWidth % 2 == 1 ) // if the number of static rubix cubes is ODD, center this way
		{
			// if ODD, do nothing. Cube already centered
			position.x = 0;
			position.y = 0;
			position.z = 0;
		}
		if( numCubesWidth % 2 == 0 ) // if the number of static rubix cubes is EVEN, center this way
		{
			// if EVEN, set to upper-back-left cube as center
			position.x = -s/2;
			position.y = -s/2;
			position.z = s/2;
		}

		// add to array
		cubeArrayMoving[numMovingCubesIndex] = cube1;
		numMovingCubesIndex++;

		
		

		// Link to array of translated vertices for Moving Cubes
		// The setting of vertices needs to happen starting in a saved location in the array
		// The saved location is numMovingCubesIndex, but need to go back steps after it was incremented
		// after adding the cube(s), to place in correct array location
		for( int i = (numMovingCubesIndex - 1); i < numMovingCubesIndex; i++ ) // should only loop One time for each cube
		{
			for( int j = 0; j < 24; j++ )
			{
				cubeMovingTranslated2[i*24 + j].x = cubeMovingVertices2[i*24 + j].x + cube1.position.x;
				cubeMovingTranslated2[i*24 + j].y = cubeMovingVertices2[i*24 + j].y + cube1.position.y;
				cubeMovingTranslated2[i*24 + j].z = cubeMovingVertices2[i*24 + j].z + cube1.position.z;
			}
		}

		// inputting faceside is 1-6
		switch( faceSide ) // for Cube 2
		{
		case 1:
			activeSide = Cube::NEG_Z;
			position.z += -1*startingHeight;
			position.x += sideLength;
			break;
		case 2:
			activeSide = Cube::POS_X;
			position.x += startingHeight;
			position.z += sideLength;
			break;
		case 3:
			activeSide = Cube::POS_Z;
			position.z += startingHeight;
			position.x += -1*sideLength;
			break;
		case 4:
			activeSide = Cube::NEG_X;
			position.x += -1*startingHeight;
			position.z += -1*sideLength;
			break;
		case 5:
			activeSide = Cube::NEG_Y;
			position.y += -1*startingHeight;
			position.x += sideLength;
			break;
		case 6:
			activeSide = Cube::POS_Y;
			position.y += startingHeight;
			position.x += sideLength; // keep mirror of x for side 6 because in case of 2x2x2 scenario. want blocks to stay hovered
			break;
		default:
			break;
		}

		// initialize the cube belonging to the set
		cube2.position = position; 
		cube2.initialPosition = position;
		cube2.direction = direction;
		cube2.sideLength = sideLength;
		cube2.distanceToLanding = distanceToLanding;
		cube2.speed = speed;
		cube2.acceleration = acceleration;
		cube2.material = material;
		cube2.color = color;
		cube2.numOfConnectedColorRequired = numOfConnectedColorRequired;
		cube2.activeSide = activeSide;
		cube2.isLanded = isLanded;

		// reset position
		if( numCubesWidth % 2 == 1 ) // if the number of static rubix cubes is ODD, center this way
		{
			// if ODD, do nothing. Cube already centered
			position.x = 0;
			position.y = 0;
			position.z = 0;
		}
		if( numCubesWidth % 2 == 0 ) // if the number of static rubix cubes is EVEN, center this way
		{
			// if EVEN, set to upper-back-left cube as center
			position.x = -s/2;
			position.y = -s/2;
			position.z = s/2;
		}

		// add to array
		cubeArrayMoving[numMovingCubesIndex] = cube2;
		numMovingCubesIndex++;

		
		

		// Link to array of translated vertices for Moving Cubes
		// The setting of vertices needs to happen starting in a saved location in the array
		// The saved location is numMovingCubesIndex, but need to go back steps after it was incremented
		// after adding the cube(s), to place in correct array location
		for( int i = (numMovingCubesIndex - 1); i < numMovingCubesIndex; i++ ) // should only loop One time for each cube
		{
			for( int j = 0; j < 24; j++ )
			{
				cubeMovingTranslated2[i*24 + j].x = cubeMovingVertices2[i*24 + j].x + cube2.position.x;
				cubeMovingTranslated2[i*24 + j].y = cubeMovingVertices2[i*24 + j].y + cube2.position.y;
				cubeMovingTranslated2[i*24 + j].z = cubeMovingVertices2[i*24 + j].z + cube2.position.z;
			}
		}

		// inputting faceside is 1-6
		switch( faceSide ) // for Cube 3
		{
		case 1:
			activeSide = Cube::NEG_Z;
			position.z += -1*startingHeight;
			position.y += -1*sideLength;
			break;
		case 2:
			activeSide = Cube::POS_X;
			position.x += startingHeight;
			position.y += -1*sideLength;
			break;
		case 3:
			activeSide = Cube::POS_Z;
			position.z += startingHeight;
			position.y += -1*sideLength;
			break;
		case 4:
			activeSide = Cube::NEG_X;
			position.x += -1*startingHeight;
			position.y += -1*sideLength;
			break;
		case 5:
			activeSide = Cube::NEG_Y;
			position.y += -1*startingHeight;
			position.z += sideLength;
			break;
		case 6:
			activeSide = Cube::POS_Y;
			position.y += startingHeight;
			position.z += -sideLength;
			break;
		default:
			break;
		}

		// initialize the cube belonging to the set
		cube3.position = position; 
		cube3.initialPosition = position;
		cube3.direction = direction;
		cube3.sideLength = sideLength;
		cube3.distanceToLanding = distanceToLanding;
		cube3.speed = speed;
		cube3.acceleration = acceleration;
		cube3.material = material;
		cube3.color = color;
		cube3.numOfConnectedColorRequired = numOfConnectedColorRequired;
		cube3.activeSide = activeSide;
		cube3.isLanded = isLanded;

		// reset position
		if( numCubesWidth % 2 == 1 ) // if the number of static rubix cubes is ODD, center this way
		{
			// if ODD, do nothing. Cube already centered
			position.x = 0;
			position.y = 0;
			position.z = 0;
		}
		if( numCubesWidth % 2 == 0 ) // if the number of static rubix cubes is EVEN, center this way
		{
			// if EVEN, set to upper-back-left cube as center
			position.x = -s/2;
			position.y = -s/2;
			position.z = s/2;
		}

		// add to array
		cubeArrayMoving[numMovingCubesIndex] = cube3;
		numMovingCubesIndex++;

		
		

		// Link to array of translated vertices for Moving Cubes
		// The setting of vertices needs to happen starting in a saved location in the array
		// The saved location is numMovingCubesIndex, but need to go back steps after it was incremented
		// after adding the cube(s), to place in correct array location
		for( int i = (numMovingCubesIndex - 1); i < numMovingCubesIndex; i++ ) // should only loop One time for each cube
		{
			for( int j = 0; j < 24; j++ )
			{
				cubeMovingTranslated2[i*24 + j].x = cubeMovingVertices2[i*24 + j].x + cube3.position.x;
				cubeMovingTranslated2[i*24 + j].y = cubeMovingVertices2[i*24 + j].y + cube3.position.y;
				cubeMovingTranslated2[i*24 + j].z = cubeMovingVertices2[i*24 + j].z + cube3.position.z;
			}
		}

	}
	else if( cubeSetType == TRIPLE_LINE )
	{
		// inputting faceside is 1-6
		switch( faceSide ) // for Cube 1
		{
		case 1:
			activeSide = Cube::NEG_Z;
			position.z += -1*startingHeight;
			break;
		case 2:
			activeSide = Cube::POS_X;
			position.x += startingHeight;
			break;
		case 3:
			activeSide = Cube::POS_Z;
			position.z += startingHeight;
			break;
		case 4:
			activeSide = Cube::NEG_X;
			position.x += -1*startingHeight;
			break;
		case 5:
			activeSide = Cube::NEG_Y;
			position.y += -1*startingHeight;
			break;
		case 6:
			activeSide = Cube::POS_Y;
			position.y += startingHeight;
			break;
		default:
			break;
		}

		// initialize the cube belonging to the set
		cube1.position = position; 
		cube1.initialPosition = position;
		cube1.direction = direction;
		cube1.sideLength = sideLength;
		cube1.distanceToLanding = distanceToLanding;
		cube1.speed = speed;
		cube1.acceleration = acceleration;
		cube1.material = material;
		cube1.color = color;
		cube1.numOfConnectedColorRequired = numOfConnectedColorRequired;
		cube1.activeSide = activeSide;
		cube1.isLanded = isLanded;

		// reset position
		if( numCubesWidth % 2 == 1 ) // if the number of static rubix cubes is ODD, center this way
		{
			// if ODD, do nothing. Cube already centered
			position.x = 0;
			position.y = 0;
			position.z = 0;
		}
		if( numCubesWidth % 2 == 0 ) // if the number of static rubix cubes is EVEN, center this way
		{
			// if EVEN, set to upper-back-left cube as center
			position.x = -s/2;
			position.y = -s/2;
			position.z = s/2;
		}

		// add to array
		cubeArrayMoving[numMovingCubesIndex] = cube1;
		numMovingCubesIndex++;

		
		

		// Link to array of translated vertices for Moving Cubes
		// The setting of vertices needs to happen starting in a saved location in the array
		// The saved location is numMovingCubesIndex, but need to go back steps after it was incremented
		// after adding the cube(s), to place in correct array location
		for( int i = (numMovingCubesIndex - 1); i < numMovingCubesIndex; i++ ) // should only loop One time for each cube
		{
			for( int j = 0; j < 24; j++ )
			{
				cubeMovingTranslated2[i*24 + j].x = cubeMovingVertices2[i*24 + j].x + cube1.position.x;
				cubeMovingTranslated2[i*24 + j].y = cubeMovingVertices2[i*24 + j].y + cube1.position.y;
				cubeMovingTranslated2[i*24 + j].z = cubeMovingVertices2[i*24 + j].z + cube1.position.z;
			}
		}

		// inputting faceside is 1-6
		switch( faceSide ) // for Cube 2
		{
		case 1:
			activeSide = Cube::NEG_Z;
			position.z += -1*startingHeight;
			position.x += sideLength;
			break;
		case 2:
			activeSide = Cube::POS_X;
			position.x += startingHeight;
			position.z += sideLength;
			break;
		case 3:
			activeSide = Cube::POS_Z;
			position.z += startingHeight;
			position.x += -1*sideLength;
			break;
		case 4:
			activeSide = Cube::NEG_X;
			position.x += -1*startingHeight;
			position.z += -1*sideLength;
			break;
		case 5:
			activeSide = Cube::NEG_Y;
			position.y += -1*startingHeight;
			position.x += sideLength;
			break;
		case 6:
			activeSide = Cube::POS_Y;
			position.y += startingHeight;
			position.x += sideLength; // keep mirror of x for side 6 because in case of 2x2x2 scenario. want blocks to stay hovered
			break;
		default:
			break;
		}

		// initialize the cube belonging to the set
		cube2.position = position; 
		cube2.initialPosition = position;
		cube2.direction = direction;
		cube2.sideLength = sideLength;
		cube2.distanceToLanding = distanceToLanding;
		cube2.speed = speed;
		cube2.acceleration = acceleration;
		cube2.material = material;
		cube2.color = color;
		cube2.numOfConnectedColorRequired = numOfConnectedColorRequired;
		cube2.activeSide = activeSide;
		cube2.isLanded = isLanded;

		// reset position
		if( numCubesWidth % 2 == 1 ) // if the number of static rubix cubes is ODD, center this way
		{
			// if ODD, do nothing. Cube already centered
			position.x = 0;
			position.y = 0;
			position.z = 0;
		}
		if( numCubesWidth % 2 == 0 ) // if the number of static rubix cubes is EVEN, center this way
		{
			// if EVEN, set to upper-back-left cube as center
			position.x = -s/2;
			position.y = -s/2;
			position.z = s/2;
		}

		// add to array
		cubeArrayMoving[numMovingCubesIndex] = cube2;
		numMovingCubesIndex++;

		
		

		// Link to array of translated vertices for Moving Cubes
		// The setting of vertices needs to happen starting in a saved location in the array
		// The saved location is numMovingCubesIndex, but need to go back steps after it was incremented
		// after adding the cube(s), to place in correct array location
		for( int i = (numMovingCubesIndex - 1); i < numMovingCubesIndex; i++ ) // should only loop One time for each cube
		{
			for( int j = 0; j < 24; j++ )
			{
				cubeMovingTranslated2[i*24 + j].x = cubeMovingVertices2[i*24 + j].x + cube2.position.x;
				cubeMovingTranslated2[i*24 + j].y = cubeMovingVertices2[i*24 + j].y + cube2.position.y;
				cubeMovingTranslated2[i*24 + j].z = cubeMovingVertices2[i*24 + j].z + cube2.position.z;
			}
		}

		// inputting faceside is 1-6
		switch( faceSide ) // for Cube 3
		{
		case 1:
			activeSide = Cube::NEG_Z;
			position.z += -1*startingHeight;
			position.x += -1*sideLength;
			break;
		case 2:
			activeSide = Cube::POS_X;
			position.x += startingHeight;
			position.z += -1*sideLength;
			break;
		case 3:
			activeSide = Cube::POS_Z;
			position.z += startingHeight;
			position.x += sideLength;
			break;
		case 4:
			activeSide = Cube::NEG_X;
			position.x += -1*startingHeight;
			position.z += sideLength;
			break;
		case 5:
			activeSide = Cube::NEG_Y;
			position.y += -1*startingHeight;
			position.x += -1*sideLength;
			break;
		case 6:
			activeSide = Cube::POS_Y;
			position.y += startingHeight;
			position.x += -1*sideLength;
			break;
		default:
			break;
		}

		// initialize the cube belonging to the set
		cube3.position = position; 
		cube3.initialPosition = position;
		cube3.direction = direction;
		cube3.sideLength = sideLength;
		cube3.distanceToLanding = distanceToLanding;
		cube3.speed = speed;
		cube3.acceleration = acceleration;
		cube3.material = material;
		cube3.color = color;
		cube3.numOfConnectedColorRequired = numOfConnectedColorRequired;
		cube3.activeSide = activeSide;
		cube3.isLanded = isLanded;

		// reset position
		if( numCubesWidth % 2 == 1 ) // if the number of static rubix cubes is ODD, center this way
		{
			// if ODD, do nothing. Cube already centered
			position.x = 0;
			position.y = 0;
			position.z = 0;
		}
		if( numCubesWidth % 2 == 0 ) // if the number of static rubix cubes is EVEN, center this way
		{
			// if EVEN, set to upper-back-left cube as center
			position.x = -s/2;
			position.y = -s/2;
			position.z = s/2;
		}

		// add to array
		cubeArrayMoving[numMovingCubesIndex] = cube3;
		numMovingCubesIndex++;

		
		

		// Link to array of translated vertices for Moving Cubes
		// The setting of vertices needs to happen starting in a saved location in the array
		// The saved location is numMovingCubesIndex, but need to go back steps after it was incremented
		// after adding the cube(s), to place in correct array location
		for( int i = (numMovingCubesIndex - 1); i < numMovingCubesIndex; i++ ) // should only loop One time for each cube
		{
			for( int j = 0; j < 24; j++ )
			{
				cubeMovingTranslated2[i*24 + j].x = cubeMovingVertices2[i*24 + j].x + cube3.position.x;
				cubeMovingTranslated2[i*24 + j].y = cubeMovingVertices2[i*24 + j].y + cube3.position.y;
				cubeMovingTranslated2[i*24 + j].z = cubeMovingVertices2[i*24 + j].z + cube3.position.z;
			}
		}
	}
	else if( cubeSetType == QUAD_T )
	{
		// inputting faceside is 1-6
		switch( faceSide ) // for Cube 1
		{
		case 1:
			activeSide = Cube::NEG_Z;
			position.z += -1*startingHeight;
			break;
		case 2:
			activeSide = Cube::POS_X;
			position.x += startingHeight;
			break;
		case 3:
			activeSide = Cube::POS_Z;
			position.z += startingHeight;
			break;
		case 4:
			activeSide = Cube::NEG_X;
			position.x += -1*startingHeight;
			break;
		case 5:
			activeSide = Cube::NEG_Y;
			position.y += -1*startingHeight;
			break;
		case 6:
			activeSide = Cube::POS_Y;
			position.y += startingHeight;
			break;
		default:
			break;
		}

		// initialize the cube belonging to the set
		cube1.position = position; 
		cube1.initialPosition = position;
		cube1.direction = direction;
		cube1.sideLength = sideLength;
		cube1.distanceToLanding = distanceToLanding;
		cube1.speed = speed;
		cube1.acceleration = acceleration;
		cube1.material = material;
		cube1.color = color;
		cube1.numOfConnectedColorRequired = numOfConnectedColorRequired;
		cube1.activeSide = activeSide;
		cube1.isLanded = isLanded;

		// reset position
		if( numCubesWidth % 2 == 1 ) // if the number of static rubix cubes is ODD, center this way
		{
			// if ODD, do nothing. Cube already centered
			position.x = 0;
			position.y = 0;
			position.z = 0;
		}
		if( numCubesWidth % 2 == 0 ) // if the number of static rubix cubes is EVEN, center this way
		{
			// if EVEN, set to upper-back-left cube as center
			position.x = -s/2;
			position.y = -s/2;
			position.z = s/2;
		}

		// add to array
		cubeArrayMoving[numMovingCubesIndex] = cube1;
		numMovingCubesIndex++;

		
		

		// Link to array of translated vertices for Moving Cubes
		// The setting of vertices needs to happen starting in a saved location in the array
		// The saved location is numMovingCubesIndex, but need to go back steps after it was incremented
		// after adding the cube(s), to place in correct array location
		for( int i = (numMovingCubesIndex - 1); i < numMovingCubesIndex; i++ ) // should only loop One time for each cube
		{
			for( int j = 0; j < 24; j++ )
			{
				cubeMovingTranslated2[i*24 + j].x = cubeMovingVertices2[i*24 + j].x + cube1.position.x;
				cubeMovingTranslated2[i*24 + j].y = cubeMovingVertices2[i*24 + j].y + cube1.position.y;
				cubeMovingTranslated2[i*24 + j].z = cubeMovingVertices2[i*24 + j].z + cube1.position.z;
			}
		}

		// inputting faceside is 1-6
		switch( faceSide ) // for Cube 2
		{
		case 1:
			activeSide = Cube::NEG_Z;
			position.z += -1*startingHeight;
			position.x += sideLength;
			break;
		case 2:
			activeSide = Cube::POS_X;
			position.x += startingHeight;
			position.z += sideLength;
			break;
		case 3:
			activeSide = Cube::POS_Z;
			position.z += startingHeight;
			position.x += -1*sideLength;
			break;
		case 4:
			activeSide = Cube::NEG_X;
			position.x += -1*startingHeight;
			position.z += -1*sideLength;
			break;
		case 5:
			activeSide = Cube::NEG_Y;
			position.y += -1*startingHeight;
			position.x += sideLength;
			break;
		case 6:
			activeSide = Cube::POS_Y;
			position.y += startingHeight;
			position.x += sideLength; // keep mirror of x for side 6 because in case of 2x2x2 scenario. want blocks to stay hovered
			break;
		default:
			break;
		}

		// initialize the cube belonging to the set
		cube2.position = position; 
		cube2.initialPosition = position;
		cube2.direction = direction;
		cube2.sideLength = sideLength;
		cube2.distanceToLanding = distanceToLanding;
		cube2.speed = speed;
		cube2.acceleration = acceleration;
		cube2.material = material;
		cube2.color = color;
		cube2.numOfConnectedColorRequired = numOfConnectedColorRequired;
		cube2.activeSide = activeSide;
		cube2.isLanded = isLanded;

		// reset position
		if( numCubesWidth % 2 == 1 ) // if the number of static rubix cubes is ODD, center this way
		{
			// if ODD, do nothing. Cube already centered
			position.x = 0;
			position.y = 0;
			position.z = 0;
		}
		if( numCubesWidth % 2 == 0 ) // if the number of static rubix cubes is EVEN, center this way
		{
			// if EVEN, set to upper-back-left cube as center
			position.x = -s/2;
			position.y = -s/2;
			position.z = s/2;
		}

		// add to array
		cubeArrayMoving[numMovingCubesIndex] = cube2;
		numMovingCubesIndex++;

		
		

		// Link to array of translated vertices for Moving Cubes
		// The setting of vertices needs to happen starting in a saved location in the array
		// The saved location is numMovingCubesIndex, but need to go back steps after it was incremented
		// after adding the cube(s), to place in correct array location
		for( int i = (numMovingCubesIndex - 1); i < numMovingCubesIndex; i++ ) // should only loop One time for each cube
		{
			for( int j = 0; j < 24; j++ )
			{
				cubeMovingTranslated2[i*24 + j].x = cubeMovingVertices2[i*24 + j].x + cube2.position.x;
				cubeMovingTranslated2[i*24 + j].y = cubeMovingVertices2[i*24 + j].y + cube2.position.y;
				cubeMovingTranslated2[i*24 + j].z = cubeMovingVertices2[i*24 + j].z + cube2.position.z;
			}
		}

		// inputting faceside is 1-6
		switch( faceSide ) // for Cube 3
		{
		case 1:
			activeSide = Cube::NEG_Z;
			position.z += -1*startingHeight;
			position.x += -1*sideLength;
			break;
		case 2:
			activeSide = Cube::POS_X;
			position.x += startingHeight;
			position.z += -1*sideLength;
			break;
		case 3:
			activeSide = Cube::POS_Z;
			position.z += startingHeight;
			position.x += sideLength;
			break;
		case 4:
			activeSide = Cube::NEG_X;
			position.x += -1*startingHeight;
			position.z += sideLength;
			break;
		case 5:
			activeSide = Cube::NEG_Y;
			position.y += -1*startingHeight;
			position.x += -1*sideLength;
			break;
		case 6:
			activeSide = Cube::POS_Y;
			position.y += startingHeight;
			position.x += -1*sideLength;
			break;
		default:
			break;
		}

		// initialize the cube belonging to the set
		cube3.position = position; 
		cube3.initialPosition = position;
		cube3.direction = direction;
		cube3.sideLength = sideLength;
		cube3.distanceToLanding = distanceToLanding;
		cube3.speed = speed;
		cube3.acceleration = acceleration;
		cube3.material = material;
		cube3.color = color;
		cube3.numOfConnectedColorRequired = numOfConnectedColorRequired;
		cube3.activeSide = activeSide;
		cube3.isLanded = isLanded;

		// reset position
		if( numCubesWidth % 2 == 1 ) // if the number of static rubix cubes is ODD, center this way
		{
			// if ODD, do nothing. Cube already centered
			position.x = 0;
			position.y = 0;
			position.z = 0;
		}
		if( numCubesWidth % 2 == 0 ) // if the number of static rubix cubes is EVEN, center this way
		{
			// if EVEN, set to upper-back-left cube as center
			position.x = -s/2;
			position.y = -s/2;
			position.z = s/2;
		}

		// add to array
		cubeArrayMoving[numMovingCubesIndex] = cube3;
		numMovingCubesIndex++;

		// Link to array of translated vertices for Moving Cubes
		// The setting of vertices needs to happen starting in a saved location in the array
		// The saved location is numMovingCubesIndex, but need to go back steps after it was incremented
		// after adding the cube(s), to place in correct array location
		for( int i = (numMovingCubesIndex - 1); i < numMovingCubesIndex; i++ ) // should only loop One time for each cube
		{
			for( int j = 0; j < 24; j++ )
			{
				cubeMovingTranslated2[i*24 + j].x = cubeMovingVertices2[i*24 + j].x + cube3.position.x;
				cubeMovingTranslated2[i*24 + j].y = cubeMovingVertices2[i*24 + j].y + cube3.position.y;
				cubeMovingTranslated2[i*24 + j].z = cubeMovingVertices2[i*24 + j].z + cube3.position.z;
			}
		}

		// inputting faceside is 1-6
		switch( faceSide ) // for Cube 4, The T stick part, facing up
		{
		case 1:
			activeSide = Cube::NEG_Z;
			position.z += -1*startingHeight;
			position.y += -1*sideLength;
			break;
		case 2:
			activeSide = Cube::POS_X;
			position.x += startingHeight;
			position.y += -1*sideLength;
			break;
		case 3:
			activeSide = Cube::POS_Z;
			position.z += startingHeight;
			position.y += -1*sideLength;
			break;
		case 4:
			activeSide = Cube::NEG_X;
			position.x += -1*startingHeight;
			position.y += -1*sideLength;
			break;
		case 5:
			activeSide = Cube::NEG_Y;
			position.y += -1*startingHeight;
			position.z += sideLength;
			break;
		case 6:
			activeSide = Cube::POS_Y;
			position.y += startingHeight;
			position.z += -1*sideLength;
			break;
		default:
			break;
		}

		// initialize the cube belonging to the set
		cube4.position = position; 
		cube4.initialPosition = position;
		cube4.direction = direction;
		cube4.sideLength = sideLength;
		cube4.distanceToLanding = distanceToLanding;
		cube4.speed = speed;
		cube4.acceleration = acceleration;
		cube4.material = material;
		cube4.color = color;
		cube4.numOfConnectedColorRequired = numOfConnectedColorRequired;
		cube4.activeSide = activeSide;
		cube4.isLanded = isLanded;

		// reset position
		if( numCubesWidth % 2 == 1 ) // if the number of static rubix cubes is ODD, center this way
		{
			// if ODD, do nothing. Cube already centered
			position.x = 0;
			position.y = 0;
			position.z = 0;
		}
		if( numCubesWidth % 2 == 0 ) // if the number of static rubix cubes is EVEN, center this way
		{
			// if EVEN, set to upper-back-left cube as center
			position.x = -s/2;
			position.y = -s/2;
			position.z = s/2;
		}

		// add to array
		cubeArrayMoving[numMovingCubesIndex] = cube4;
		numMovingCubesIndex++;

		
		

		// Link to array of translated vertices for Moving Cubes
		// The setting of vertices needs to happen starting in a saved location in the array
		// The saved location is numMovingCubesIndex, but need to go back steps after it was incremented
		// after adding the cube(s), to place in correct array location
		for( int i = (numMovingCubesIndex - 1); i < numMovingCubesIndex; i++ ) // should only loop One time for each cube
		{
			for( int j = 0; j < 24; j++ )
			{
				cubeMovingTranslated2[i*24 + j].x = cubeMovingVertices2[i*24 + j].x + cube4.position.x;
				cubeMovingTranslated2[i*24 + j].y = cubeMovingVertices2[i*24 + j].y + cube4.position.y;
				cubeMovingTranslated2[i*24 + j].z = cubeMovingVertices2[i*24 + j].z + cube4.position.z;
			}
		}
	}
	else if( cubeSetType == QUAD_SQUARE )
	{
		// inputting faceside is 1-6
		switch( faceSide ) // for Cube 1
		{
		case 1:
			activeSide = Cube::NEG_Z;
			position.z += -1*startingHeight;
			break;
		case 2:
			activeSide = Cube::POS_X;
			position.x += startingHeight;
			break;
		case 3:
			activeSide = Cube::POS_Z;
			position.z += startingHeight;
			break;
		case 4:
			activeSide = Cube::NEG_X;
			position.x += -1*startingHeight;
			break;
		case 5:
			activeSide = Cube::NEG_Y;
			position.y += -1*startingHeight;
			break;
		case 6:
			activeSide = Cube::POS_Y;
			position.y += startingHeight;
			break;
		default:
			break;
		}

		// initialize the cube belonging to the set
		cube1.position = position; 
		cube1.initialPosition = position;
		cube1.direction = direction;
		cube1.sideLength = sideLength;
		cube1.distanceToLanding = distanceToLanding;
		cube1.speed = speed;
		cube1.acceleration = acceleration;
		cube1.material = material;
		cube1.color = color;
		cube1.numOfConnectedColorRequired = numOfConnectedColorRequired;
		cube1.activeSide = activeSide;
		cube1.isLanded = isLanded;

		// reset position
		if( numCubesWidth % 2 == 1 ) // if the number of static rubix cubes is ODD, center this way
		{
			// if ODD, do nothing. Cube already centered
			position.x = 0;
			position.y = 0;
			position.z = 0;
		}
		if( numCubesWidth % 2 == 0 ) // if the number of static rubix cubes is EVEN, center this way
		{
			// if EVEN, set to upper-back-left cube as center
			position.x = -s/2;
			position.y = -s/2;
			position.z = s/2;
		}

		// add to array
		cubeArrayMoving[numMovingCubesIndex] = cube1;
		numMovingCubesIndex++;

		
		

		// Link to array of translated vertices for Moving Cubes
		// The setting of vertices needs to happen starting in a saved location in the array
		// The saved location is numMovingCubesIndex, but need to go back steps after it was incremented
		// after adding the cube(s), to place in correct array location
		for( int i = (numMovingCubesIndex - 1); i < numMovingCubesIndex; i++ ) // should only loop One time for each cube
		{
			for( int j = 0; j < 24; j++ )
			{
				cubeMovingTranslated2[i*24 + j].x = cubeMovingVertices2[i*24 + j].x + cube1.position.x;
				cubeMovingTranslated2[i*24 + j].y = cubeMovingVertices2[i*24 + j].y + cube1.position.y;
				cubeMovingTranslated2[i*24 + j].z = cubeMovingVertices2[i*24 + j].z + cube1.position.z;
			}
		}

		// inputting faceside is 1-6
		switch( faceSide ) // for Cube 2
		{
		case 1:
			activeSide = Cube::NEG_Z;
			position.z += -1*startingHeight;
			position.x += sideLength;
			break;
		case 2:
			activeSide = Cube::POS_X;
			position.x += startingHeight;
			position.z += sideLength;
			break;
		case 3:
			activeSide = Cube::POS_Z;
			position.z += startingHeight;
			position.x += -1*sideLength;
			break;
		case 4:
			activeSide = Cube::NEG_X;
			position.x += -1*startingHeight;
			position.z += -1*sideLength;
			break;
		case 5:
			activeSide = Cube::NEG_Y;
			position.y += -1*startingHeight;
			position.x += sideLength;
			break;
		case 6:
			activeSide = Cube::POS_Y;
			position.y += startingHeight;
			position.x += sideLength; // keep mirror of x for side 6 because in case of 2x2x2 scenario. want blocks to stay hovered
			break;
		default:
			break;
		}

		// initialize the cube belonging to the set
		cube2.position = position; 
		cube2.initialPosition = position;
		cube2.direction = direction;
		cube2.sideLength = sideLength;
		cube2.distanceToLanding = distanceToLanding;
		cube2.speed = speed;
		cube2.acceleration = acceleration;
		cube2.material = material;
		cube2.color = color;
		cube2.numOfConnectedColorRequired = numOfConnectedColorRequired;
		cube2.activeSide = activeSide;
		cube2.isLanded = isLanded;

		// reset position
		if( numCubesWidth % 2 == 1 ) // if the number of static rubix cubes is ODD, center this way
		{
			// if ODD, do nothing. Cube already centered
			position.x = 0;
			position.y = 0;
			position.z = 0;
		}
		if( numCubesWidth % 2 == 0 ) // if the number of static rubix cubes is EVEN, center this way
		{
			// if EVEN, set to upper-back-left cube as center
			position.x = -s/2;
			position.y = -s/2;
			position.z = s/2;
		}

		// add to array
		cubeArrayMoving[numMovingCubesIndex] = cube2;
		numMovingCubesIndex++;

		
		

		// Link to array of translated vertices for Moving Cubes
		// The setting of vertices needs to happen starting in a saved location in the array
		// The saved location is numMovingCubesIndex, but need to go back steps after it was incremented
		// after adding the cube(s), to place in correct array location
		for( int i = (numMovingCubesIndex - 1); i < numMovingCubesIndex; i++ ) // should only loop One time for each cube
		{
			for( int j = 0; j < 24; j++ )
			{
				cubeMovingTranslated2[i*24 + j].x = cubeMovingVertices2[i*24 + j].x + cube2.position.x;
				cubeMovingTranslated2[i*24 + j].y = cubeMovingVertices2[i*24 + j].y + cube2.position.y;
				cubeMovingTranslated2[i*24 + j].z = cubeMovingVertices2[i*24 + j].z + cube2.position.z;
			}
		}

		// inputting faceside is 1-6
		switch( faceSide ) // for Cube 3
		{
		case 1:
			activeSide = Cube::NEG_Z;
			position.z += -1*startingHeight;
			position.y += -1*sideLength;
			break;
		case 2:
			activeSide = Cube::POS_X;
			position.x += startingHeight;
			position.y += -1*sideLength;
			break;
		case 3:
			activeSide = Cube::POS_Z;
			position.z += startingHeight;
			position.y += -1*sideLength;
			break;
		case 4:
			activeSide = Cube::NEG_X;
			position.x += -1*startingHeight;
			position.y += -1*sideLength;
			break;
		case 5:
			activeSide = Cube::NEG_Y;
			position.y += -1*startingHeight;
			position.z += sideLength;
			break;
		case 6:
			activeSide = Cube::POS_Y;
			position.y += startingHeight;
			position.z += sideLength;
			break;
		default:
			break;
		}

		// initialize the cube belonging to the set
		cube3.position = position; 
		cube3.initialPosition = position;
		cube3.direction = direction;
		cube3.sideLength = sideLength;
		cube3.distanceToLanding = distanceToLanding;
		cube3.speed = speed;
		cube3.acceleration = acceleration;
		cube3.material = material;
		cube3.color = color;
		cube3.numOfConnectedColorRequired = numOfConnectedColorRequired;
		cube3.activeSide = activeSide;
		cube3.isLanded = isLanded;

		// reset position
		if( numCubesWidth % 2 == 1 ) // if the number of static rubix cubes is ODD, center this way
		{
			// if ODD, do nothing. Cube already centered
			position.x = 0;
			position.y = 0;
			position.z = 0;
		}
		if( numCubesWidth % 2 == 0 ) // if the number of static rubix cubes is EVEN, center this way
		{
			// if EVEN, set to upper-back-left cube as center
			position.x = -s/2;
			position.y = -s/2;
			position.z = s/2;
		}

		// add to array
		cubeArrayMoving[numMovingCubesIndex] = cube3;
		numMovingCubesIndex++;

		// Link to array of translated vertices for Moving Cubes
		// The setting of vertices needs to happen starting in a saved location in the array
		// The saved location is numMovingCubesIndex, but need to go back steps after it was incremented
		// after adding the cube(s), to place in correct array location
		for( int i = (numMovingCubesIndex - 1); i < numMovingCubesIndex; i++ ) // should only loop One time for each cube
		{
			for( int j = 0; j < 24; j++ )
			{
				cubeMovingTranslated2[i*24 + j].x = cubeMovingVertices2[i*24 + j].x + cube3.position.x;
				cubeMovingTranslated2[i*24 + j].y = cubeMovingVertices2[i*24 + j].y + cube3.position.y;
				cubeMovingTranslated2[i*24 + j].z = cubeMovingVertices2[i*24 + j].z + cube3.position.z;
			}
		}

		// inputting faceside is 1-6
		switch( faceSide ) // for Cube 4
		{
		case 1:
			activeSide = Cube::NEG_Z;
			position.z += -1*startingHeight;
			position.x += sideLength;
			position.y += -1*sideLength;
			break;
		case 2:
			activeSide = Cube::POS_X;
			position.x += startingHeight;
			position.z += sideLength;
			position.y += -1*sideLength;
			break;
		case 3:
			activeSide = Cube::POS_Z;
			position.z += startingHeight;
			position.x += -1*sideLength;
			position.y += -1*sideLength;
			break;
		case 4:
			activeSide = Cube::NEG_X;
			position.x += -1*startingHeight;
			position.z += -1*sideLength;
			position.y += -1*sideLength;
			break;
		case 5:
			activeSide = Cube::NEG_Y;
			position.y += -1*startingHeight;
			position.x += sideLength;
			position.z += sideLength;
			break;
		case 6:
			activeSide = Cube::POS_Y;
			position.y += startingHeight;
			position.x += sideLength; // keep mirror of x for side 6 because in case of 2x2x2 scenario. want blocks to stay hovered
			position.z += sideLength;
			break;
		default:
			break;
		}

		// initialize the cube belonging to the set
		cube4.position = position; 
		cube4.initialPosition = position;
		cube4.direction = direction;
		cube4.sideLength = sideLength;
		cube4.distanceToLanding = distanceToLanding;
		cube4.speed = speed;
		cube4.acceleration = acceleration;
		cube4.material = material;
		cube4.color = color;
		cube4.numOfConnectedColorRequired = numOfConnectedColorRequired;
		cube4.activeSide = activeSide;
		cube4.isLanded = isLanded;

		// reset position
		if( numCubesWidth % 2 == 1 ) // if the number of static rubix cubes is ODD, center this way
		{
			// if ODD, do nothing. Cube already centered
			position.x = 0;
			position.y = 0;
			position.z = 0;
		}
		if( numCubesWidth % 2 == 0 ) // if the number of static rubix cubes is EVEN, center this way
		{
			// if EVEN, set to upper-back-left cube as center
			position.x = -s/2;
			position.y = -s/2;
			position.z = s/2;
		}

		// add to array
		cubeArrayMoving[numMovingCubesIndex] = cube4;
		numMovingCubesIndex++;

		// Link to array of translated vertices for Moving Cubes
		// The setting of vertices needs to happen starting in a saved location in the array
		// The saved location is numMovingCubesIndex, but need to go back steps after it was incremented
		// after adding the cube(s), to place in correct array location
		for( int i = (numMovingCubesIndex - 1); i < numMovingCubesIndex; i++ ) // should only loop One time for each cube
		{
			for( int j = 0; j < 24; j++ )
			{
				cubeMovingTranslated2[i*24 + j].x = cubeMovingVertices2[i*24 + j].x + cube4.position.x;
				cubeMovingTranslated2[i*24 + j].y = cubeMovingVertices2[i*24 + j].y + cube4.position.y;
				cubeMovingTranslated2[i*24 + j].z = cubeMovingVertices2[i*24 + j].z + cube4.position.z;
			}
		}
	}
}// End of spawnmovingcubes

// spawn shadows
void SpawnShadows( int16 faceSide, int16 amount )
{
	Shadow shadow1( faceSide, s );
	Shadow shadow2( faceSide, s );
	Shadow shadow3( faceSide, s );
	Shadow shadow4( faceSide, s );
	
	if( amount == 1 )
	{
		shadowArray[numShadowsIndex] = shadow1;
		numShadowsIndex++;
	}
	else if( amount == 2 )
	{
		shadowArray[numShadowsIndex] = shadow1;
		numShadowsIndex++;
		shadowArray[numShadowsIndex] = shadow2;
		numShadowsIndex++;
	}
	else if( amount == 3 )
	{
		shadowArray[numShadowsIndex] = shadow1;
		numShadowsIndex++;
		shadowArray[numShadowsIndex] = shadow2;
		numShadowsIndex++;
		shadowArray[numShadowsIndex] = shadow3;
		numShadowsIndex++;
	}
	else if( amount == 4 )
	{
		shadowArray[numShadowsIndex] = shadow1;
		numShadowsIndex++;
		shadowArray[numShadowsIndex] = shadow2;
		numShadowsIndex++;
		shadowArray[numShadowsIndex] = shadow3;
		numShadowsIndex++;
		shadowArray[numShadowsIndex] = shadow4;
		numShadowsIndex++;
	}	

	// make a copy of base vertices corresponding to correct FaceSide and add to stream to be translated later
	switch( faceSide )
	{
	case 1:
		// add the vertices to stream
		for( int i = numShadowsIndex-amount; i < numShadowsIndex; i++ ) // each shadow
		{
			for( int j = 0; j < 24; j++ )// each vertex
			{
				// makes a copy of the base vertices for specific faceSide and puts into vertex stream
				// these are not translated yet, so all have position in center, but facing the correct direction
				shadowVertices[i*24 + j] = shadowVerticesFaceSide1[j];
				shadowNormals[i*24 + j] = cubeNormals[j];
				shadowUVStream[i*24+j] = uvstream_base[j];

				shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide1[j];
			}
		}
		break;
	case 2:
		// add the vertices to stream
		for( int i = numShadowsIndex-amount; i < numShadowsIndex; i++ ) // each shadow
		{
			for( int j = 0; j < 24; j++ )// each vertex
			{
				// makes a copy of the base vertices for specific faceSide and puts into vertex stream
				// these are not translated yet, so all have position in center, but facing the correct direction
				shadowVertices[i*24 + j] = shadowVerticesFaceSide2[j];
				shadowNormals[i*24 + j] = cubeNormals[j];
				shadowUVStream[i*24+j] = uvstream_base[j];

				shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide2[j];
			}
		}
		break;
	case 3:
		// add the vertices to stream
		for( int i = numShadowsIndex-amount; i < numShadowsIndex; i++ ) // each shadow
		{
			for( int j = 0; j < 24; j++ )// each vertex
			{
				// makes a copy of the base vertices for specific faceSide and puts into vertex stream
				// these are not translated yet, so all have position in center, but facing the correct direction
				shadowVertices[i*24 + j] = shadowVerticesFaceSide3[j];
				shadowNormals[i*24 + j] = cubeNormals[j];
				shadowUVStream[i*24+j] = uvstream_base[j];

				shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide3[j];
			}
		}
		break;
	case 4:
		// add the vertices to stream
		for( int i = numShadowsIndex-amount; i < numShadowsIndex; i++ ) // each shadow
		{
			for( int j = 0; j < 24; j++ )// each vertex
			{
				// makes a copy of the base vertices for specific faceSide and puts into vertex stream
				// these are not translated yet, so all have position in center, but facing the correct direction
				shadowVertices[i*24 + j] = shadowVerticesFaceSide4[j];
				shadowNormals[i*24 + j] = cubeNormals[j];
				shadowUVStream[i*24+j] = uvstream_base[j];

				shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide4[j];
			}
		}
		break;
	case 5:
		// add the vertices to stream
		for( int i = numShadowsIndex-amount; i < numShadowsIndex; i++ ) // each shadow
		{
			for( int j = 0; j < 24; j++ )// each vertex
			{
				// makes a copy of the base vertices for specific faceSide and puts into vertex stream
				// these are not translated yet, so all have position in center, but facing the correct direction
				shadowVertices[i*24 + j] = shadowVerticesFaceSide5[j];
				shadowNormals[i*24 + j] = cubeNormals[j];
				shadowUVStream[i*24+j] = uvstream_base[j];

				shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide5[j];
			}
		}
		break;
	case 6:
		// add the vertices to stream
		for( int i = numShadowsIndex-amount; i < numShadowsIndex; i++ ) // each shadow
		{
			for( int j = 0; j < 24; j++ )// each vertex
			{
				// makes a copy of the base vertices for specific faceSide and puts into vertex stream
				// these are not translated yet, so all have position in center, but facing the correct direction
				shadowVertices[i*24 + j] = shadowVerticesFaceSide6[j];
				shadowNormals[i*24 + j] = cubeNormals[j];
				shadowUVStream[i*24+j] = uvstream_base[j];

				shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide6[j];
			}
		}
		break;
	}
}

void LinkShadowToCube( int16 index )
{
	shadowArray[index].cube = cubeArrayMoving + index;
	shadowArray[index].position = cubeArrayMoving[index].position;
	//shadowArray[index].initialPosition = cubeArrayMoving[index].position; // this was taken out b/c it affects shadow's movements when shifting data structures
	shadowArray[index].setSpawnPosition( cubeArrayMoving[index].position ); // this is set only once. don't worry b/c has internal boolean to keep track
	shadowArray[index].setDirection( cubeArrayMoving[index].direction );

	// links cube to the shadow
	cubeArrayMoving[index].shadow = shadowArray + index;
}

// Link() tests to see if two cubes are adjacent, and then links them together as neighbors through
// linked list-type data structure. If two cubes have the same color but different ID's, that means 
// they are not a part of the same network, and should be linked and the numOfConnectedColor should be increased
// throughout both cubes and also their entire network. IDs are also synchronized to be the same within that network.
// If, however, two cubes have same ID AND same color, that means they are a part of the same network already, so only
// a link should be made and numOfConnectedColor NOT increased - linked just like if they were adjacent but diff colors.
void Link( Cube* dock, Cube* docker ) // must use pass-by-reference to ensure they are linked correctly
{
	int16 dockerFaceSide = docker->sideResidesOn( *dock );
	int16 dockFaceSide = dock->sideResidesOn( *docker );
	int16 dockerID = docker->getID();
	int16 dockID = dock->getID();
	int16 totalNumOfConnectedColor = docker->numOfConnectedColor + dock->numOfConnectedColor;

	// First, comparison is if docker and dock have the SAME color
	// If the ID's are different between docking cube and dock cube, that means they are a part of different networks.
	// We want to merge ID for docker and all its connected cubes in order to connect their networks.
	// Then merge the numOfConnectedColor with docker and dock to the docker.
	// Then recursively traverse through all the neighbors starting from docker to update the numOfConnectedColor 

	if( (dockerID != dockID) && (docker->color == dock->color) )  // if cubes are same color but different networks
	{		
		//docker.setID( dockID );  // set docker ID equal to dock's to merge networks
		//docker.numOfConnectedColor = totalNumOfConnectedColor; // updates the numofconnectedcolor for docker. now the most up-to-date in network.
		
		if( dockerFaceSide == 0 || dockFaceSide == 0 ) // tests to see if faceSide was found
			printf("Link failed. Same color, different ID's, but positions were not adjacent between two cubes.\n");
		else
		{
			docker->linkAsNeighbor( dock, dockerFaceSide ); // Link as neighbors
			dock->linkAsNeighbor( docker, dockFaceSide );
			// update the network with docker as root. must feed color to be tested in order to update cubes with same color but diff ID's
			docker->updateNetwork( true, dockID, dock->color, totalNumOfConnectedColor );
		}
	}
	else // else if IDs are the same, or if they aren't, only link as neighbors
	{
		if( dockerFaceSide == 0 || dockFaceSide == 0 ) // tests to see if faceSide was found
			printf("Link failed. Positions were not adjacent between two cubes.\n");
		else
		{
			docker->linkAsNeighbor( dock, dockerFaceSide ); // Link as neighbors
			dock->linkAsNeighbor( docker, dockFaceSide );
		}
	}
} 

// moves the cube
// first determine's the cube's "next position" in the next time increment,
// then checks the position against all static cubes in the array. If the next
// position is occupied by any of those cubes, will initiate the landing.
// If the next position is not occupied, proceed to move it.
void Move( Cube* cube, int16 index )
{
	// Aligns cube's XY plane with the linked shadow's
	switch( cube->direction )
	{
	case 1:
		cube->position.x = shadowArray[index].position.x;
		cube->position.y = shadowArray[index].position.y;
		break;
	case 2:
		cube->position.z = shadowArray[index].position.z;
		cube->position.y = shadowArray[index].position.y;
		break;
	case 3:
		cube->position.x = shadowArray[index].position.x;
		cube->position.y = shadowArray[index].position.y;
		break;
	case 4:
		cube->position.z = shadowArray[index].position.z;
		cube->position.y = shadowArray[index].position.y;
		break;
	case 5:
		cube->position.z = shadowArray[index].position.z;
		cube->position.x = shadowArray[index].position.x;
		break;
	case 6:
		cube->position.z = shadowArray[index].position.z;
		cube->position.x = shadowArray[index].position.x;
		break;
	}

	nextPosition = cube->position; // next position must be the current position to maintain alignment
	Cube *closestCube = NULL;

	// acceleration, must also be multiple of the FPS
	//cube->speed = cube->speed + cube->acceleration/RATE;
	//if( cube->speed > MAX_SPEED )
		//cube->speed = MAX_SPEED;
	
	// while distance is updated by GameTime passing
	switch(cube->direction) // determine's the cube's next position. 
	{
	case 1:
		nextPosition.z = cube->position.z + cube->speed/RATE;
		//nextPosition.z = cube->initialPosition.z + cube->speed * (int16)GameTime; // the "depth" will be independent of current depth, so we use initialPosition here
		break;
	case 2:
		nextPosition.x = cube->position.x + -1*cube->speed/RATE;
		//nextPosition.x = cube->initialPosition.x + -1*cube->speed * (int16)GameTime;
		break;
	case 3:
		nextPosition.z = cube->position.z + -1*cube->speed/RATE;
		//nextPosition.z = cube->initialPosition.z + -1*cube->speed * (int16)GameTime;
		break;
	case 4:
		nextPosition.x = cube->position.x + cube->speed/RATE;
		//nextPosition.x = cube->initialPosition.x + cube->speed * (int16)GameTime;
		break;
	case 5:
		nextPosition.y = cube->position.y + cube->speed/RATE;
		//nextPosition.y = cube->initialPosition.y + cube->speed * (int16)GameTime;
		break;
	case 6:
		nextPosition.y = cube->position.y + -1*cube->speed/RATE;
		//nextPosition.y = cube->initialPosition.y + -1*cube->speed * (int16)GameTime;
		break;
	}


	// Find closest cube
	for( int i = 0; i < numStaticCubes; i++ ) // look at all the static cubes
	{
		if( cubeArray[i].position != cube->position ) // this makes sure 'cube' does not get compared with itself
		{
			// find the cubes on the same direction axis
			switch( cube->direction )
			{
			// the distanceToLanding is the difference of current position and static cube's position. 
			// also mind the negative/positive axes. Ensure positive values
			case 1: 
				if((cubeArray[i].position.y == cube->position.y) && (cubeArray[i].position.x == cube->position.x)) // tests to see if static cube is on the same axis - XY
				{				
					if( closestCube == NULL ) // initialize the closestCube to be the first cube in array that has same axis alignment
					{
						closestCube = cubeArray + i;
					}
					else if( cubeArray[i].position.z < closestCube->position.z && (cubeArray[i].exploding == false && cubeArray[i].exploded == false) ) // if the cube is higher than the closestcube, make that the new closestcube
					{
						closestCube = cubeArray + i;
					}
				}
				break;
			case 2:
				if((cubeArray[i].position.z == cube->position.z) && (cubeArray[i].position.y == cube->position.y)) // tests to see if static cube is on the same axis - ZY
				{		
					if( closestCube == NULL ) // initialize the closestCube to be the first cube in array that has same axis alignment
					{
						closestCube = cubeArray + i;
					}
					else if( cubeArray[i].position.x > closestCube->position.x && (cubeArray[i].exploding == false && cubeArray[i].exploded == false) ) // if the cube is higher than the closestcube, make that the new closestcube
					{
						closestCube = cubeArray + i;
					}
				}
				break;
			case 3:
				if((cubeArray[i].position.y == cube->position.y) && (cubeArray[i].position.x == cube->position.x)) // tests to see if static cube is on the same axis - XY
				{				
					if( closestCube == NULL ) // initialize the closestCube to be the first cube in array that has same axis alignment
					{
						closestCube = cubeArray + i;
					}
					else if( cubeArray[i].position.z > closestCube->position.z && (cubeArray[i].exploding == false && cubeArray[i].exploded == false) ) // if the cube is higher than the closestcube, make that the new closestcube
					{
						closestCube = cubeArray + i;
					}
				}
				break;
			case 4:
				if((cubeArray[i].position.z == cube->position.z) && (cubeArray[i].position.y == cube->position.y)) // tests to see if static cube is on the same axis - ZY
				{			
					if( closestCube == NULL ) // initialize the closestCube to be the first cube in array that has same axis alignment
					{
						closestCube = cubeArray + i;
					}
					else if( cubeArray[i].position.x < closestCube->position.x && (cubeArray[i].exploding == false && cubeArray[i].exploded == false) ) // if the cube is higher than the closestcube, make that the new closestcube
					{
						closestCube = cubeArray + i;
					}
				}
				break;
			case 5:
				if((cubeArray[i].position.z == cube->position.z) && (cubeArray[i].position.x == cube->position.x)) // tests to see if static cube is on the same axis - XZ
				{				
					if( closestCube == NULL ) // initialize the closestCube to be the first cube in array that has same axis alignment
					{
						closestCube = cubeArray + i;
					}
					else if( cubeArray[i].position.y < closestCube->position.y && (cubeArray[i].exploding == false && cubeArray[i].exploded == false) ) // if the cube is higher than the closestcube, make that the new closestcube
					{
						closestCube = cubeArray + i;
					}
				}
				break;
			case 6:
				if((cubeArray[i].position.z == cube->position.z) && (cubeArray[i].position.x == cube->position.x)) // tests to see if static cube is on the same axis - XZ
				{				
					if( closestCube == NULL ) // initialize the closestCube to be the first cube in array that has same axis alignment
					{
						closestCube = cubeArray + i;
					}
					else if( cubeArray[i].position.y > closestCube->position.y && (cubeArray[i].exploding == false && cubeArray[i].exploded == false) ) // if the cube is higher than the closestcube, make that the new closestcube
					{
						closestCube = cubeArray + i;
					}
				}
				break;
			}
		}
	}

	cube->closestLandingCube = closestCube;
	
	// Establish the DistanceToLanding. Once this reaches zero or less, the cube is landed.
	// Look at all the static cubes and find ones with the same axis.
	// Find the ones with closest distance and set the differene as distance to landing. 
	// If the distance to landing reaches or is less than zero, it will have landed.

	//cube->distanceToLanding = 0; // resets the DTL each time

	
	// find the cubes on the same direction axis
	switch( cube->direction ) 
	{
	// the distanceToLanding is the difference of current position and static cube's position. 
	// also mind the negative/positive axes. Ensure positive values
	// compare cube's position with closestCube's position
	case 1: 
		cube->distanceToLanding = abs(cube->position.z) - abs(closestCube->position.z) - s;
		break;
	case 2:
		cube->distanceToLanding = abs(cube->position.x) - abs(closestCube->position.x) - s;
		break;
	case 3:
		cube->distanceToLanding = abs(cube->position.z) - abs(closestCube->position.z) - s;
		break;
	case 4:
		cube->distanceToLanding = abs(cube->position.x) - abs(closestCube->position.x) - s;
		break;
	case 5:
		cube->distanceToLanding = abs(cube->position.y) - abs(closestCube->position.y) - s;
		break;
	case 6:
		cube->distanceToLanding = abs(cube->position.y) - abs(closestCube->position.y) - s;
		break;
	}

	// Reduce speed if DTL is within panic limit at s*5
	// this is what we need to test for during experiment. See what comfort limit equals what levels of freaking out
	if( cube->shadow->shadowGroup->dropCubes == false && cube->distanceToLanding <= s*5 )
	{
		cube->shadow->shadowGroup->startSlowingDown = true;
	}

	if( cube->shadow->shadowGroup->dropCubes == false && cube->shadow->shadowGroup->startSlowingDown == true )
	{
		if( storyMode == true )
		{
			if( INITIAL_SPEED >= 800 )
			{
				cube->speed = 450;
			}
			else if( INITIAL_SPEED >= 600 )
			{
				cube->speed = 400;
			}		
			else if( INITIAL_SPEED >= 400 )
			{
				cube->speed = 300;
			}
		}
	}
	

	// If difference in (Next Position - current position) with 
	// distance to landing is zero or less, that means cube has hit another cube
	int16 deltaDistance = 0;
	int16 netDistance = 0;
	switch(cube->direction)
	{
	case 1:
		deltaDistance = abs(cube->position.z - nextPosition.z);
		break;
	case 2:
		deltaDistance = cube->position.x - nextPosition.x;
		break;
	case 3:
		deltaDistance = cube->position.z - nextPosition.z;
		break;
	case 4:
		deltaDistance = abs(cube->position.x - nextPosition.x);
		break;
	case 5:
		deltaDistance = abs(cube->position.y - nextPosition.y);
		break;
	case 6:
		deltaDistance = cube->position.y - nextPosition.y;
		break;
	}

	
	// STOPS CUBES FROM BEING MOVED within s/4 distance from hitting
	// if cube is within s/4 distance from distance to landing, do not let it touch
	if( cube->distanceToLanding <= s/4 )
	{
		// if the shadow landing is the one that is being touched
		if( selectedShadow != NULL )
		{
			if( selectedShadow->cube->ID == cube->ID )
			{
				
				cube->shadow->shadowGroup->dropCubes = true; // this prevents the shadows and cubes from being moved
				selectedShadow = NULL;

				shadowIsTouched = false;
			}
		}
	}


	// Cube has Landed
	if( deltaDistance > cube->distanceToLanding || deltaDistance == cube->distanceToLanding ) //sound/ this means cube has landed
	{
		// PLAY LAND SOUND just once
		if( cube->shadow->shadowGroup->firstCubeLanded == false )
		{
			playLandSound();			
			cube->shadow->shadowGroup->firstCubeLanded = true;
		}

		// Start bomb ticking if true
		if( cube->hasBomb == true )
		{
			cube->bomb.setState( Bomb::TICKING );
			playBombVoice();
		}
		
		// EFFICIENCY INDEX variables
		// keeping track of number of drops
		//if( percentComplete < 1.0 ) // only count total drops if progress bar under 100%. this affects statistics b/c points are not received at this state
		{
			totalDrops++;
			totalDropsCurrent++;
		}

		if( storyMode == true )
		{
			storyModeTotalDropsCurrent++;
		}

		// keeping track of number of drops in flow state to determine variable reset
		if( inFlowState == true )
		{
			totalDropsInFlowState++;
		}

		// for tutorial, grant completion for level 3 Tap-to-Drop
		if( tutorialNumber == 3 )
		{
			tutorialTapDropPassed = true;
		}
		
		// IF CUBE HIT PLANE
		// checks if the closest cube is one of the originals. If it was, that means this cube hit a plane
		if( closestCube->ID == 0 )
		{
			cube->touchingSide = true; // set the cube of touching plane to true. will be used to determine when it warps
			cube->layerLevel = 1; // set the layer to level 1 if it touches the plane

			for( int i = 0; i < 6; i++ ) // CHECKING COLOR COMPARISON AGAINST PLANE
			{
				if( plane[i].direction == cube->direction && plane[i].color == cube->color ) // IF SAME COLOR AND DIRECTION
				{
					plane[i].count++; // increase count to plane - not needed anymore. need to take out the BREAK for +point images

					// SHOW NICE SPRITE FOR TUTORIAL
					if( tutorialNumber == 4 || tutorialNumber == 7 )
					{
						showCongratsSpriteNice = true;
					}
					
					// ADD POINTS if it landed on side
					if( cube->hasBomb == false && percentComplete < 1.0 ) // do not add points if there is a bomb, or if progress bar is full
					{
						// play sound
						if( cube->shadow->shadowGroup->scoredPoints == false )
						{
							playPointPerkSound();
							cube->shadow->shadowGroup->scoredPoints = true;
						}

						// set plus point images to render and increase score
						for( int j = 0; j < 4; j++ ) // find the free sprite 
						{
							if( pointSprites[i][j].type == PointSprite::NONE ) // means it's free
							{
								// add one hundred points
								if( cube->hasFuzzy == true )
								{
									pointSprites[i][j].setType( PointSprite::ONE_HUNDRED ); // it is one hundred points if it is a fuzzy
									addScore( 100 );
								}
								else if( cube->hasFuzzy == false ) // add fifty points
								{
									pointSprites[i][j].setType( PointSprite::FIFTY ); // it is fifty points if the cube is not a fuzzy
									addScore( 50 );
								}
								// set the location of the point sprite
								int32 x;
								int32 y;
								CIwVec3 p = modelMatrix1.TransformVec( (CIwVec3)cube->position );

								// convert 3d to 2d coordinates
								IwGxWorldToScreenXY( x, y, p );

								pointSprites[i][j].setPosition( x, y - height*.063 );// set the location

								// Efficiency Index - increment scoredDrops
								scoredDrops++;
								scoredDropsCurrent++;

								break; // stop assigning and activating sprites once free one is found
							}
						}

						break; // break out of loop when found the plane that matches cube, and stop incrementing count.
					} // end of adding points if not a bomb and percentComplete is under 100%
				}
				else if( plane[i].direction == cube->direction && plane[i].color != cube->color )// IF SAME DIRECTION BUT DIFF COLOR
				{
					// set cube to explode
					cube->exploding = true;

					if( cube->hasFuzzy == true )
					{
						// plays fuzzy death voice sound
						if( playedDeathVoiceOnce == false )
						{
							playDeathVoice();
							playedDeathVoiceOnce = true;
						}
						
					}

					// if the cube was a bomb, it was defused
					if( cube->hasBomb == true )
					{
						cube->bomb.defused = true;
					}

					// do not increase plane count
					
					totalDTL += -5;
					comfortIndexCurrent = -panicLimit;
				}
			} // end of for loop checking planes to see which plane landed for adding points			
		} // end of if-statement if a cube hit a side
		else if( closestCube->ID != 0 ) // IF CUBE LANDED ON ANOTHER CUBE
		{
			if( cube->color == closestCube->color ) // IF CUBE HAS SAME COLOR AS CUBE UNDERNEATH
			{
				// do nothing
			}
			else // IF CUBE HAS DIFFERENT COLOR THAN CUBE UNDERNEATH
			{
				// make it explode
				cube->exploding = true;
				// play death voice, only if it has a fuzzy inside
				if( playedDeathVoiceOnce == false && cube->hasFuzzy == true )
				{
					playDeathVoice();
					playedDeathVoiceOnce = true;
				}
				

				// make the cube underneath explode
				// check if it's a bomb. If it wasn't already heating up, then make it be defused
				closestCube->exploding = true;
				if( closestCube->hasFuzzy == true )
				{
					if( playedDeathVoiceOnce == false )
					{
						playDeathVoice();
						playedDeathVoiceOnce = true;
					}
				}

				if( closestCube->hasBomb == true )
				{
					if( closestCube->bomb.state == Bomb::TICKING ) // only defuse bomb if it was still ticking
					{
						closestCube->bomb.defused = true;
					}
				}

				// if this cube was a bomb itself, defuse it
				if( cube->hasBomb == true )
				{
					cube->bomb.defused = true;
				}

				totalDTL += -5;
				comfortIndexCurrent = -panicLimit;

			}
		}

		cube->isLanded = true;

		
		// tutorial counts
		if( cube->shadow->shadowGroup->landed == false )
		{
			cube->shadow->shadowGroup->landed = true;

			// tutorial counts
			if( episode == 1 )
			{
				numOfTutorialDropsCurrent++;

				// hide tutorial tap to drop	
				if( triggeredShowTutorialTapDrop == true && triggeredHideTutorialTapDrop == false )
				{
					s3eTimerSetTimer( 0, triggerHideTutorialTapDrop, 0 );
					s3eTimerCancelTimer( triggerShowTutorialTapDrop, 0 );
					triggeredHideTutorialTapDrop = true;
				}

				// show tutorial drag space count
				if( planeSpawning == DOUBLE_ADJACENT && cubeSpawning == SINGLE_RANDOM && tutorialDragSpaceShown == true )
				{
					tutorialDragSpaceCount++;
					tutorialDragSpaceShown = false;
				}
			}
		}

		// only increase layer level if the cubes are same color
		if( cube->color == closestCube->color && closestCube->layerLevel >= 1 && cube->exploding == false ) // only increase layer level if cube is not exploding
		{
			cube->layerLevel = closestCube->layerLevel + 1; // the layer level is one more than its closestCube's layer level
			// we only increase it if it's the same color soas to not increase it when it lands on a diff color, to prevent from ending game with too many stacks
			
			// show tutorial donotstack
			if( episode == 1 && levelNumber >= 1 && levelNumber <= 3  && percentComplete > .999 && cube->layerLevel >= 2 )
			{
				enableTutorialDoNotStack = true;
			}
		}

		// may be obsolete/unneeded
		// update Plane's highest layer level
		for( int i = 0; i < 6; i++ )
		{
			if( plane[i].direction == cube->direction && cube->exploding == false ) // finds the plane side that the cube landed on
			{
				if( cube->layerLevel > plane[i].highestLayerLevel )
					plane[i].highestLayerLevel = cube->layerLevel;
			}
		}

		// slowdrop the cubes if they hit without a droptap. determined by the speed of falling cube since droptap is reset before it hits even if activated
		if( cube->speed < 24000 )
		{
			// QFI Multitasking Index - adding totalDroppedCubeSets to be multiplied to startingHeight
			// Only increase if it was the FIRST time that the shadow group's slowdrop variable was set to true
			if( cube->shadow->shadowGroup->dropCubesSlow == false )
			{
				// multitasking index and comfort index are only calculated if the spawn types are RANDOM
				// otherwise you can just move and choose to not drop and let cubes fall if they spawn INCOLOR
				if( true /*cubeSpawning != DOUBLE_INCOLOR && 
					cubeSpawning != TRIPLE_INCOLOR && 
					cubeSpawning != QUADRUPLE_INCOLOR && 
					cubeSpawning != QUINTUPLE_INCOLOR && 
					cubeSpawning != SEXTUPLE_INCOLOR*/ )
				{
					totalDroppedCubeSets++;
					totalDroppedCubeSetsCurrent++;

					totalDTL += -5;

					
					comfortIndexCurrent = -panicLimit;
				}
			}

			cube->shadow->shadowGroup->dropCubesSlow = true; // only activate if cubes were not landed due to droptap
			dropCubesSlow(); // perform a dropcubes whenever a cube has landed to prevent delayed dropping of rest of cubes in group
		}
		cube->shadow->shadowGroup->dropCubes = true;
		cube->speed = 0;
		cube->acceleration = 0;
		cube->position = closestCube->position; // clamp position


		switch(cube->direction) // clamp the cube's position based on the cube it landed on's position
		{
		case 1:
			cube->position.z = closestCube->position.z + -1*cube->sideLength;
			break;
		case 2:
			cube->position.x = closestCube->position.x + cube->sideLength;
			break;
		case 3:
			cube->position.z = closestCube->position.z + cube->sideLength;
			break;
		case 4:
			cube->position.x = closestCube->position.x + -1*cube->sideLength;
			break;
		case 5:
			cube->position.y = closestCube->position.y + -1*cube->sideLength;
			break;
		case 6:
			cube->position.y = closestCube->position.y + cube->sideLength;
			break;
		}
	}
	else
	{
		cube->position = nextPosition;
	}

	// If the cube has landed from Moving to Static
	// Link to vertices
	if( cube->isLanded == true )
	{
		// Perfect Warp Counter checks
		if( perfectWarped == true )
		{
			// if there was a perfect warp the previous cube landing, do nothing

			// check for perfect warped on current iteration
			checkPerfectWarped = true;
		}
		else // if there was NO perfect warp previous cube landing, reset the warp counter
		{
			perfectWarpCount = 0;

			// check for perfect warped on current iteration
			checkPerfectWarped = true;
		}

		// Add to static cube array
		cubeArray[numStaticCubes] = *cube;
		// translate after becoming Static to vertex stream
		for( int j = 0; j < 24; j++ )
		{
			// add vertices to the static stream. The cubeVertices2 array has already been initialized with max num of cubes possible in game
			cubeTranslated2[numStaticCubes*24 + j].x = cubeVertices2[numStaticCubes*24 + j].x + cube->position.x;
			cubeTranslated2[numStaticCubes*24 + j].y = cubeVertices2[numStaticCubes*24 + j].y + cube->position.y;
			cubeTranslated2[numStaticCubes*24 + j].z = cubeVertices2[numStaticCubes*24 + j].z + cube->position.z;			
		}		

		// also make sure other shadows are not touchable

		// This is no longer used, because vertex stream is based on material.
		// Copying of vertices should be located at the end of Update()
		/*
		// Copy vertices to movingToStatic array
		for( int j = 0; j < 24; j++ )
		{
			movingToStaticVertices[movingToStaticIndex*24 +j] = cubeTranslated2[numStaticCubes*24 + j];
			movingToStaticNormals[movingToStaticIndex*24 +j] = cubeNormals2[numStaticCubes*24 + j];
		}
		movingToStaticIndex++;
		*/

		// increment count of static cubes after vertex initialization
		numStaticCubes++;
		

		// When dealing with pointers and they are pointing to each other, make sure they are in the same Array.
		// That's why I added the cube to static array first, and then make pointer links with neighbors within the
		// static array. This yields correct pointing, and neighbors don't get F'd up.
		// Compare and Link this cube with every cube in array of static cubes only if they are adjacent
		// and link only if they have nonzero ID
		/* LINK is obsolete. Not needed, I think...
		for( int i = 0; i < numStaticCubes - 1; i++ )
		{
			if( cubeArray[numStaticCubes-1].isAdjacentTo( cubeArray[i] ) && cubeArray[i].getID() != 0 ) // link the cube if it's adjacent to a static cube
			{
				Link( cubeArray+(numStaticCubes - 1), cubeArray + i );
			}
		}*/
	}
	else // if cube still in motion, move it. link position to vertices
	{
		// translate to vertex stream
		for( int j = 0; j < 24; j++ )
		{
			//cubeMovingTranslated2[index*24 + j].x = cubeMovingVertices2[index*24 + j].x + cube->position.x;
			//cubeMovingTranslated2[index*24 + j].y = cubeMovingVertices2[index*24 + j].y + cube->position.y;
			//cubeMovingTranslated2[index*24 + j].z = cubeMovingVertices2[index*24 + j].z + cube->position.z;
			cubeMovingTranslated2[index*24 + j] = cubeMovingVertices2[index*24 + j] + cube->position;
		}
	}


	// Restrictions for rotation when a cube is spawning
	if( isSpawning == false )
	{
		cube->hasMovedOnce = true;
	}

	// adding this boolean to signal allCubesHaveMovedOnce ensures allCubes does not get read as true during loop
	bool testingForAllMovedOnce = false;
	if( isSpawning == true )
	{
		for( int i = 0; i < numMovingCubesIndex; i++ )
		{
			if( cubeArrayMoving[i].hasMovedOnce == false )
			{
				testingForAllMovedOnce = true;
			}
		}
	}

	allCubesHaveMovedOnce = false;
	if( testingForAllMovedOnce == false )
	{
		allCubesHaveMovedOnce = true;
	}

	if( completeComplete == false && allCubesHaveMovedOnce == true && isSpawning == false )
	{
		completeComplete = true; // completeComplete signals the spawningSetCounter to activate delay until rotation is pressable
	}

} // end of move()

void MoveShadows( int16 dx, int16 dy )
{
	//int16 dxPerUnit = 30;
	//int16 dyPerUnit = 30;
	int16 dxPerUnit = 15.0 / 244 * height + 60 / 7.0;
	int16 dyPerUnit = 15.0 / 244 * height + 60 / 7.0;
	
	// controls shadow motion sensitivity
	if( highestLayerLevel < 3 ) // if normal camera
	{
		//if( selectedShadow != NULL )
		{
			//switch( selectedShadow->cube->closestLandingCube->layerLevel)
			switch( layerLevelOnTouch )
			{
			case 0:
				//dxPerUnit = 30;
				//dyPerUnit = 30;
				dxPerUnit = 15.0 / 244 * height + 60 / 7.0;
				dyPerUnit = 15.0 / 244 * height + 60 / 7.0;
				break;
			case 1:
				//dxPerUnit = 40;
				//dyPerUnit = 40;
				dxPerUnit = 25.0 / 244 * height + 30 / 7.0;
				dyPerUnit = 25.0 / 244 * height + 30 / 7.0;
				break;
			case 2:
				//dxPerUnit = 50;
				//dyPerUnit = 50;
				dxPerUnit = 5.0 / 32 * height;
				dyPerUnit = 5.0 / 32 * height;
				break;
			default:
				//dxPerUnit = 30;
				//dyPerUnit = 30;
				dxPerUnit = 15.0 / 244 * height + 60 / 7.0;
				dyPerUnit = 15.0 / 244 * height + 60 / 7.0;
				break;
			}
		}
	}
	else // if camera is zoomed out and wobbling
	{
		//dxPerUnit = 30;
		//dyPerUnit = 30;
		dxPerUnit = 15.0 / 244 * height + 60 / 7.0;
		dyPerUnit = 15.0 / 244 * height + 60 / 7.0;
	}

	int16 xUnitsToMove = dx / dxPerUnit; // the number of units to try to move based on delta X drag
	int16 yUnitsToMove = dy / dyPerUnit; // the number of units to try to move based on delta Y drag


	int16 limit; // used to clamp position
	int16 direction = getActiveFaceSide();

	int16 invertXIndex = 1;
	int16 invertYIndex = 1;

	CIwSVec3 position; // this is the position we try to move the shadow

	

	for( int i = 0; i < numShadowsIndex; i++ ) // search  through shadow array
	{
		if( shadowArray[i].direction == direction && shadowArray[i].shadowGroup->dropCubes == false ) // for each shadow on the active side
		{	
			// disable droptap if moved a cube past a certain distance
			if( abs(dx) >= dxPerUnit || abs(dy) >= dyPerUnit )
			{
				dropTap = false;
			}

			// set the location
			if( numCubesWidth % 2 == 1 ) // if the sides are ODD
			{
				// different for each faceside
				switch( direction )
				{
				case 1:					
					// moving the X values
					// clamp the location based on limit if necessary
					limit = (numCubesWidth - 1)/2 * s;

					// account for camera flipping
					if( worldX == 2048 || worldX == -2048 )
					{
						invertXIndex = -1;
					}
					if( worldY == -2048 || worldY == 2048 )
					{
						invertYIndex = -1;
					}

					xUnitsToMove *= invertXIndex;
					yUnitsToMove *= invertYIndex;
					
					if( shadowArray[i].shadowGroup->leftBound + (xUnitsToMove*s) <= -1*limit ) // if the units to move exceeds limit
					{
						// set the units to move equal to limit minus bound
						xUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->leftBound) / s;						
					}
					else if( shadowArray[i].shadowGroup->rightBound + (xUnitsToMove*s) >= limit )
					{
						xUnitsToMove = (limit - shadowArray[i].shadowGroup->rightBound) / s;
					}
					else
					{
						xUnitsToMove = dx / dxPerUnit * invertXIndex;
					}	

					position.x = shadowArray[i].initialPosition.x + (xUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
					shadowArray[i].position.x = position.x; // set the position

					// moving the Y values
					limit = (numCubesHeight - 1)/2 * s;

					if( shadowArray[i].shadowGroup->topBound + (yUnitsToMove*s) <= -1*limit ) // if the units to move exceeds limit
					{
						// set the units to move equal to limit minus bound
						yUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->topBound) / s;
					}
					else if( shadowArray[i].shadowGroup->bottomBound + (yUnitsToMove*s) >= limit )
					{
						yUnitsToMove = (limit - shadowArray[i].shadowGroup->bottomBound) / s;
					}
					else
					{
						yUnitsToMove = dy / dyPerUnit * invertYIndex;
					}	

					position.y = shadowArray[i].initialPosition.y + (yUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
					shadowArray[i].position.y = position.y; // set the position

					// reverse the reverse for each successive shadow object
					xUnitsToMove *= invertXIndex;
					yUnitsToMove *= invertYIndex;

					break;
				case 3:
					// moving the X values
					// clamp the location based on limit if necessary
					limit = (numCubesWidth - 1)/2 * s;

					// account for camera flipping
					if( worldX == 2048 || worldX == -2048 )
					{
						invertXIndex = -1;
					}

					if( worldY == -2048 || worldY == 2048 )
					{
						invertYIndex = -1;
					}

					xUnitsToMove *= invertXIndex;
					yUnitsToMove *= invertYIndex;
					
					if( (shadowArray[i].shadowGroup->leftBound + (xUnitsToMove*s)) >= limit ) // if the units to move exceeds limit
					{
						// set the units to move equal to limit minus bound
						xUnitsToMove = (limit - shadowArray[i].shadowGroup->leftBound) / s;
					}
					else if( shadowArray[i].shadowGroup->rightBound + (xUnitsToMove*s) <= -1* limit )
					{
						xUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->rightBound) / s;
					}
					else
					{
						xUnitsToMove = dx / dxPerUnit * invertXIndex;
					}	

					position.x = shadowArray[i].initialPosition.x + (xUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
					shadowArray[i].position.x = position.x; // set the position
					
					// moving the Y values
					limit = (numCubesHeight - 1)/2 * s;

					if( shadowArray[i].shadowGroup->topBound + (yUnitsToMove*s) <= -1*limit ) // if the units to move exceeds limit
					{
						// set the units to move equal to limit minus bound
						yUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->topBound) / s;
					}
					else if( shadowArray[i].shadowGroup->bottomBound + (yUnitsToMove*s) >= limit )
					{
						yUnitsToMove = (limit - shadowArray[i].shadowGroup->bottomBound) / s;
					}
					else
					{
						yUnitsToMove = dy / dyPerUnit * invertYIndex;
					}	

					position.y = shadowArray[i].initialPosition.y + (yUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
					shadowArray[i].position.y = position.y; // set the position

					// reverse the reverse for each successive shadow object
					xUnitsToMove *= invertXIndex;
					yUnitsToMove *= invertYIndex;

					break;
				case 2:
					// moving the X values
					// clamp the location based on limit if necessary
					limit = (numCubesLength - 1)/2 * s;

					if( worldX == 1024 || worldX == -3072 )
					{
						invertXIndex = -1;
					}
					if( worldY == 2048 || worldY == -2048 )
					{
						invertYIndex = -1;
					}

					xUnitsToMove *= invertXIndex;
					yUnitsToMove *= invertYIndex;
					
					if( shadowArray[i].shadowGroup->leftBound + (xUnitsToMove*s) <= -1*limit ) // if the units to move exceeds limit
					{
						// set the units to move equal to limit minus bound
						xUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->leftBound) / s;
					}
					else if( shadowArray[i].shadowGroup->rightBound + (xUnitsToMove*s) >= limit )
					{
						xUnitsToMove = (limit - shadowArray[i].shadowGroup->rightBound) / s;
					}
					else
					{
						xUnitsToMove = dx / dxPerUnit * invertXIndex;
					}	

					position.z = shadowArray[i].initialPosition.z + (xUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
					shadowArray[i].position.z = position.z; // set the position

					// moving the Y values
					limit = (numCubesHeight - 1)/2 * s;

					if( shadowArray[i].shadowGroup->topBound + (yUnitsToMove*s) <= -1*limit ) // if the units to move exceeds limit
					{
						// set the units to move equal to limit minus bound
						yUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->topBound) / s;
					}
					else if( shadowArray[i].shadowGroup->bottomBound + (yUnitsToMove*s) >= limit )
					{
						yUnitsToMove = (limit - shadowArray[i].shadowGroup->bottomBound) / s;
					}
					else
					{
						yUnitsToMove = dy / dyPerUnit * invertYIndex;
					}	

					position.y = shadowArray[i].initialPosition.y + (yUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
					shadowArray[i].position.y = position.y; // set the position

					// reverse the reverse for each successive shadow object
					xUnitsToMove *= invertXIndex;
					yUnitsToMove *= invertYIndex;

					break;
				case 4:
					// moving the X values
					// clamp the location based on limit if necessary
					limit = (numCubesWidth - 1)/2 * s;

					if( worldX == 1024 || worldX == -3072 )
					{
						invertXIndex = -1;
					}
					if( worldY == 2048 || worldY == -2048 )
					{
						invertYIndex = -1;
					}

					xUnitsToMove *= invertXIndex;
					yUnitsToMove *= invertYIndex;
					
					if( (shadowArray[i].shadowGroup->leftBound + (xUnitsToMove*s)) >= limit ) // if the units to move exceeds limit
					{
						// set the units to move equal to limit minus bound
						xUnitsToMove = (limit - shadowArray[i].shadowGroup->leftBound) / s;
					}
					else if( shadowArray[i].shadowGroup->rightBound + (xUnitsToMove*s) <= -1* limit )
					{
						xUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->rightBound) / s;
					}
					else
					{
						xUnitsToMove = dx / dxPerUnit * invertXIndex;
					}	

					position.z = shadowArray[i].initialPosition.z + (xUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
					shadowArray[i].position.z = position.z; // set the position

					// moving the Y values
					limit = (numCubesHeight - 1)/2 * s;

					if( shadowArray[i].shadowGroup->topBound + (yUnitsToMove*s) <= -1*limit ) // if the units to move exceeds limit
					{
						// set the units to move equal to limit minus bound
						yUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->topBound) / s;
					}
					else if( shadowArray[i].shadowGroup->bottomBound + (yUnitsToMove*s) >= limit )
					{
						yUnitsToMove = (limit - shadowArray[i].shadowGroup->bottomBound) / s;
					}
					else
					{
						yUnitsToMove = dy / dyPerUnit * invertYIndex;
					}	

					position.y = shadowArray[i].initialPosition.y + (yUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
					shadowArray[i].position.y = position.y; // set the position

					// reverse the reverse for each successive shadow object
					xUnitsToMove *= invertXIndex;
					yUnitsToMove *= invertYIndex;

					break;
				case 5: // case 5 has 4 rotational positions, so it must have 4 variations
					if( worldX == 0 ) // if faceside 1 on bottom
					{
						// moving the X values
						// clamp the location based on limit if necessary
						limit = (numCubesWidth - 1)/2 * s;

						/*
						if( worldX == 1024 || worldX == -3072 )
						{
							invertXIndex = -1;
						}*/

						if( worldY == -1024 || worldY == 3072)
						{
							invertYIndex = -1;
						}
						

						xUnitsToMove *= invertXIndex;
						yUnitsToMove *= invertYIndex;
					
						if( shadowArray[i].shadowGroup->leftBound + (xUnitsToMove*s) <= -1*limit ) // if the units to move exceeds limit
						{
							// set the units to move equal to limit minus bound
							xUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->leftBound) / s;
						}
						else if( shadowArray[i].shadowGroup->rightBound + (xUnitsToMove*s) >= limit )
						{
							xUnitsToMove = (limit - shadowArray[i].shadowGroup->rightBound) / s;
						}
						else
						{
							xUnitsToMove = dx / dxPerUnit * invertXIndex;
						}	

						position.x = shadowArray[i].initialPosition.x + (xUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
						shadowArray[i].position.x = position.x; // set the position

						// moving the Y values
						limit = (numCubesLength - 1)/2 * s;

						if( shadowArray[i].shadowGroup->topBound + (yUnitsToMove*s) >= limit ) // if the units to move exceeds limit
						{
							// set the units to move equal to limit minus bound
							yUnitsToMove = (limit - shadowArray[i].shadowGroup->topBound) / s;
						}
						else if( shadowArray[i].shadowGroup->bottomBound + (yUnitsToMove*s) <= -1*limit )
						{
							yUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->bottomBound) / s;
						}
						else
						{
							yUnitsToMove = dy / dyPerUnit * invertYIndex;
						}	

						position.z = shadowArray[i].initialPosition.z + (yUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
						shadowArray[i].position.z = position.z; // set the position

						// reverse the reverse for each successive shadow object
						xUnitsToMove *= invertXIndex;
						yUnitsToMove *= invertYIndex;
					}
					else if( worldX == 2048 || worldX == -2048  ) // if faceside 3 on bottom
					{
						// moving the X values
						// clamp the location based on limit if necessary
						limit = (numCubesWidth - 1)/2 * s;

						
						if( worldX == 2048 || worldX == -2048 )
						{
							invertXIndex = -1;
						}

						xUnitsToMove *= invertXIndex;
						yUnitsToMove *= invertYIndex;
					
						if( shadowArray[i].shadowGroup->leftBound + (xUnitsToMove*s) <= -1*limit ) // if the units to move exceeds limit
						{
							// set the units to move equal to limit minus bound
							xUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->leftBound) / s;
						}
						else if( shadowArray[i].shadowGroup->rightBound + (xUnitsToMove*s) >= limit )
						{
							xUnitsToMove = (limit - shadowArray[i].shadowGroup->rightBound) / s;
						}
						else
						{
							xUnitsToMove = dx / dxPerUnit * invertXIndex;
						}	

						position.x = shadowArray[i].initialPosition.x + (xUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
						shadowArray[i].position.x = position.x; // set the position

						// moving the Y values
						limit = (numCubesLength - 1)/2 * s;

						if( shadowArray[i].shadowGroup->topBound + (yUnitsToMove*s) >= limit ) // if the units to move exceeds limit
						{
							// set the units to move equal to limit minus bound
							yUnitsToMove = (limit - shadowArray[i].shadowGroup->topBound) / s;
						}
						else if( shadowArray[i].shadowGroup->bottomBound + (yUnitsToMove*s) <= -1*limit )
						{
							yUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->bottomBound) / s;
						}
						else
						{
							yUnitsToMove = dy / dyPerUnit * invertYIndex;
						}	

						position.z = shadowArray[i].initialPosition.z + (yUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
						shadowArray[i].position.z = position.z; // set the position

						// reverse the reverse for each successive shadow object
						xUnitsToMove *= invertXIndex;
						yUnitsToMove *= invertYIndex;
					}
					else if( worldX == -1024 || worldX == 3072  ) // if faceside 2 on bottom
					{
						// moving the X values
						// clamp the location based on limit if necessary
						limit = (numCubesWidth - 1)/2 * s;

						if( worldX == 2048 || worldX == -2048 )
						{
							invertXIndex = -1;
						}
						if( worldY == 1024 || worldY == -3072 )
						{
							invertYIndex = -1;
						}

						xUnitsToMove *= invertXIndex;
						yUnitsToMove *= invertYIndex;
					
						if( shadowArray[i].shadowGroup->bottomBound + (xUnitsToMove*s) <= -1*limit ) // if the units to move exceeds limit
						{
							// set the units to move equal to limit minus bound
							xUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->bottomBound) / s;
						}
						else if( shadowArray[i].shadowGroup->topBound + (xUnitsToMove*s) >= limit )
						{
							xUnitsToMove = (limit - shadowArray[i].shadowGroup->topBound) / s;
						}
						else
						{
							xUnitsToMove = dx / dxPerUnit * invertXIndex;
						}	

						position.z = shadowArray[i].initialPosition.z + (xUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
						shadowArray[i].position.z = position.z; // set the position

						// moving the Y values
						limit = (numCubesLength - 1)/2 * s;

						if( shadowArray[i].shadowGroup->rightBound + (yUnitsToMove*s) >= limit ) // if the units to move exceeds limit
						{
							// set the units to move equal to limit minus bound
							yUnitsToMove = (limit - shadowArray[i].shadowGroup->rightBound) / s;
						}
						else if( shadowArray[i].shadowGroup->leftBound + (yUnitsToMove*s) <= -1*limit )
						{
							yUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->leftBound) / s;
						}
						else
						{
							yUnitsToMove = dy / dyPerUnit * invertYIndex;
						}	

						position.x = shadowArray[i].initialPosition.x + (yUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
						shadowArray[i].position.x = position.x; // set the position

						// reverse the reverse for each successive shadow object
						xUnitsToMove *= invertXIndex;
						yUnitsToMove *= invertYIndex;
					}
					else if( worldX == 1024 || worldX == -3072  ) // if faceside 4 on bottom
					{	
						// moving the X values
						// clamp the location based on limit if necessary
						limit = (numCubesWidth - 1)/2 * s;

						if( worldX == 1024 || worldX == -3072 )
						{
							invertXIndex = -1;
						}
						if( worldY == -1024 || worldY == 3072 )
						{
							invertYIndex = -1;
						}

						xUnitsToMove *= invertXIndex;
						yUnitsToMove *= invertYIndex;
					
						if( shadowArray[i].shadowGroup->bottomBound + (xUnitsToMove*s) <= -1*limit ) // if the units to move exceeds limit
						{
							// set the units to move equal to limit minus bound
							xUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->bottomBound) / s;
						}
						else if( shadowArray[i].shadowGroup->topBound + (xUnitsToMove*s) >= limit )
						{
							xUnitsToMove = (limit - shadowArray[i].shadowGroup->topBound) / s;
						}
						else
						{
							xUnitsToMove = dx / dxPerUnit * invertXIndex;
						}	

						position.z = shadowArray[i].initialPosition.z + (xUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
						shadowArray[i].position.z = position.z; // set the position

						// moving the Y values
						limit = (numCubesLength - 1)/2 * s;

						if( shadowArray[i].shadowGroup->rightBound + (yUnitsToMove*s) >= limit ) // if the units to move exceeds limit
						{
							// set the units to move equal to limit minus bound
							yUnitsToMove = (limit - shadowArray[i].shadowGroup->rightBound) / s;
						}
						else if( shadowArray[i].shadowGroup->leftBound + (yUnitsToMove*s) <= -1*limit )
						{
							yUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->leftBound) / s;
						}
						else
						{
							yUnitsToMove = dy / dyPerUnit * invertYIndex;
						}	

						position.x = shadowArray[i].initialPosition.x + (yUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
						shadowArray[i].position.x = position.x; // set the position

						// reverse the reverse for each successive shadow object
						xUnitsToMove *= invertXIndex;
						yUnitsToMove *= invertYIndex;
					}

					break;

				case 6: // case 6 has 4 rotational positions, so it must have 4 variations
					if( worldX == 0 ) // if faceside 1 on top
					{
						// moving the X values
						// clamp the location based on limit if necessary
						limit = (numCubesWidth - 1)/2 * s;

						if( worldY == 3072 || worldY == -1024 )
						{
							invertYIndex = -1;
						}
						
						xUnitsToMove *= invertXIndex;
						yUnitsToMove *= invertYIndex;
					
						if( shadowArray[i].shadowGroup->leftBound + (xUnitsToMove*s) <= -1*limit ) // if the units to move exceeds limit
						{
							// set the units to move equal to limit minus bound
							xUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->leftBound) / s;
						}
						else if( shadowArray[i].shadowGroup->rightBound + (xUnitsToMove*s) >= limit )
						{
							xUnitsToMove = (limit - shadowArray[i].shadowGroup->rightBound) / s;
						}
						else
						{
							xUnitsToMove = dx / dxPerUnit * invertXIndex;
						}	

						position.x = shadowArray[i].initialPosition.x + (xUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
						shadowArray[i].position.x = position.x; // set the position

						// moving the Y values
						limit = (numCubesLength - 1)/2 * s;

						if( shadowArray[i].shadowGroup->bottomBound + (yUnitsToMove*s) >= limit ) // if the units to move exceeds limit
						{
							// set the units to move equal to limit minus bound
							yUnitsToMove = (limit - shadowArray[i].shadowGroup->bottomBound) / s;
						}
						else if( shadowArray[i].shadowGroup->topBound + (yUnitsToMove*s) <= -1*limit )
						{
							yUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->topBound) / s;
						}
						else
						{
							yUnitsToMove = dy / dyPerUnit * invertYIndex;
						}	

						position.z = shadowArray[i].initialPosition.z + (yUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
						shadowArray[i].position.z = position.z; // set the position

						// reverse the reverse for each successive shadow object
						xUnitsToMove *= invertXIndex;
						yUnitsToMove *= invertYIndex;
					}
					else if( worldX == 2048 || worldX == -2048 ) // if faceside 3 on top
					{
						// moving the X values
						// clamp the location based on limit if necessary
						limit = (numCubesWidth - 1)/2 * s;

						if( worldX == 2048 || worldX == -2048 )
						{
							invertXIndex = -1;
						}

						if( worldY == -3072 || worldY == 1024 )
						{
							invertYIndex = -1;
						}
						
						xUnitsToMove *= invertXIndex;
						yUnitsToMove *= invertYIndex;
					
						if( shadowArray[i].shadowGroup->leftBound + (xUnitsToMove*s) <= -1*limit ) // if the units to move exceeds limit
						{
							// set the units to move equal to limit minus bound
							xUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->leftBound) / s;
						}
						else if( shadowArray[i].shadowGroup->rightBound + (xUnitsToMove*s) >= limit )
						{
							xUnitsToMove = (limit - shadowArray[i].shadowGroup->rightBound) / s;
						}
						else
						{
							xUnitsToMove = dx / dxPerUnit * invertXIndex;
						}	

						position.x = shadowArray[i].initialPosition.x + (xUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
						shadowArray[i].position.x = position.x; // set the position

						// moving the Y values
						limit = (numCubesLength - 1)/2 * s;

						if( shadowArray[i].shadowGroup->bottomBound + (yUnitsToMove*s) >= limit ) // if the units to move exceeds limit
						{
							// set the units to move equal to limit minus bound
							yUnitsToMove = (limit - shadowArray[i].shadowGroup->bottomBound) / s;
						}
						else if( shadowArray[i].shadowGroup->topBound + (yUnitsToMove*s) <= -1*limit )
						{
							yUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->topBound) / s;
						}
						else
						{
							yUnitsToMove = dy / dyPerUnit * invertYIndex;
						}	

						position.z = shadowArray[i].initialPosition.z + (yUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
						shadowArray[i].position.z = position.z; // set the position

						// reverse the reverse for each successive shadow object
						xUnitsToMove *= invertXIndex;
						yUnitsToMove *= invertYIndex;
					}
					else if( worldX == -1024 || worldX == 3072 ) // if faceside 2 on top
					{
						 
						// moving the X values
						// clamp the location based on limit if necessary
						limit = (numCubesWidth - 1)/2 * s;

						/*
						if( worldX == -1024 || worldX == 3072 )
						{
							invertXIndex = -1;
						}
						*/

						if( worldY == -3072 || worldY == 1024 )
						{
							invertYIndex = -1;
						}
						
						xUnitsToMove *= invertXIndex;
						yUnitsToMove *= invertYIndex;
					
						if( shadowArray[i].shadowGroup->topBound + (xUnitsToMove*s) <= -1*limit ) // if the units to move exceeds limit
						{
							// set the units to move equal to limit minus bound
							xUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->topBound) / s;
						}
						else if( shadowArray[i].shadowGroup->bottomBound + (xUnitsToMove*s) >= limit )
						{
							xUnitsToMove = (limit - shadowArray[i].shadowGroup->bottomBound) / s;
						}
						else
						{
							xUnitsToMove = dx / dxPerUnit * invertXIndex;
						}	

						position.z = shadowArray[i].initialPosition.z + (xUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
						shadowArray[i].position.z = position.z; // set the position

						// moving the Y values
						limit = (numCubesLength - 1)/2 * s;

						if( shadowArray[i].shadowGroup->rightBound + (yUnitsToMove*s) >= limit ) // if the units to move exceeds limit
						{
							// set the units to move equal to limit minus bound
							yUnitsToMove = (limit - shadowArray[i].shadowGroup->rightBound) / s;
						}
						else if( shadowArray[i].shadowGroup->leftBound + (yUnitsToMove*s) <= -1*limit )
						{
							yUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->leftBound) / s;
						}
						else
						{
							yUnitsToMove = dy / dyPerUnit * invertYIndex;
						}	

						position.x = shadowArray[i].initialPosition.x + (yUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
						shadowArray[i].position.x = position.x; // set the position

						// reverse the reverse for each successive shadow object
						xUnitsToMove *= invertXIndex;
						yUnitsToMove *= invertYIndex;
					}
					else if( worldX == 1024 || worldX == -3072 ) // if faceside 4 on top
					{
						 
						// moving the X values
						// clamp the location based on limit if necessary
						limit = (numCubesWidth - 1)/2 * s;

						if( worldX == 1024 || worldX == -3072 )
						{
							invertXIndex = -1;
						}
						
						if( worldY == 3072 || worldY == -1024 )
						{
							invertYIndex = -1;
						}
						
						xUnitsToMove *= invertXIndex;
						yUnitsToMove *= invertYIndex;
					
						if( shadowArray[i].shadowGroup->topBound + (xUnitsToMove*s) <= -1*limit ) // if the units to move exceeds limit
						{
							// set the units to move equal to limit minus bound
							xUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->topBound) / s;
						}
						else if( shadowArray[i].shadowGroup->bottomBound + (xUnitsToMove*s) >= limit )
						{
							xUnitsToMove = (limit - shadowArray[i].shadowGroup->bottomBound) / s;
						}
						else
						{
							xUnitsToMove = dx / dxPerUnit * invertXIndex;
						}	

						position.z = shadowArray[i].initialPosition.z + (xUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
						shadowArray[i].position.z = position.z; // set the position

						// moving the Y values
						limit = (numCubesLength - 1)/2 * s;

						if( shadowArray[i].shadowGroup->rightBound + (yUnitsToMove*s) >= limit ) // if the units to move exceeds limit
						{
							// set the units to move equal to limit minus bound
							yUnitsToMove = (limit - shadowArray[i].shadowGroup->rightBound) / s;
						}
						else if( shadowArray[i].shadowGroup->leftBound + (yUnitsToMove*s) <= -1*limit )
						{
							yUnitsToMove = (-1*limit - shadowArray[i].shadowGroup->leftBound) / s;
						}
						else
						{
							yUnitsToMove = dy / dyPerUnit * invertYIndex;
						}	

						position.x = shadowArray[i].initialPosition.x + (yUnitsToMove * s); // final position to move to, uses shadow's initialposition so it does not keep compounding
						shadowArray[i].position.x = position.x; // set the position

						// reverse the reverse for each successive shadow object
						xUnitsToMove *= invertXIndex;
						yUnitsToMove *= invertYIndex;
					}
					break;
				} // end of switch statement for the direction
				// to be deleted
				/*
				printf("leftBound is %d. ", shadowArray[i].shadowGroup->leftBound);
				printf("rightBound is %d. ", shadowArray[i].shadowGroup->rightBound);
				printf("topBound is %d. ", shadowArray[i].shadowGroup->topBound);
				printf("bottomBound is %d. ", shadowArray[i].shadowGroup->bottomBound);
				printf("xUnitsToMove is %d ", xUnitsToMove );
				printf("yUnitsToMove is %d ", yUnitsToMove );*/
			} // end of if the number of sides of cube is odd
			// to be deleted
			//printf("\n");
		} // end of if same direction as active side and drop cubes is not true
	} // end of searching through every shadow

	// DETERMINE IF A SHADOW WAS MOVED for tutorial
	// If it was, return true. This is for Tutorial purposes and has No effect on the actual movement
	if( GameState == PLAY_TUTORIAL )
	{
		if( tutorialNumber == 1 )
		{
			if( abs(xUnitsToMove) > 0 || abs(yUnitsToMove) > 0 )
			{
				tutorialTouchDragPassed = true;
			}
		}
	}
	
} // end of MoveShadows()

void UpdateShadow( Shadow *shadow, int16 index)
{
	//shadow->position = shadow->cube->position; // these should already be set when linking
	//shadow->direction = shadow->cube->direction;

	Cube* cube = shadow->cube;
	
	// sets the shadow's height position depending on faceSide/direction
	switch( shadow->direction )
	{
	case 1: 
		// we don't add an extra sidelength because the center of the shadow is actually the center of a cube
		// The extra -20/+20 makes sure the shadow is rendered in FRONT of the cube 
		if( cube->closestLandingCube != NULL )
			shadow->position.z = cube->closestLandingCube->position.z - 0;
		break;
	case 2:
		if( cube->closestLandingCube != NULL )
			shadow->position.x = cube->closestLandingCube->position.x + 0;
		break;
	case 3:
		if( cube->closestLandingCube != NULL )
			shadow->position.z = cube->closestLandingCube->position.z + 0;
		break;
	case 4:
		if( cube->closestLandingCube != NULL )
			shadow->position.x = cube->closestLandingCube->position.x - 0;
		break;
	case 5:
		if( cube->closestLandingCube != NULL )
			shadow->position.y = cube->closestLandingCube->position.y - 0;
		break;
	case 6:
		if( cube->closestLandingCube != NULL )
			shadow->position.y = cube->closestLandingCube->position.y + 0;
		break;
	}

	// set the vertex stream for rendering
	for( int j = 0; j < 24; j++ )
	{
		shadowVerticesTranslated[index*24 + j] = shadowVertices[index*24 + j] + shadow->position;
		shadowNormals[index*24 + j] = cubeNormals[j];

		shadowVerticesTransparentTranslated[index*24 + j] = shadowVerticesTransparent[index*24 + j] + shadow->position;
	}

	// updates the vertices in shadow for picking
	// copies rotation matrix
	shadow->setModelMatrix( tt1 );
} // end of updateshadow()


// updates the bounds based on the shadows' direction
void UpdateShadowGroupBounds()
{
	ShadowGroup* shadowGroupPointer;
	int16 tempDirection = 0;
	for( int i = 0; i < numShadowsIndex; i++ )
	{
		// initialize pointer to be used
		shadowGroupPointer = shadowArray[i].shadowGroup;

		if( i == 0 || tempDirection != shadowArray[i].direction ) // if i = 0, it is the first iteration of set of shadows, or new set of shadows, initialize direction and bounds
		{
			// initialize direction
			tempDirection = shadowArray[i].direction;

			// initialize the bounds
			switch( tempDirection )
			{
			case 1:
				shadowGroupPointer->topBound = shadowArray[i].position.y;
				shadowGroupPointer->bottomBound = shadowArray[i].position.y;
				shadowGroupPointer->leftBound = shadowArray[i].position.x;
				shadowGroupPointer->rightBound = shadowArray[i].position.x;
				break;
			case 2:
				shadowGroupPointer->topBound = shadowArray[i].position.y;
				shadowGroupPointer->bottomBound = shadowArray[i].position.y;
				shadowGroupPointer->leftBound = shadowArray[i].position.z;
				shadowGroupPointer->rightBound = shadowArray[i].position.z;
				break;
			case 3:
				shadowGroupPointer->topBound = shadowArray[i].position.y;
				shadowGroupPointer->bottomBound = shadowArray[i].position.y;
				shadowGroupPointer->leftBound = shadowArray[i].position.x;
				shadowGroupPointer->rightBound = shadowArray[i].position.x;
				break;
			case 4:
				shadowGroupPointer->topBound = shadowArray[i].position.y;
				shadowGroupPointer->bottomBound = shadowArray[i].position.y;
				shadowGroupPointer->leftBound = shadowArray[i].position.z;
				shadowGroupPointer->rightBound = shadowArray[i].position.z;
				break;
			case 5:
				shadowGroupPointer->topBound = shadowArray[i].position.z;
				shadowGroupPointer->bottomBound = shadowArray[i].position.z;
				shadowGroupPointer->leftBound = shadowArray[i].position.x;
				shadowGroupPointer->rightBound = shadowArray[i].position.x;
				break;
			case 6:
				shadowGroupPointer->topBound = shadowArray[i].position.z;
				shadowGroupPointer->bottomBound = shadowArray[i].position.z;
				shadowGroupPointer->leftBound = shadowArray[i].position.x;
				shadowGroupPointer->rightBound = shadowArray[i].position.x;
				break;
			} // end of switch statement bound initialization 
		} // end of first iteration of i = 0, or of set of shadows
		else // set the bounds based on direction
		{
			// set the bounds
			switch( tempDirection )
			{
			case 1:
				if( shadowArray[i].position.y < shadowGroupPointer->topBound )
					shadowGroupPointer->topBound = shadowArray[i].position.y;
				if( shadowArray[i].position.y > shadowGroupPointer->bottomBound)
					shadowGroupPointer->bottomBound = shadowArray[i].position.y;
				if( shadowArray[i].position.x < shadowGroupPointer->leftBound )
					shadowGroupPointer->leftBound = shadowArray[i].position.x;
				if( shadowArray[i].position.x > shadowGroupPointer->rightBound )
					shadowGroupPointer->rightBound = shadowArray[i].position.x;
				break;
			case 2:
				if( shadowArray[i].position.y < shadowGroupPointer->topBound )
					shadowGroupPointer->topBound = shadowArray[i].position.y;
				if( shadowArray[i].position.y > shadowGroupPointer->bottomBound )
					shadowGroupPointer->bottomBound = shadowArray[i].position.y;
				if( shadowArray[i].position.z < shadowGroupPointer->leftBound )
					shadowGroupPointer->leftBound = shadowArray[i].position.z;
				if( shadowArray[i].position.z > shadowGroupPointer->rightBound )
					shadowGroupPointer->rightBound = shadowArray[i].position.z;
				break;
			case 3:
				if( shadowArray[i].position.y < shadowGroupPointer->topBound )
					shadowGroupPointer->topBound = shadowArray[i].position.y;
				if( shadowArray[i].position.y > shadowGroupPointer->bottomBound )
					shadowGroupPointer->bottomBound = shadowArray[i].position.y;
				if( shadowArray[i].position.x > shadowGroupPointer->leftBound )
					shadowGroupPointer->leftBound = shadowArray[i].position.x;
				if( shadowArray[i].position.x < shadowGroupPointer->rightBound )
					shadowGroupPointer->rightBound = shadowArray[i].position.x;
				break;
			case 4:
				if( shadowArray[i].position.y < shadowGroupPointer->topBound )
					shadowGroupPointer->topBound = shadowArray[i].position.y;
				if( shadowArray[i].position.y > shadowGroupPointer->bottomBound )
					shadowGroupPointer->bottomBound = shadowArray[i].position.y;
				if( shadowArray[i].position.z > shadowGroupPointer->leftBound )
					shadowGroupPointer->leftBound = shadowArray[i].position.z;
				if( shadowArray[i].position.z < shadowGroupPointer->rightBound )
					shadowGroupPointer->rightBound = shadowArray[i].position.z;
				break;
			case 5:
				if( shadowArray[i].position.z > shadowGroupPointer->topBound )
					shadowGroupPointer->topBound = shadowArray[i].position.z;
				if( shadowArray[i].position.z < shadowGroupPointer->bottomBound )
					shadowGroupPointer->bottomBound = shadowArray[i].position.z;
				if( shadowArray[i].position.x < shadowGroupPointer->leftBound )
					shadowGroupPointer->leftBound = shadowArray[i].position.x;
				if( shadowArray[i].position.x > shadowGroupPointer->rightBound )
					shadowGroupPointer->rightBound = shadowArray[i].position.x;
				break;
			case 6:
				if( shadowArray[i].position.z < shadowGroupPointer->topBound )
					shadowGroupPointer->topBound = shadowArray[i].position.z;
				if( shadowArray[i].position.z > shadowGroupPointer->bottomBound )
					shadowGroupPointer->bottomBound = shadowArray[i].position.z;
				if( shadowArray[i].position.x < shadowGroupPointer->leftBound )
					shadowGroupPointer->leftBound = shadowArray[i].position.x;
				if( shadowArray[i].position.x > shadowGroupPointer->rightBound )
					shadowGroupPointer->rightBound = shadowArray[i].position.x;
				break;
			} // end of switch statement for setting bounds
		} // end of else statement for setting bounds
	} // end of for-loop looping through each shadow
}// end of updateshadowgroupbounds()

int16 min( int16 a, int16 b )
{
	if( a < b )
		return a;

	if( b < a )
		return b;

	return 0; // returns 0 if they are equal
}

int16 max( int16 a, int16 b )
{
	if( a > b )
		return a;
	
	if( b > a )
		return b;

	return 0; // return 0 if they are equal
}

void removeShadow( int16 index )
{
	// for adjusting the selected shadow
	bool afterIndex = false;
	int16 selectedShadowPosition = -1;

	// removes shadow from shadow array
	for( int i = index; i < numShadowsIndex; i++ )
	{	
		// for selected shadow
		if( selectedShadow != NULL )
		{
			if( selectedShadow->cube->ID == shadowArray[i].cube->ID )
			{
				afterIndex = true;
			}
		}

		if( i == (numShadowsIndex - 1)) // if it reaches last element, don't do anything. set to null
		{
			if( i == index )
			{
				// check to see if this is the last shadow of direction
				bool lastShadow = true;
				int16 tempDir = shadowArray[i].shadowGroup->direction;
				for( int j = 0; j < numShadowsIndex; j++ )
				{
					int16 dir = shadowArray[j].shadowGroup->direction;

					if( dir == tempDir && j != index ) // if the direction of another shadow's shadowgroup matches this one's
					{
						lastShadow = false;
					}
				}

				if( lastShadow == true ) // if last shadow of group, remove shadowGroup pointer
				{
					delete shadowArray[i].shadowGroup;
					numMovingSets--; // decrement the number of moving sets
				}
			}

			shadowArray[i] = NULL;
			// don't worry about array of vertices
		}
		else
		{
			if( i == index )
			{
				// check to see if this is the last shadow of direction
				bool lastShadow = true;
				int16 tempDir = shadowArray[i].shadowGroup->direction;
				for( int j = 0; j < numShadowsIndex; j++ )
				{
					int16 dir = shadowArray[j].shadowGroup->direction;

					if( dir == tempDir && j != index ) // if the direction of another shadow's shadowgroup matches this one's
					{
						lastShadow = false;
					}
				}

				if( lastShadow == true ) // if last shadow of group, remove shadowGroup pointer
				{
					delete shadowArray[i].shadowGroup;
					numMovingSets--; // decrement the number of moving sets			


				}
			}

			shadowArray[i] = shadowArray[i+1];
			LinkShadowToCube( i );
			for( int j = 0; j < 24; j++ ) // remove the vertices for base vertices and normals
			{
				shadowVertices[i*24 + j] = shadowVertices[(i+1)*24 + j];
				shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparent[(i+1)*24 + j];

				shadowVerticesTranslated[i*24 +j] = shadowVerticesTranslated[(i+1)*24 + j];
				shadowVerticesTransparentTranslated[i*24+j] = shadowVerticesTransparentTranslated[(i+1)*24 + j];

				shadowNormals[i*24 + j] = shadowNormals[(i+1)*24 + j];
				shadowUVStream[i*24 + j] = shadowUVStream[(i+1)*24 + j];
			}
		}
	}

	numShadowsIndex--;

	if( selectedShadow != NULL )
	{
		if( afterIndex )
			selectedShadow--;
		// else, do nothing
	}
}

void removeMovingCube( int16 index )
{
	// copy array from elements index+1 into index
	// set element at numMovingCubesIndex to null
	// decrement counter

	for( int i = index; i < numMovingCubesIndex; i++ )
	{		
		if( i == (numMovingCubesIndex - 1)) // if it reaches last element, don't do anything. set to null
		{
			// no fuzzy is removed b/c it must be preserved for moving to static
			// remove fuzzy in Reset()
			cubeArrayMoving[i] = NULL;
		}
		else
		{
			cubeArrayMoving[i] = cubeArrayMoving[i+1];
		}
	}

	numMovingCubesIndex--;
}

void removeMovingCubeAndTerminate( int16 index )
{
	// copy array from elements index+1 into index
	// set element at numMovingCubesIndex to null
	// decrement counter
	for( int i = index; i < numMovingCubesIndex; i++ )
	{
		if( i == (numMovingCubesIndex - 1)) // if it reaches last element, don't do anything. set to null
		{
			if( i == index ) // if the cube removed is the last element. delete it.
			{
				if( cubeArrayMoving[i].hasFuzzy == true )
				{
					delete cubeArrayMoving[i].fuzzyMaterial;
						
					
					//if( cubeArrayMoving[i].exploded == true ) // this was changed on 12/07/11 to fix memory leak. if game crashes, put this back in
					{
						delete cubeArrayMoving[i].fuzzyExplodeMaterial;
					}
					//printf("deleted an explosion ");

					//delete cubeArray[i].fuzzyMaterial;
					fuzzyCount--;
					//printf("deleted a fuzzy" );				
				}

				if( cubeArrayMoving[i].hasBomb == true )
				{
					cubeArrayMoving[i].bomb.Terminate();
				}
			}
			// otherwise, nothing to delete and just set null
			cubeArrayMoving[i] = NULL;
		}
		else if( i == index )
		{
			if( cubeArrayMoving[i].hasFuzzy == true )
			{
				delete cubeArrayMoving[i].fuzzyMaterial;
				// formerly deleted materials b/c was on cube
				
				delete cubeArrayMoving[i].fuzzyExplodeMaterial;

				/* Now fuzzyExplodeMaterial is removed no matter what b/c it is created when fuzzy is created
				if( cubeArray[i].exploded == true )
				{
					delete cubeArray[i].fuzzyExplodeMaterial;
				}*/
				//printf("deleted an explosion ");

				// delete cubeArray[i].fuzzyMaterial;
				fuzzyCount--;
				//printf("deleted a fuzzy" );
			}

			if( cubeArrayMoving[i].hasBomb == true )
			{
				cubeArrayMoving[i].bomb.Terminate();
			}

			cubeArrayMoving[i] = cubeArrayMoving[i+1];
		}
		else 
		{
			cubeArrayMoving[i] = cubeArrayMoving[i+1];
			//cubeArray[i].fuzzyMaterial = cubeArray[i+1].fuzzyMaterial;
			//cubeArray[i].fuzzyExplodeMaterial = cubeArray[i+1].fuzzyExplodeMaterial;
		}
	}

	numMovingCubesIndex--;
	//printf("deleted a cube \n");
}

void removeStaticCube( int16 index )
{
	// copy array from elements index+1 into index
	// set element at numMovingCubesIndex to null
	// decrement counter
	for( int i = index; i < numStaticCubes; i++ )
	{
		if( i == (numStaticCubes - 1)) // if it reaches last element, don't do anything. set to null
		{
			if( i == index ) // if the cube removed is the last element. delete it.
			{
				if( cubeArray[i].hasFuzzy == true )
				{
					delete cubeArray[i].fuzzyMaterial;
						
					
					//if( cubeArray[i].exploded == true ) // this was changed on 12/07/11 to fix memory leak. if game crashes, put this back in
					{
						delete cubeArray[i].fuzzyExplodeMaterial;
					}
					//printf("deleted an explosion ");

					//delete cubeArray[i].fuzzyMaterial;
					fuzzyCount--;
					//printf("deleted a fuzzy" );				
				}

				if( cubeArray[i].hasBomb == true )
				{
					cubeArray[i].bomb.Terminate();
				}
			}
			// otherwise, nothing to delete and just set null
			cubeArray[i] = NULL;
		}
		else if( i == index )
		{
			if( cubeArray[i].hasFuzzy == true )
			{
				delete cubeArray[i].fuzzyMaterial;
				// formerly deleted materials b/c was on cube
				
				delete cubeArray[i].fuzzyExplodeMaterial;

				/* Now fuzzyExplodeMaterial is removed no matter what b/c it is created when fuzzy is created
				if( cubeArray[i].exploded == true )
				{
					delete cubeArray[i].fuzzyExplodeMaterial;
				}*/
				//printf("deleted an explosion ");

				// delete cubeArray[i].fuzzyMaterial;
				fuzzyCount--;
				//printf("deleted a fuzzy" );
			}

			if( cubeArray[i].hasBomb == true )
			{
				cubeArray[i].bomb.Terminate();
			}

			cubeArray[i] = cubeArray[i+1];
		}
		else 
		{
			cubeArray[i] = cubeArray[i+1];
			//cubeArray[i].fuzzyMaterial = cubeArray[i+1].fuzzyMaterial;
			//cubeArray[i].fuzzyExplodeMaterial = cubeArray[i+1].fuzzyExplodeMaterial;
		}
	}

	numStaticCubes--;
	//printf("deleted a cube \n");
}

// drops all the cubes
void dropCubes()
{
	for( int i = 0; i < numShadowsIndex; i++ )
	{
		if( shadowArray[i].shadowGroup->dropCubes == true  && shadowArray[i].shadowGroup->dropCubesSlow == false ) // if the shadow is supposed to be falling
		{			
			shadowArray[i].cube->speed = 24000;
		}
	}

}

void dropCubesSlow()
{
	for( int i = 0; i < numShadowsIndex; i++ )
	{
		if( shadowArray[i].shadowGroup->dropCubesSlow == true ) // if the shadow is supposed to be falling
		{			
			shadowArray[i].cube->speed = 6000;
		}
	}
}

void UntouchShadows()
{
	shadowIsTouched = false;

	// untouch all shadows
	for( int i = 0; i < numShadowsIndex; i++ )
	{
		shadowArray[i].touched = false;

		// set all bounds
		// When calculating how the shadow moves and creating the bounds, it is based on the shadow's initial position
		// Thus if the shadow's initial position changes after every untouch, the bounds must also be changed.
		CIwSVec3 deltaDistance = shadowArray[i].position - shadowArray[i].initialPosition;
		
		switch( shadowArray[i].shadowGroup->direction )
		{
		case 1:
			if( shadowArray[i].shadowGroup->updatedBounds == false )
			{
				shadowArray[i].shadowGroup->topBound += deltaDistance.y;
				shadowArray[i].shadowGroup->bottomBound += deltaDistance.y;
				shadowArray[i].shadowGroup->leftBound += deltaDistance.x;
				shadowArray[i].shadowGroup->rightBound += deltaDistance.x;
				shadowArray[i].shadowGroup->updatedBounds = true; // ensures that this happens only once b/c a set of shadows use only ONE shadow group
			}
			break;
		case 2:
			if( shadowArray[i].shadowGroup->updatedBounds == false )
			{
				shadowArray[i].shadowGroup->topBound += deltaDistance.y;
				shadowArray[i].shadowGroup->bottomBound += deltaDistance.y;
				shadowArray[i].shadowGroup->leftBound += deltaDistance.z;
				shadowArray[i].shadowGroup->rightBound += deltaDistance.z;
				shadowArray[i].shadowGroup->updatedBounds = true; // ensures that this happens only once
			}
			break;
		case 3:
			if( shadowArray[i].shadowGroup->updatedBounds == false )
			{
				shadowArray[i].shadowGroup->topBound += deltaDistance.y;
				shadowArray[i].shadowGroup->bottomBound += deltaDistance.y;
				shadowArray[i].shadowGroup->leftBound += deltaDistance.x;
				shadowArray[i].shadowGroup->rightBound += deltaDistance.x;
				shadowArray[i].shadowGroup->updatedBounds = true; // ensures that this happens only once
			}
			break;
		case 4:
			if( shadowArray[i].shadowGroup->updatedBounds == false )
			{
				shadowArray[i].shadowGroup->topBound += deltaDistance.y;
				shadowArray[i].shadowGroup->bottomBound += deltaDistance.y;
				shadowArray[i].shadowGroup->leftBound += deltaDistance.z;
				shadowArray[i].shadowGroup->rightBound += deltaDistance.z;
				shadowArray[i].shadowGroup->updatedBounds = true; // ensures that this happens only once
			}
			break;
		case 5:
			if( shadowArray[i].shadowGroup->updatedBounds == false )
			{
				shadowArray[i].shadowGroup->topBound += deltaDistance.z;
				shadowArray[i].shadowGroup->bottomBound += deltaDistance.z;
				shadowArray[i].shadowGroup->leftBound += deltaDistance.x;
				shadowArray[i].shadowGroup->rightBound += deltaDistance.x;
				shadowArray[i].shadowGroup->updatedBounds = true; // ensures that this happens only once
			}
			break;
		case 6:
			if( shadowArray[i].shadowGroup->updatedBounds == false )
			{
				shadowArray[i].shadowGroup->topBound += deltaDistance.z;
				shadowArray[i].shadowGroup->bottomBound += deltaDistance.z;
				shadowArray[i].shadowGroup->leftBound += deltaDistance.x;
				shadowArray[i].shadowGroup->rightBound += deltaDistance.x;
				shadowArray[i].shadowGroup->updatedBounds = true; // ensures that this happens only once
			}
			break;
		}
			
		// set all initial positions
		shadowArray[i].initialPosition = shadowArray[i].position;
	}
	selectedShadow = NULL;
	// reset bounds update boolean
	for( int i = 0; i < numShadowsIndex; i++ )
		shadowArray[i].shadowGroup->updatedBounds = false;
}


// CREATE VERTEX STREAM
void CreateVertexStream()
{	
	// In this method: create vertex stream for movingToStatic, moving, and also shadows

	// the numStaticCubes includes the original static cubes as well as moving cubes turned into static.
	// the originalCube set is just the original static.
	numLandedCubes = numStaticCubes - numOriginalCubes;

	blueSolidIndex = 0; // reset the indexes b/c these are recalculated each update() iteration
	greenSolidIndex = 0;
	orangeSolidIndex = 0;
	purpleSolidIndex = 0;
	redSolidIndex = 0;
	yellowSolidIndex = 0;

	blueTransIndex = 0; // reset the indexes b/c these are recalculated each update() iteration
	greenTransIndex = 0;
	orangeTransIndex = 0;
	purpleTransIndex = 0;
	redTransIndex = 0;
	yellowTransIndex = 0;

	for( int i = 0; i < 6; i++ )
	{
		warpingMaterialIndex[i] = 0;
		explodingMaterialIndex[i] = 0;
	}

	// update the vertex streams before separating into materials
	for( int i = numOriginalCubes; i < numStaticCubes; i++ )
	{
		for( int j = 0; j < 24; j++ )
		{			
			cubeTranslated2[i*24 + j] = cubeVertices2[i*24+j] + cubeArray[i].position;
		}		
	}

	for( int i = 0; i < numMovingCubesIndex; i++ )
	{
		for( int j = 0; j < 24; j++ )
		{
			cubeMovingTranslated2[i*24 + j] = cubeMovingVertices2[i*24+j] + cubeArrayMoving[i].position;
		}
	}

	// Create vertex stream for movingToStatic cubes, aka the "landed cubes," for rendering
	for( int i = numOriginalCubes; i < numStaticCubes; i++ )
	{
		int16 dir = 0;

		switch( cubeArray[i].material )
		{
		case Cube::SOLID_BLUE:
			for( int j = 0; j < 24; j++ )
			{
				blueSolidVertices[blueSolidIndex*24 + j] = cubeTranslated2[(i)*24 + j];
				blueSolidUVStream[blueSolidIndex*24 + j] = uvstream_base[j];
			}
			blueSolidIndex++;
			break;
		case Cube::SOLID_GREEN:
			for( int j = 0; j < 24; j++ )
			{
				greenSolidVertices[greenSolidIndex*24 + j] = cubeTranslated2[(i)*24 + j];
				greenSolidUVStream[greenSolidIndex*24 + j] = uvstream_base[j];
			}
			greenSolidIndex++;
			break;
		case Cube::SOLID_ORANGE:
			for( int j = 0; j < 24; j++ )
			{
				orangeSolidVertices[orangeSolidIndex*24 + j] = cubeTranslated2[(i)*24 + j];
				orangeSolidUVStream[orangeSolidIndex*24 + j] = uvstream_base[j];
			}
			orangeSolidIndex++;
			break;
		case Cube::SOLID_PURPLE:
			for( int j = 0; j < 24; j++ )
			{
				purpleSolidVertices[purpleSolidIndex*24 + j] = cubeTranslated2[(i)*24 + j];
				purpleSolidUVStream[purpleSolidIndex*24 + j] = uvstream_base[j];
			}
			purpleSolidIndex++;
			break;
		case Cube::SOLID_RED:
			for( int j = 0; j < 24; j++ )
			{
				redSolidVertices[redSolidIndex*24 + j] = cubeTranslated2[(i)*24 + j];
				redSolidUVStream[redSolidIndex*24 + j] = uvstream_base[j];
			}
			redSolidIndex++;
			break;
		case Cube::SOLID_YELLOW:
			for( int j = 0; j < 24; j++ )
			{
				yellowSolidVertices[yellowSolidIndex*24 + j] = cubeTranslated2[(i)*24 + j];
				yellowSolidUVStream[yellowSolidIndex*24 + j] = uvstream_base[j];
			}
			yellowSolidIndex++;
			break;
			case Cube::TRANS_BLUE:
			for( int j = 0; j < 24; j++ )
			{
				blueTransVertices[blueTransIndex*24 + j] = cubeTranslated2[(i)*24 + j];
				blueTransUVStream[blueTransIndex*24 + j] = uvstream_base[j];
			}
			blueTransIndex++;
			break;
		case Cube::TRANS_GREEN:
			for( int j = 0; j < 24; j++ )
			{
				greenTransVertices[greenTransIndex*24 + j] = cubeTranslated2[(i)*24 + j];
				greenTransUVStream[greenTransIndex*24 + j] = uvstream_base[j];
			}
			greenTransIndex++;
			break;
		case Cube::TRANS_ORANGE:
			for( int j = 0; j < 24; j++ )
			{
				orangeTransVertices[orangeTransIndex*24 + j] = cubeTranslated2[(i)*24 + j];
				orangeTransUVStream[orangeTransIndex*24 + j] = uvstream_base[j];
			}
			orangeTransIndex++;
			break;
		case Cube::TRANS_PURPLE:
			for( int j = 0; j < 24; j++ )
			{
				purpleTransVertices[purpleTransIndex*24 + j] = cubeTranslated2[(i)*24 + j];
				purpleTransUVStream[purpleTransIndex*24 + j] = uvstream_base[j];
			}
			purpleTransIndex++;
			break;
		case Cube::TRANS_RED:
			for( int j = 0; j < 24; j++ )
			{
				redTransVertices[redTransIndex*24 + j] = cubeTranslated2[(i)*24 + j];
				redTransUVStream[redTransIndex*24 + j] = uvstream_base[j];
			}
			redTransIndex++;
			break;
		case Cube::TRANS_YELLOW:
			for( int j = 0; j < 24; j++ )
			{
				yellowTransVertices[yellowTransIndex*24 + j] = cubeTranslated2[(i)*24 + j];
				yellowTransUVStream[yellowTransIndex*24 + j] = uvstream_base[j];
			}
			yellowTransIndex++;
			break;
		case Cube::WARPING_MATERIAL:   // add the cube's vertex to the warping material stream that corresponds to the plane direction/cube's faceside
			dir = cubeArray[i].direction;

			dir = dir - 1; // subtract 1 from the direction to correspond to the warpingMaterial index positions
			for( int j = 0; j < 24; j++ )
			{
				warpingMaterialVertexStream[dir][warpingMaterialIndex[dir]*24 + j] = cubeTranslated2[(i)*24 + j];
				warpingMaterialUVStream[dir][warpingMaterialIndex[dir]*24 + j] = uvstream_base[j];
			}

			warpingMaterialIndex[dir]++;

			// set the warping material color intensity
			// find the plane that is of same side as the cube
			for( int j = 0; j < 6; j++ )
			{
				if( plane[j].direction == cubeArray[i].direction )
				{
					warpingMaterialIntensity[j] = plane[j].warpingMaterialIntensity;
				}
			}
			break;			
		case Cube::EXPLODING_MATERIAL:
			dir = cubeArray[i].direction;

			dir = dir - 1; // subtract 1 from the direction to correspond to the warpingMaterial index positions
			for( int j = 0; j < 24; j++ )
			{
				explodingMaterialVertexStream[dir][explodingMaterialIndex[dir]*24 + j] = cubeTranslated2[(i)*24 + j];
				explodingMaterialUVStream[dir][explodingMaterialIndex[dir]*24 + j] = uvstream_base[j];
			}

			if( cubeArray[i].exploding == true )
				explodingMaterialIndex[dir]++;

			//exploding material intensity already set

			break;
		} // end of switch for adding vertices for a cube
	}

	// create vertex stream for moving cubes
	for( int i = 0; i < numMovingCubesIndex; i++ )
	{
		switch( cubeArrayMoving[i].material )
		{
		case Cube::SOLID_BLUE:
		case Cube::TRANS_BLUE:
			for( int j = 0; j < 24; j++ )
			{
				blueTransVertices[blueTransIndex*24 + j] = cubeMovingTranslated2[(i)*24 + j];
				blueTransUVStream[blueTransIndex*24 + j] = uvstream_base[j];
			}
			blueTransIndex++;
			break;
		case Cube::SOLID_GREEN:
		case Cube::TRANS_GREEN:
			for( int j = 0; j < 24; j++ )
			{
				greenTransVertices[greenTransIndex*24 + j] = cubeMovingTranslated2[(i)*24 + j];
				greenTransUVStream[greenTransIndex*24 + j] = uvstream_base[j];
			}
			greenTransIndex++;
			break;
		case Cube::SOLID_ORANGE:
		case Cube::TRANS_ORANGE:
			for( int j = 0; j < 24; j++ )
			{
				orangeTransVertices[orangeTransIndex*24 + j] = cubeMovingTranslated2[(i)*24 + j];
				orangeTransUVStream[orangeTransIndex*24 + j] = uvstream_base[j];
			}
			orangeTransIndex++;
			break;
		case Cube::SOLID_PURPLE:
		case Cube::TRANS_PURPLE:
			for( int j = 0; j < 24; j++ )
			{
				purpleTransVertices[purpleTransIndex*24 + j] = cubeMovingTranslated2[(i)*24 + j];
				purpleTransUVStream[purpleTransIndex*24 + j] = uvstream_base[j];
			}
			purpleTransIndex++;
			break;
		case Cube::SOLID_RED:
		case Cube::TRANS_RED:
			for( int j = 0; j < 24; j++ )
			{
				redTransVertices[redTransIndex*24 + j] = cubeMovingTranslated2[(i)*24 + j];
				redTransUVStream[redTransIndex*24 + j] = uvstream_base[j];
			}
			redTransIndex++;
			break;
		case Cube::SOLID_YELLOW:
		case Cube::TRANS_YELLOW:
			for( int j = 0; j < 24; j++ )
			{
				yellowTransVertices[yellowTransIndex*24 + j] = cubeMovingTranslated2[(i)*24 + j];
				yellowTransUVStream[yellowTransIndex*24 + j] = uvstream_base[j];
			}
			yellowTransIndex++;
			break;
		} // end of switch statement for adding vertices of a cube
	}
}

// CREATE SHADOW VERTEX STREAM
void CreateShadowVertexStream()
{
	blueSolidShadowIndex = 0; // reset the indexes b/c these are recalculated each update() iteration
	greenSolidShadowIndex = 0;
	orangeSolidShadowIndex = 0;
	purpleSolidShadowIndex = 0;
	redSolidShadowIndex = 0;
	yellowSolidShadowIndex = 0;

	for( int i = 0; i < numMovingCubesIndex; i++ )
	{
		// checks the material of the shadow's connected cube to determine material of shadow when rendering
		// since shadows and moving cubes are linked with same indexes, we can use the shadowIndex on the cube array
		switch( cubeArrayMoving[i].material ) 
		{
		case Cube::SOLID_BLUE:
		case Cube::TRANS_BLUE:
			for( int j = 0; j < 24; j++ )
			{
				blueSolidShadowVertices[blueSolidShadowIndex*24 + j] = shadowVerticesTranslated[i*24 + j];
				blueSolidShadowNormals[blueSolidShadowIndex*24 + j] = shadowNormals[j];			

				blueTransShadowVertices[blueSolidShadowIndex*24 + j] = shadowVerticesTransparentTranslated[i*24+j];
			}
			blueSolidShadowIndex++;
			break;
		case Cube::SOLID_GREEN:
		case Cube::TRANS_GREEN:
			for( int j = 0; j < 24; j++ )
			{
				greenSolidShadowVertices[greenSolidShadowIndex*24 + j] = shadowVerticesTranslated[i*24 + j];
				greenSolidShadowNormals[greenSolidShadowIndex*24 + j] = shadowNormals[j];

				greenTransShadowVertices[greenSolidShadowIndex*24 + j] = shadowVerticesTransparentTranslated[i*24+j];
			}
			greenSolidShadowIndex++;
			break;
		case Cube::SOLID_ORANGE:
		case Cube::TRANS_ORANGE:
			for( int j = 0; j < 24; j++ )
			{
				orangeSolidShadowVertices[orangeSolidShadowIndex*24 + j] = shadowVerticesTranslated[i*24 + j];
				orangeSolidShadowNormals[orangeSolidShadowIndex*24 + j] = shadowNormals[j];

				orangeTransShadowVertices[orangeSolidShadowIndex*24 + j] = shadowVerticesTransparentTranslated[i*24+j];
			}
			orangeSolidShadowIndex++;
			break;
		case Cube::SOLID_PURPLE:
		case Cube::TRANS_PURPLE:
			for( int j = 0; j < 24; j++ )
			{
				purpleSolidShadowVertices[purpleSolidShadowIndex*24 + j] = shadowVerticesTranslated[i*24 + j];
				purpleSolidShadowNormals[purpleSolidShadowIndex*24 + j] = shadowNormals[j];

				purpleTransShadowVertices[purpleSolidShadowIndex*24 + j] = shadowVerticesTransparentTranslated[i*24+j];
			}
			purpleSolidShadowIndex++;
			break;
		case Cube::SOLID_RED:
		case Cube::TRANS_RED:
			for( int j = 0; j < 24; j++ )
			{
				redSolidShadowVertices[redSolidShadowIndex*24 + j] = shadowVerticesTranslated[i*24 + j];
				redSolidShadowNormals[redSolidShadowIndex*24 + j] = shadowNormals[j];

				redTransShadowVertices[redSolidShadowIndex*24 + j] = shadowVerticesTransparentTranslated[i*24+j];
			}
			redSolidShadowIndex++;
			break;
		case Cube::SOLID_YELLOW:
		case Cube::TRANS_YELLOW:
			for( int j = 0; j < 24; j++ )
			{
				yellowSolidShadowVertices[yellowSolidShadowIndex*24 + j] = shadowVerticesTranslated[i*24 + j];
				yellowSolidShadowNormals[yellowSolidShadowIndex*24 + j] = shadowNormals[j];

				yellowTransShadowVertices[yellowSolidShadowIndex*24 + j] = shadowVerticesTransparentTranslated[i*24+j];
			}
			yellowSolidShadowIndex++;
			break;
		} // end of switch statement for adding vertices of a shadow


		// BLINKING SPEED of the shadows
		if( INITIAL_SPEED <= 200 )
		{
			if( cubeArrayMoving[i].speed >= 2400 )
			{
				if( cubeArrayMoving[i].color == Cube::BLUE )	// BLUE
				{
					blueSolidIntensityIncrement = 48;
				}
				else if( cubeArrayMoving[i].color == Cube::RED )	// RED
				{
					redSolidIntensityIncrement = 48;
				}
				else if( cubeArrayMoving[i].color == Cube::GREEN )	// GREEN
				{
					greenSolidIntensityIncrement = 48;
				}
				else if( cubeArrayMoving[i].color == Cube::YELLOW )	// YELLOW
				{
					yellowSolidIntensityIncrement = 48;
				}
				else if( cubeArrayMoving[i].color == Cube::ORANGE )	// ORANGE
				{
					orangeSolidIntensityIncrement = 48;
				}
				else if( cubeArrayMoving[i].color == Cube::PURPLE )	// PURPLE
				{
					purpleSolidIntensityIncrement = 24;
				}
			}
			else if( cubeArrayMoving[i].color == Cube::BLUE )	// BLUE
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					blueSolidIntensityIncrement = 24;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					blueSolidIntensityIncrement = 12;
				else //if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					blueSolidIntensityIncrement = 3;
			}
			else if( cubeArrayMoving[i].color == Cube::RED )	// RED
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					redSolidIntensityIncrement = 24;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					redSolidIntensityIncrement = 12;
				else //if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					redSolidIntensityIncrement = 3;
			}
			else if( cubeArrayMoving[i].color == Cube::GREEN )	// GREEN
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					greenSolidIntensityIncrement = 24;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					greenSolidIntensityIncrement = 12;
				else //if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					greenSolidIntensityIncrement = 3;
			}
			else if( cubeArrayMoving[i].color == Cube::YELLOW )	// YELLOW
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					yellowSolidIntensityIncrement = 24;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					yellowSolidIntensityIncrement = 12;
				else //if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					yellowSolidIntensityIncrement = 3;
			}
			else if( cubeArrayMoving[i].color == Cube::ORANGE )	// ORANGE
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					orangeSolidIntensityIncrement = 24;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					orangeSolidIntensityIncrement = 12;
				else //if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					orangeSolidIntensityIncrement = 3;
			}
			else if( cubeArrayMoving[i].color == Cube::PURPLE )	// PURPLE
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					purpleSolidIntensityIncrement = 24;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					purpleSolidIntensityIncrement = 12;
				else //if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					purpleSolidIntensityIncrement = 3;
			}
		} // end of if initial speed <= 200 
		else if( INITIAL_SPEED <= 400 )
		{
			if( cubeArrayMoving[i].speed >= 2400 )
			{
				if( cubeArrayMoving[i].color == Cube::BLUE )	// BLUE
				{
					blueSolidIntensityIncrement = 48;
				}
				else if( cubeArrayMoving[i].color == Cube::RED )	// RED
				{
					redSolidIntensityIncrement = 48;
				}
				else if( cubeArrayMoving[i].color == Cube::GREEN )	// GREEN
				{
					greenSolidIntensityIncrement = 48;
				}
				else if( cubeArrayMoving[i].color == Cube::YELLOW )	// YELLOW
				{
					yellowSolidIntensityIncrement = 48;
				}
				else if( cubeArrayMoving[i].color == Cube::ORANGE )	// ORANGE
				{
					orangeSolidIntensityIncrement = 48;
				}
				else if( cubeArrayMoving[i].color == Cube::PURPLE )	// PURPLE
				{
					purpleSolidIntensityIncrement = 48;
				}
			}
			else if( cubeArrayMoving[i].color == Cube::BLUE )	// BLUE
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					blueSolidIntensityIncrement = 48;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					blueSolidIntensityIncrement = 24;
				else //if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					blueSolidIntensityIncrement = 6;
			}
			else if( cubeArrayMoving[i].color == Cube::RED )	// RED
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					redSolidIntensityIncrement = 48;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					redSolidIntensityIncrement = 24;
				else //if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					redSolidIntensityIncrement = 6;
			}
			else if( cubeArrayMoving[i].color == Cube::GREEN )	// GREEN
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					greenSolidIntensityIncrement = 48;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					greenSolidIntensityIncrement = 24;
				else //if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					greenSolidIntensityIncrement = 6;
			}
			else if( cubeArrayMoving[i].color == Cube::YELLOW )	// YELLOW
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					yellowSolidIntensityIncrement = 48;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					yellowSolidIntensityIncrement = 24;
				else //if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					yellowSolidIntensityIncrement = 6;
			}
			else if( cubeArrayMoving[i].color == Cube::ORANGE )	// ORANGE
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					orangeSolidIntensityIncrement = 48;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					orangeSolidIntensityIncrement = 24;
				else //if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					orangeSolidIntensityIncrement = 6;
			}
			else if( cubeArrayMoving[i].color == Cube::PURPLE )	// PURPLE
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					purpleSolidIntensityIncrement = 48;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					purpleSolidIntensityIncrement = 24;
				else //if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					purpleSolidIntensityIncrement = 6;
			}
		} // end of if initial_speed <= 400
		else if( INITIAL_SPEED <= 600 || INITIAL_SPEED >= 600 )
		{
			if( cubeArrayMoving[i].speed >= 2400 )
			{
				if( cubeArrayMoving[i].color == Cube::BLUE )	// BLUE
				{
					blueSolidIntensityIncrement = 72;
				}
				else if( cubeArrayMoving[i].color == Cube::RED )	// RED
				{
					redSolidIntensityIncrement = 72;
				}
				else if( cubeArrayMoving[i].color == Cube::GREEN )	// GREEN
				{
					greenSolidIntensityIncrement = 72;
				}
				else if( cubeArrayMoving[i].color == Cube::YELLOW )	// YELLOW
				{
					yellowSolidIntensityIncrement = 72;
				}
				else if( cubeArrayMoving[i].color == Cube::ORANGE )	// ORANGE
				{
					orangeSolidIntensityIncrement = 72;
				}
				else if( cubeArrayMoving[i].color == Cube::PURPLE )	// PURPLE
				{
					purpleSolidIntensityIncrement = 72;
				}
			}
			else if( cubeArrayMoving[i].color == Cube::BLUE )	// BLUE
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					blueSolidIntensityIncrement = 54; // used to be 72
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					blueSolidIntensityIncrement = 24;
				else //if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					blueSolidIntensityIncrement = 9;
			}
			else if( cubeArrayMoving[i].color == Cube::RED )	// RED
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					redSolidIntensityIncrement = 54;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					redSolidIntensityIncrement = 24;
				else //if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					redSolidIntensityIncrement = 9;
			}
			else if( cubeArrayMoving[i].color == Cube::GREEN )	// GREEN
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					greenSolidIntensityIncrement = 54;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					greenSolidIntensityIncrement = 24;
				else //if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					greenSolidIntensityIncrement = 9;
			}
			else if( cubeArrayMoving[i].color == Cube::YELLOW )	// YELLOW
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					yellowSolidIntensityIncrement = 54;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					yellowSolidIntensityIncrement = 24;
				else //if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					yellowSolidIntensityIncrement = 9;
			}
			else if( cubeArrayMoving[i].color == Cube::ORANGE )	// ORANGE
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					orangeSolidIntensityIncrement = 54;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					orangeSolidIntensityIncrement = 24;
				else //if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					orangeSolidIntensityIncrement = 9;
			}
			else if( cubeArrayMoving[i].color == Cube::PURPLE )	// PURPLE
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					purpleSolidIntensityIncrement = 54;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					purpleSolidIntensityIncrement = 24;
				else //if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					purpleSolidIntensityIncrement = 9;
			}
		} // end of if initial speed <= 600 
		else if( INITIAL_SPEED <= 800 )
		{
			if( cubeArrayMoving[i].speed >= 2400 )
			{
				if( cubeArrayMoving[i].color == Cube::BLUE )	// BLUE
				{
					blueSolidIntensityIncrement = 96;
				}
				else if( cubeArrayMoving[i].color == Cube::RED )	// RED
				{
					redSolidIntensityIncrement = 96;
				}
				else if( cubeArrayMoving[i].color == Cube::GREEN )	// GREEN
				{
					greenSolidIntensityIncrement = 96;
				}
				else if( cubeArrayMoving[i].color == Cube::YELLOW )	// YELLOW
				{
					yellowSolidIntensityIncrement = 96;
				}
				else if( cubeArrayMoving[i].color == Cube::ORANGE )	// ORANGE
				{
					orangeSolidIntensityIncrement = 96;
				}
				else if( cubeArrayMoving[i].color == Cube::PURPLE )	// PURPLE
				{
					purpleSolidIntensityIncrement = 96;
				}
			}
			else if( cubeArrayMoving[i].color == Cube::BLUE )	// BLUE
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					blueSolidIntensityIncrement = 96;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					blueSolidIntensityIncrement = 48;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					blueSolidIntensityIncrement = 12;
			}
			else if( cubeArrayMoving[i].color == Cube::RED )	// RED
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					redSolidIntensityIncrement = 96;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					redSolidIntensityIncrement = 48;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					redSolidIntensityIncrement = 12;
			}
			else if( cubeArrayMoving[i].color == Cube::GREEN )	// GREEN
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					greenSolidIntensityIncrement = 96;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					greenSolidIntensityIncrement = 48;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					greenSolidIntensityIncrement = 12;
			}
			else if( cubeArrayMoving[i].color == Cube::YELLOW )	// YELLOW
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					yellowSolidIntensityIncrement = 96;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					yellowSolidIntensityIncrement = 48;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					yellowSolidIntensityIncrement = 12;
			}
			else if( cubeArrayMoving[i].color == Cube::ORANGE )	// ORANGE
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					orangeSolidIntensityIncrement = 96;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					orangeSolidIntensityIncrement = 48;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					orangeSolidIntensityIncrement = 12;
			}
			else if( cubeArrayMoving[i].color == Cube::PURPLE )	// PURPLE
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					purpleSolidIntensityIncrement = 96;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					purpleSolidIntensityIncrement = 48;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					purpleSolidIntensityIncrement = 12;
			}
		} // end of if initial speed <= 800
		else
		{
			if( cubeArrayMoving[i].speed >= 2400 )
			{
				if( cubeArrayMoving[i].color == Cube::BLUE )	// BLUE
				{
					blueSolidIntensityIncrement = 120;
				}
				else if( cubeArrayMoving[i].color == Cube::RED )	// RED
				{
					redSolidIntensityIncrement = 120;
				}
				else if( cubeArrayMoving[i].color == Cube::GREEN )	// GREEN
				{
					greenSolidIntensityIncrement = 120;
				}
				else if( cubeArrayMoving[i].color == Cube::YELLOW )	// YELLOW
				{
					yellowSolidIntensityIncrement = 120;
				}
				else if( cubeArrayMoving[i].color == Cube::ORANGE )	// ORANGE
				{
					orangeSolidIntensityIncrement = 120;
				}
				else if( cubeArrayMoving[i].color == Cube::PURPLE )	// PURPLE
				{
					purpleSolidIntensityIncrement = 120;
				}
			}
			else if( cubeArrayMoving[i].color == Cube::BLUE )	// BLUE
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					blueSolidIntensityIncrement = 120;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					blueSolidIntensityIncrement = 60;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					blueSolidIntensityIncrement = 15;
			}
			else if( cubeArrayMoving[i].color == Cube::RED )	// RED
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					redSolidIntensityIncrement = 120;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					redSolidIntensityIncrement = 60;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					redSolidIntensityIncrement = 15;
			}
			else if( cubeArrayMoving[i].color == Cube::GREEN )	// GREEN
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					greenSolidIntensityIncrement = 120;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					greenSolidIntensityIncrement = 60;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					greenSolidIntensityIncrement = 15;
			}
			else if( cubeArrayMoving[i].color == Cube::YELLOW )	// YELLOW
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					yellowSolidIntensityIncrement = 120;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					yellowSolidIntensityIncrement = 60;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					yellowSolidIntensityIncrement = 15;
			}
			else if( cubeArrayMoving[i].color == Cube::ORANGE )	// ORANGE
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					orangeSolidIntensityIncrement = 120;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					orangeSolidIntensityIncrement = 60;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					orangeSolidIntensityIncrement = 15;
			}
			else if( cubeArrayMoving[i].color == Cube::PURPLE )	// PURPLE
			{
				if( cubeArrayMoving[i].distanceToLanding <= s * 5 )
					purpleSolidIntensityIncrement = 120;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 10 )
					purpleSolidIntensityIncrement = 60;
				else if( cubeArrayMoving[i].distanceToLanding <= s * 16 )
					purpleSolidIntensityIncrement = 15;
			}
		}


		// obsolete. need to be standardized for all levels and diff.
		/*
		if( levelNumber == 1 || levelNumber == 2 )
		{
			if( cubeArrayMoving[i].speed >= 2400 )
			{
				if( cubeArrayMoving[i].color == Cube::BLUE )	// BLUE
				{
					blueSolidIntensityIncrement = 48;
				}
				else if( cubeArrayMoving[i].color == Cube::RED )	// RED
				{
					redSolidIntensityIncrement = 48;
				}
				else if( cubeArrayMoving[i].color == Cube::GREEN )	// GREEN
				{
					greenSolidIntensityIncrement = 48;
				}
				else if( cubeArrayMoving[i].color == Cube::YELLOW )	// YELLOW
				{
					yellowSolidIntensityIncrement = 48;
				}
				else if( cubeArrayMoving[i].color == Cube::ORANGE )	// ORANGE
				{
					orangeSolidIntensityIncrement = 48;
				}
				else if( cubeArrayMoving[i].color == Cube::PURPLE )	// PURPLE
				{
					purpleSolidIntensityIncrement = 48;
				}
			}
			else if( cubeArrayMoving[i].speed >= 1600 )
			{
				if( cubeArrayMoving[i].color == Cube::BLUE )	// BLUE
				{
					blueSolidIntensityIncrement = 24;
				}
				else if( cubeArrayMoving[i].color == Cube::RED )	// RED
				{
					redSolidIntensityIncrement = 24;
				}
				else if( cubeArrayMoving[i].color == Cube::GREEN )	// GREEN
				{
					greenSolidIntensityIncrement = 24;
				}
				else if( cubeArrayMoving[i].color == Cube::YELLOW )	// YELLOW
				{
					yellowSolidIntensityIncrement = 24;
				}
				else if( cubeArrayMoving[i].color == Cube::ORANGE )	// ORANGE
				{
					orangeSolidIntensityIncrement = 24;
				}
				else if( cubeArrayMoving[i].color == Cube::PURPLE )	// PURPLE
				{
					purpleSolidIntensityIncrement = 24;
				}
			}
			else if( cubeArrayMoving[i].speed >= 600 )
			{
				if( cubeArrayMoving[i].color == Cube::BLUE )	// BLUE
				{
					blueSolidIntensityIncrement = 16;
				}
				else if( cubeArrayMoving[i].color == Cube::RED )	// RED
				{
					redSolidIntensityIncrement = 16;
				}
				else if( cubeArrayMoving[i].color == Cube::GREEN )	// GREEN
				{
					greenSolidIntensityIncrement = 16;
				}
				else if( cubeArrayMoving[i].color == Cube::YELLOW )	// YELLOW
				{
					yellowSolidIntensityIncrement = 16;
				}
				else if( cubeArrayMoving[i].color == Cube::ORANGE )	// ORANGE
				{
					orangeSolidIntensityIncrement = 16;
				}
				else if( cubeArrayMoving[i].color == Cube::PURPLE )	// PURPLE
				{
					purpleSolidIntensityIncrement = 16;
				}
			}
			else
			{
				if( cubeArrayMoving[i].color == Cube::BLUE )	// BLUE
				{
					blueSolidIntensityIncrement = 8;
				}
				else if( cubeArrayMoving[i].color == Cube::RED )	// RED
				{
					redSolidIntensityIncrement = 8;
				}
				else if( cubeArrayMoving[i].color == Cube::GREEN )	// GREEN
				{
					greenSolidIntensityIncrement = 8;
				}
				else if( cubeArrayMoving[i].color == Cube::YELLOW )	// YELLOW
				{
					yellowSolidIntensityIncrement = 8;
				}
				else if( cubeArrayMoving[i].color == Cube::ORANGE )	// ORANGE
				{
					orangeSolidIntensityIncrement = 8;
				}
				else if( cubeArrayMoving[i].color == Cube::PURPLE )	// PURPLE
				{
					purpleSolidIntensityIncrement = 8;
				}
			}
		}
		else // if level is 3 or higher
		{
			
		}*/

	} // end of for loop for going through moving cubes/shadows
	
}

// not used
void CreateSideVertexStream()
{
	// copy temp materials
	side1TempMaterial->Copy( *side1Material );
	side2TempMaterial->Copy( *side2Material );
	side3TempMaterial->Copy( *side3Material );
	side4TempMaterial->Copy( *side4Material );
	side5TempMaterial->Copy( *side5Material );
	side6TempMaterial->Copy( *side6Material );

	// scroll through the planes to see if they are active. if they are, render it
	for( int i = 0; i < 6; i++ )
	{
		// order of colors are:
		// blue, red, purple, orange, green, yellow
		if( plane[i].active == true )
		{
			// if the plane is active, there is no change in its render material, so copy back from temp material
			switch( i )
			{
			case 0:
				side1Material->Copy( *side1TempMaterial );
				break;
			case 1:
				side2Material->Copy( *side2TempMaterial );
				break;
			case 2:
				side3Material->Copy( *side3TempMaterial );
				break;
			case 3:
				side4Material->Copy( *side4TempMaterial );
				break;
			case 4:
				side5Material->Copy( *side5TempMaterial );
				break;
			case 5:
				side6Material->Copy( *side6TempMaterial );
				break;
			}			
		}
		else if( plane[i].active == false )
		{
			// if the plane is not active, replace its corresp. side with a null material
			switch( i )
			{
			case 0:
				side1Material->Copy( *nullMaterial );
				break;
			case 1:
				side2Material->Copy( *nullMaterial );
				break;
			case 2:
				side3Material->Copy( *nullMaterial );
				break;
			case 3:
				side4Material->Copy( *nullMaterial );
			case 4:
				side5Material->Copy( *nullMaterial );
				break;
			case 5:
				side6Material->Copy( *nullMaterial );
				break;
			}	
		} // end of if not active, set to null
	} // end of for loop through planes
}

void ReleaseButtons()
{
	if( rotateButton.pressed == true ) // Rotate Button
	{
		RotateActiveShadows();
		
		// play the sound
		playRotateSound();

		if( episode == 1 )
		{
			// hide tutorial rotate
			if( triggeredShowTutorialRotate == true && triggeredHideTutorialRotate == false )
			{
				s3eTimerSetTimer( 0, triggerHideTutorialRotate, 0 );
				s3eTimerCancelTimer( triggerShowTutorialRotate, 0 );
				triggeredHideTutorialRotate = true;
			}
		}

		
		// disable the button highlight for tutorial
		if( GameState == PLAY_TUTORIAL )
		{
			if( tutorialNumber == 2 )
			{
				tutorialRotateButtonHighlightEnabled = false;
				tutorialRotateCubePassed = true;
			}
		}				
	}
	if( pauseButton.pressed == true && transition == false ) // Pause Button
	{
		if( GameState == PLAY_GAME )
		{
			GameState = PAUSED;

			//lowerVolume();
			//printf("The volume is %d \n", s3eAudioGetInt( S3E_AUDIO_VOLUME ) );

			// flurry log pause
			if( hasFlurry )
			{
				char cstring[50] = "Pressed Pause";
				s3eFlurryLogEvent( cstring, false );
			}
		}
		else if( GameState == PLAY_TUTORIAL )
		{
			GameState = PAUSED;
		}
		else if( GameState == PAUSED )
		{
			if( atTutorial == true )
			{
				GameState = PLAY_TUTORIAL;
			}
			else
			{
				GameState = PLAY_GAME;
			}
		}
	}

	if( tutorialLeftButton.pressed == true )
	{
		worldX = 0;
		worldY = 0;
		savedX = 0;
		savedY = 0;

		tutorialNumber--;

		// CLAMP the tutorial number
		if( tutorialNumber <= 1 )
		{
			tutorialNumber = 1;
		}

		// Reset Congrats Sprite
		showCongratsSpriteComplete = false;
		congratsSpriteComplete.resetAndPlayAnimation();

		// BUTTON HIGHLIGHTS
		// Enable Rotate Button HIGHLIGHT
		if( tutorialNumber == 2 )
		{
			tutorialRotateButtonHighlightEnabled = true;
		}

		// Disable Right Button Highlight
		tutorialRightButtonHighlightEnabled = false;

		// Reset PASSED-STATES for all tutorial levels
		tutorialTouchDragPassed = false;
		tutorialRotateCubePassed = false;
		tutorialTapDropPassed = false;
		tutorialCompleteSidePassed = false;
		tutorialRotateCameraPassed = false;
		tutorialFlipCubePassed = false;
		tutorialCompleteSide2Passed = false;

		// Reset and Resync ANIMATION for all tutorial levels
		tutorialRightButtonHighlightSprite.resetAndPlayAnimation();
		switch( tutorialNumber )
		{
		case 1:
			tutorialTouchDragSprite.resetAndPlayAnimation();
			break;
		case 2:
			tutorialRotateCubeSprite.resetAndPlayAnimation();
			tutorialRotateButtonHighlightSprite.resetAndPlayAnimation(); // resync highlight animation
			break;
		case 3:
			tutorialTapDropSprite.resetAndPlayAnimation();
			break;
		case 4:
			tutorialCompleteSideSprite.resetAndPlayAnimation();
			break;
		case 5:
			tutorialRotateCameraSprite.resetAndPlayAnimation();
			break;
		case 6:
			tutorialFlipCubeSprite.resetAndPlayAnimation();
			break;
		case 7:
			break;
		}

		// RESET AND REMOVE STATIC CUBES every time a new level is changed
		Reset();

		if( tutorialNumber < 6 ) // FOR TUTORIAL LEVELS 1-5, Remove Cubes, Spawn Cubes
		{
			SpawnMovingSets(); // spawning should not spawn more cubes if already in play. Internal condition
		}
		else if( tutorialNumber >= 6 ) // FOR TUTORIAL LEVELS 6 and 7
		{			
			/*
			// REMOVE ALL MOVING CUBES IF NOT ON FACE SIDES 2, 4, 5, 6
			for( int i = 0; i < numMovingCubesIndex; i++ )
			{
				if( cubeArrayMoving[i].direction == 1 || // if the direction is either 1 or 3, frontside or backside, remove it
					cubeArrayMoving[i].direction == 3
					)
				{
					removeMovingCube( i );// remove from moving cube array if it landed after a move() iteration
					removeShadow(i);// this happens when a cube is landed, or dropped-from the touch remove event
					i--;
				}
			}*/
		
			SpawnMovingSets(); // spawning should not spawn more cubes if already in play. Internal condition
		}
	} // end of if left tutorial button is pressed
	
	if( tutorialRightButton.pressed == true )
	{
		worldX = 0;
		worldY = 0;
		savedX = 0;
		savedY = 0;

		tutorialNumber++;

		// CLAMP the tutorial number
		if( tutorialNumber >= 7 )
		{
			tutorialNumber = 7;
		}

		// Reset Congrats Sprite
		showCongratsSpriteComplete = false;
		congratsSpriteComplete.resetAndPlayAnimation();

		// BUTTON HIGHLIGHTS
		// Enable Rotate Button HIGHLIGHT
		if( tutorialNumber == 2 )
		{
			tutorialRotateButtonHighlightEnabled = true;
		}

		// Disable Right Button Highlight
		tutorialRightButtonHighlightEnabled = false;


		// Reset PASSED-STATES for all tutorial levels
		tutorialTouchDragPassed = false;
		tutorialRotateCubePassed = false;
		tutorialTapDropPassed = false;
		tutorialCompleteSidePassed = false;
		tutorialRotateCameraPassed = false;
		tutorialFlipCubePassed = false;
		tutorialCompleteSide2Passed = false;

		// Reset and Resync ANIMATION for all tutorial levels
		tutorialRightButtonHighlightSprite.resetAndPlayAnimation();
		switch( tutorialNumber )
		{
		case 1:
			tutorialTouchDragSprite.resetAndPlayAnimation();
			
			break;
		case 2:
			tutorialRotateCubeSprite.resetAndPlayAnimation();
			tutorialRotateButtonHighlightSprite.resetAndPlayAnimation();
			break;
		case 3:
			tutorialTapDropSprite.resetAndPlayAnimation();
			break;
		case 4:
			tutorialCompleteSideSprite.resetAndPlayAnimation();
			break;
		case 5:
			tutorialRotateCameraSprite.resetAndPlayAnimation();
			break;
		case 6:
			tutorialFlipCubeSprite.resetAndPlayAnimation();
			break;
		case 7:
			break;
		}

		// RESET AND REMOVE STATIC CUBES every time a new level is changed
		Reset();

		// Controls TUTORIAL CUBE SPAWNING
		if( tutorialNumber < 6 ) // FOR TUTORIAL LEVELS 1-5
		{
			/*
			// REMOVE MOVING CUBES
			for( int i = 0; i < numMovingCubesIndex; i++ )
			{
				if( cubeArrayMoving[i].direction != 1 || tutorialNumber == 2 ) // If the direction is NOT 1, or if it's level 3, remove moving cubes
				{
					removeMovingCube( i );// remove from moving cube array if it landed after a move() iteration
					removeShadow(i);// this happens when a cube is landed, or dropped-from the touch remove event
					i--;
				}
			}
			*/
		
			SpawnMovingSets(); // spawning should not spawn more cubes if already in play. Internal condition
		}
		else if( tutorialNumber >= 6 ) // FOR TUTORIAL LEVELS 6 and 7
		{			
			/*
			// REMOVE ALL MOVING CUBES IF NOT ON FACE SIDES 2, 4, 5, 6
			for( int i = 0; i < numMovingCubesIndex; i++ )
			{
				if( cubeArrayMoving[i].direction == 1 || // if the direction is either 1 or 3, frontside or backside, remove it
					cubeArrayMoving[i].direction == 3
					)
				{
					removeMovingCube( i );// remove from moving cube array if it landed after a move() iteration
					removeShadow(i);// this happens when a cube is landed, or dropped-from the touch remove event
					i--;
				}
			}
			*/
		
			SpawnMovingSets(); // spawning should not spawn more cubes if already in play. Internal condition
		}
	} // end of if tutorial right button is pressed

	// NO CUBES DROPPING check
	// search through shadows to make sure no cubes are dropping. 
	// this affects if rotate buttons will take effect
	for( int i = 0; i < numShadowsIndex; i++ )
	{
		if( shadowArray[i].shadowGroup->dropCubes == true )
		{
			cubeIsDropping = true;
			break;
		}
		else
		{
			cubeIsDropping = false;
		}
	}

	cubeIsExploding = false;
	cubeIsWarping = false;

	// NO EXPLODING CUBES check
	for( int i = numOriginalCubes; i < numStaticCubes; i++ )
	{
		if( cubeArray[i].exploding == true && cubeArray[i].exploded == false )
			cubeIsExploding = true;

		if( cubeArray[i].material == Cube::WARPING_MATERIAL )
			cubeIsWarping = true;
	}

	// ROTATE THE MOVING CUBES
	// only execute rotation buttons if no cubes are currently dropping
	// if( cubeIsDropping == false && cubeIsExploding == false && cubeIsWarping == false )
	if( cubeIsDropping == false  && cubeIsWarping == false )
	{
		if( rightButton.pressed == true ) // if the button is pressed
		{
			playRedButtonSound();

			// hide tutorial shift
			if( triggeredShowTutorialShift == true && triggeredHideTutorialShift == false )
			{
				tutorialPlaneShiftCount++;
				s3eTimerSetTimer( 4000, triggerTutorialShiftEnable, 0 );

				s3eTimerSetTimer( 0, triggerHideTutorialShift, 0 );
				s3eTimerCancelTimer( triggerShowTutorialShift, 0 );
				triggeredHideTutorialShift = true;
				triggeredShowTutorialShift = false;
			}
			

			if( rotateMovingCubes == true ) // as opposed to rotateStaticCubes when implemented
			{
				if( getActiveFaceSide() == 5 ) // if the active faceside is 5
				{
					if( (worldX > -512 && worldX < 512) || 
						worldX > 3584 ||
						worldX < -3584 ) // orientation with faceside 1 facing bottom
					{
						rotateMovingVerticesClockwise = true;
					}
					else if( worldX < -512 && worldX > -1536 ||
						worldX < 3584 && worldX > 2560 ) // orientation with faceside 2 facing bottom
					{
						rotateMovingVerticesUp = true;
					}
					else if( worldX < 2560 && worldX > 1536 ||
						worldX < -1536 && worldX > -2560 ) // orientation with faceside 3 facing bottom
					{
						rotateMovingVerticesCounterClockwise = true;
					}
					else if( worldX < -2560 && worldX > -3584 ||
						worldX < 1536 && worldX > 512 ) // orientation with faceside 4 facing bottom
					{
						rotateMovingVerticesDown = true;
					}
				}
				else if( getActiveFaceSide() == 6 )
				{
					if( (worldX > -512 && worldX < 512) || 
						worldX > 3584 ||
						worldX < -3584 ) // orientation with faceside 1 facing top
					{
						rotateMovingVerticesCounterClockwise = true;
					}
					else if( worldX < -512 && worldX > -1536 ||
						worldX < 3584 && worldX > 2560 ) // orientation with faceside 2 facing top
					{
						rotateMovingVerticesDown = true;
					}
					else if( worldX < 2560 && worldX > 1536 ||
						worldX < -1536 && worldX > -2560 ) // orientation with faceside 3 facing top
					{
						rotateMovingVerticesClockwise = true;
					}
					else if( worldX < -2560 && worldX > -3584 ||
						worldX < 1536 && worldX > 512 ) // orientation with faceside 4 facing top
					{
						rotateMovingVerticesUp = true;
					}
				}
				else // if the active face sides are 1-4
				{
					if( reversedIndex == 1 ) // If the cubes are upside down, rotation changes to opposite
						rotateMovingVerticesRight = true;
					else
						rotateMovingVerticesLeft = true;
				}
			} // end of if rotateMovingCubes
			else // if rotateMovingCubes == false, meaning rotateStaticCubes = true
			{
				if( staticCubesAreRotating == false ) // only find active faceside if a cube is not rotating
				{
					if( getActiveFaceSide() == 5 ) // if the active faceside is 5
					{
						if( (worldX > -512 && worldX < 512) || 
							worldX > 3584 ||
							worldX < -3584 ) // orientation with faceside 1 facing bottom
						{
							rotateStaticVerticesClockwise = true;
						}
						else if( worldX < -512 && worldX > -1536 ||
							worldX < 3584 && worldX > 2560 ) // orientation with faceside 2 facing bottom
						{
							rotateStaticVerticesUp = true;
						}
						else if( worldX < 2560 && worldX > 1536 ||
							worldX < -1536 && worldX > -2560 ) // orientation with faceside 3 facing bottom
						{
							rotateStaticVerticesCounterClockwise = true;
						}
						else if( worldX < -2560 && worldX > -3584 ||
							worldX < 1536 && worldX > 512 ) // orientation with faceside 4 facing bottom
						{
							rotateStaticVerticesDown = true;
						}
					}
					else if( getActiveFaceSide() == 6 )
					{
						if( (worldX > -512 && worldX < 512) || 
							worldX > 3584 ||
							worldX < -3584 ) // orientation with faceside 1 facing top
						{
							rotateStaticVerticesCounterClockwise = true;
						}
						else if( worldX < -512 && worldX > -1536 ||
							worldX < 3584 && worldX > 2560 ) // orientation with faceside 2 facing top
						{
							rotateStaticVerticesDown = true;
						}
						else if( worldX < 2560 && worldX > 1536 ||
							worldX < -1536 && worldX > -2560 ) // orientation with faceside 3 facing top
						{
							rotateStaticVerticesClockwise = true;
						}
						else if( worldX < -2560 && worldX > -3584 ||
							worldX < 1536 && worldX > 512 ) // orientation with faceside 4 facing top
						{
							rotateStaticVerticesUp = true;
						}
					}
					else // if the active face sides are 1-4
					{
						if( reversedIndex == 1 ) // If the cubes are upside down, rotation changes to opposite
							rotateStaticVerticesRight = true;
						else
							rotateStaticVerticesLeft = true;
					}
				} // end of if static cubes not rotating
			}// end of if rotateStaticCubes
		} // end of if rightbutton is pressed
		else if( leftButton.pressed == true ) // if the button is pressed
		{
			playRedButtonSound();

			// hide tutorial shift
			if( triggeredShowTutorialShift == true && triggeredHideTutorialShift == false )
			{
				tutorialPlaneShiftCount++;
				s3eTimerSetTimer( 4000, triggerTutorialShiftEnable, 0 );

				s3eTimerSetTimer( 0, triggerHideTutorialShift, 0 );
				s3eTimerCancelTimer( triggerShowTutorialShift, 0 );
				triggeredHideTutorialShift = true;
				triggeredShowTutorialShift = false;
			}
			
			if( rotateMovingCubes == true )
			{
				if( getActiveFaceSide() == 5 ) // faceside 5 is active
				{
					if( (worldX > -512 && worldX < 512) || // orientation of faceside 5 with faceside 1 facing bottom
						worldX > 3584 ||
						worldX < -3584 )
					{
						rotateMovingVerticesCounterClockwise = true;
					}
					else if( worldX < -512 && worldX > -1536 ||
						worldX < 3584 && worldX > 2560 ) // orientation with faceside 2 facing bottom
					{
						rotateMovingVerticesDown = true;
					}
					else if( worldX < 2560 && worldX > 1536 ||
						worldX < -1536 && worldX > -2560 ) // orientation with faceside 3 facing bottom
					{
						rotateMovingVerticesClockwise = true;
					}
					else if( worldX < -2560 && worldX > -3584 ||
						worldX < 1536 && worldX > 512 ) // orientation with faceside 4 facing bottom
					{
						rotateMovingVerticesUp = true;
					}
				}
				else if( getActiveFaceSide() == 6 )
				{
					if( (worldX > -512 && worldX < 512) || 
						worldX > 3584 ||
						worldX < -3584 ) // orientation with faceside 1 facing top
					{
						rotateMovingVerticesClockwise = true;
					}
					else if( worldX < -512 && worldX > -1536 ||
						worldX < 3584 && worldX > 2560 ) // orientation with faceside 2 facing top
					{
						rotateMovingVerticesUp = true;
					}
					else if( worldX < 2560 && worldX > 1536 ||
						worldX < -1536 && worldX > -2560 ) // orientation with faceside 3 facing top
					{
						rotateMovingVerticesCounterClockwise = true;
					}
					else if( worldX < -2560 && worldX > -3584 ||
						worldX < 1536 && worldX > 512 ) // orientation with faceside 4 facing top
					{
						rotateMovingVerticesDown = true;
					}
				}
				else // if the active face sides are 1-4
				{
					if( reversedIndex == 1 ) // If the cubes are upside down, rotation changes to opposite
						rotateMovingVerticesLeft = true;	
					else
						rotateMovingVerticesRight = true;
				}
			} // end of if rotateMovingCubes == true
			else // if rotateMovingCubes == false, meaning rotateStaticCubes = true
			{
				if( staticCubesAreRotating == false ) // only find active faceside if a cube is not rotating
				{
					if( getActiveFaceSide() == 5 ) // if the active faceside is 5
					{
						if( (worldX > -512 && worldX < 512) || 
							worldX > 3584 ||
							worldX < -3584 ) // orientation with faceside 1 facing bottom
						{
							rotateStaticVerticesCounterClockwise = true;
						}
						else if( worldX < -512 && worldX > -1536 ||
							worldX < 3584 && worldX > 2560 ) // orientation with faceside 2 facing bottom
						{
							rotateStaticVerticesDown = true;
						}
						else if( worldX < 2560 && worldX > 1536 ||
							worldX < -1536 && worldX > -2560 ) // orientation with faceside 3 facing bottom
						{
							rotateStaticVerticesClockwise = true;
						}
						else if( worldX < -2560 && worldX > -3584 ||
							worldX < 1536 && worldX > 512 ) // orientation with faceside 4 facing bottom
						{
							rotateStaticVerticesUp = true;
						}
					}
					else if( getActiveFaceSide() == 6 )
					{
						if( (worldX > -512 && worldX < 512) || 
							worldX > 3584 ||
							worldX < -3584 ) // orientation with faceside 1 facing top
						{
							rotateStaticVerticesClockwise = true;
						}
						else if( worldX < -512 && worldX > -1536 ||
							worldX < 3584 && worldX > 2560 ) // orientation with faceside 2 facing top
						{
							rotateStaticVerticesUp = true;
						}
						else if( worldX < 2560 && worldX > 1536 ||
							worldX < -1536 && worldX > -2560 ) // orientation with faceside 3 facing top
						{
							rotateStaticVerticesCounterClockwise = true;
						}
						else if( worldX < -2560 && worldX > -3584 ||
							worldX < 1536 && worldX > 512 ) // orientation with faceside 4 facing top
						{
							rotateStaticVerticesDown = true;
						}
					}
					else // if the active face sides are 1-4
					{
						if( reversedIndex == 1 ) // If the cubes are upside down, rotation changes to opposite
							rotateStaticVerticesLeft = true;
						else
							rotateStaticVerticesRight = true;
					}
				} // end of if static cubes not rotating
			}// end of if rotateStaticCubes
		} // end of leftButton press
		else if( upButton.pressed == true ) // if the button is pressed
		{
			playRedButtonSound();

			// hide tutorial shift
			if( triggeredShowTutorialShift == true && triggeredHideTutorialShift == false )
			{
				tutorialPlaneShiftCount++;
				s3eTimerSetTimer( 4000, triggerTutorialShiftEnable, 0 );

				s3eTimerSetTimer( 0, triggerHideTutorialShift, 0 );
				s3eTimerCancelTimer( triggerShowTutorialShift, 0 );
				triggeredHideTutorialShift = true;
				triggeredShowTutorialShift = false;
			}

			if( rotateMovingCubes == true )
			{
				if( getActiveFaceSide() == 5 ) // faceside 5
				{
					if( (worldX > -512 && worldX < 512) || // orientation with faceside 1 facing bottom
						worldX > 3584 ||
						worldX < -3584 )
					{
						rotateMovingVerticesUp = true;
					}
					else if( worldX < -512 && worldX > -1536 ||
						worldX < 3584 && worldX > 2560 ) // orientation with faceside 2 facing bottom
					{
						rotateMovingVerticesCounterClockwise = true;
					}
					else if( worldX < 2560 && worldX > 1536 ||
						worldX < -1536 && worldX > -2560 ) // orientation with faceside 3 facing bottom
					{
						rotateMovingVerticesDown = true;
					}
					else if( worldX < -2560 && worldX > -3584 ||
						worldX < 1536 && worldX > 512 ) // orientation with faceside 4 facing bottom
					{
						rotateMovingVerticesClockwise = true;
					}
				}
				else if( getActiveFaceSide() == 6 )
				{
					if( (worldX > -512 && worldX < 512) || 
						worldX > 3584 ||
						worldX < -3584 ) // orientation with faceside 1 facing top
					{
						rotateMovingVerticesUp = true;
					}
					else if( worldX < -512 && worldX > -1536 ||
						worldX < 3584 && worldX > 2560 ) // orientation with faceside 2 facing top
					{
						rotateMovingVerticesCounterClockwise = true;
					}
					else if( worldX < 2560 && worldX > 1536 ||
						worldX < -1536 && worldX > -2560 ) // orientation with faceside 3 facing top
					{
						rotateMovingVerticesDown = true;
					}
					else if( worldX < -2560 && worldX > -3584 ||
						worldX < 1536 && worldX > 512 ) // orientation with faceside 4 facing top
					{
						rotateMovingVerticesClockwise = true;
					}
				}
				else if( getActiveFaceSide() == 1 )
				{
					if( reversedIndex == 1 ) // If the cubes are upside down, rotation changes to opposite
						rotateMovingVerticesUp = true;
					else
						rotateMovingVerticesDown = true;
				}
				else if( getActiveFaceSide() == 2 )
				{
					if( reversedIndex == 1 ) // If the cubes are upside down, rotation changes to opposite
						rotateMovingVerticesCounterClockwise = true;
					else
						rotateMovingVerticesClockwise = true;
				}
				else if( getActiveFaceSide() == 3 )
				{
					if( reversedIndex == 1 ) // If the cubes are upside down, rotation changes to opposite
						rotateMovingVerticesDown = true;
					else
						rotateMovingVerticesUp = true;
				}
				else if( getActiveFaceSide() == 4 )
				{
					if( reversedIndex == 1 ) // If the cubes are upside down, rotation changes to opposite
						rotateMovingVerticesClockwise = true;
					else
						rotateMovingVerticesCounterClockwise = true;
				}
			}// end of if rotateMovingCubes == true		
			else
			{
				if( staticCubesAreRotating == false ) // only find active faceside if a cube is not rotating
				{
					if( getActiveFaceSide() == 5 ) // faceside 5
					{
						if( (worldX > -512 && worldX < 512) || // orientation with faceside 1 facing bottom
							worldX > 3584 ||
							worldX < -3584 )
						{
							rotateStaticVerticesUp = true;
						}
						else if( worldX < -512 && worldX > -1536 ||
							worldX < 3584 && worldX > 2560 ) // orientation with faceside 2 facing bottom
						{
							rotateStaticVerticesCounterClockwise = true;
						}
						else if( worldX < 2560 && worldX > 1536 ||
							worldX < -1536 && worldX > -2560 ) // orientation with faceside 3 facing bottom
						{
							rotateStaticVerticesDown = true;
						}
						else if( worldX < -2560 && worldX > -3584 ||
							worldX < 1536 && worldX > 512 ) // orientation with faceside 4 facing bottom
						{
							rotateStaticVerticesClockwise = true;
						}
					}
					else if( getActiveFaceSide() == 6 )
					{
						if( (worldX > -512 && worldX < 512) || 
							worldX > 3584 ||
							worldX < -3584 ) // orientation with faceside 1 facing top
						{
							rotateStaticVerticesUp = true;
						}
						else if( worldX < -512 && worldX > -1536 ||
							worldX < 3584 && worldX > 2560 ) // orientation with faceside 2 facing top
						{
							rotateStaticVerticesCounterClockwise = true;
						}
						else if( worldX < 2560 && worldX > 1536 ||
							worldX < -1536 && worldX > -2560 ) // orientation with faceside 3 facing top
						{
							rotateStaticVerticesDown = true;
						}
						else if( worldX < -2560 && worldX > -3584 ||
							worldX < 1536 && worldX > 512 ) // orientation with faceside 4 facing top
						{
							rotateStaticVerticesClockwise = true;
						}
					}
					else if( getActiveFaceSide() == 1 )
					{
						if( reversedIndex == 1 ) // If the cubes are upside down, rotation changes to opposite
							rotateStaticVerticesUp = true;
						else
							rotateStaticVerticesDown = true;
					}
					else if( getActiveFaceSide() == 2 )
					{
						if( reversedIndex == 1 ) // If the cubes are upside down, rotation changes to opposite
							rotateStaticVerticesCounterClockwise = true;
						else
							rotateStaticVerticesClockwise = true;
					}
					else if( getActiveFaceSide() == 3 )
					{
						if( reversedIndex == 1 ) // If the cubes are upside down, rotation changes to opposite
							rotateStaticVerticesDown = true;
						else
							rotateStaticVerticesUp = true;
					}
					else if( getActiveFaceSide() == 4 )
					{
						if( reversedIndex == 1 ) // If the cubes are upside down, rotation changes to opposite
							rotateStaticVerticesClockwise = true;
						else
							rotateStaticVerticesCounterClockwise = true;
					}
				} // end of if static cubes not rotating
			} // end of if rotate static cubes
		} // end of up button press
		else if( downButton.pressed == true ) // if the button is pressed
		{
			playRedButtonSound();

			// hide tutorial shift
			if( triggeredShowTutorialShift == true && triggeredHideTutorialShift == false )
			{
				tutorialPlaneShiftCount++;
				s3eTimerSetTimer( 4000, triggerTutorialShiftEnable, 0 );

				s3eTimerSetTimer( 0, triggerHideTutorialShift, 0 );
				s3eTimerCancelTimer( triggerShowTutorialShift, 0 );
				triggeredHideTutorialShift = true;
				triggeredShowTutorialShift = false;
			}

			if( rotateMovingCubes == true )
			{
				if( getActiveFaceSide() == 5 ) // faceside 5
				{
					if( (worldX > -512 && worldX < 512) || // orientation with faceside 1 facing bottom
						worldX > 3584 ||
						worldX < -3584 )
					{
						rotateMovingVerticesDown = true;
					}
					else if( worldX < -512 && worldX > -1536 ||
						worldX < 3584 && worldX > 2560 ) // orientation with faceside 2 facing bottom
					{
						rotateMovingVerticesClockwise = true;
					}
					else if( worldX < 2560 && worldX > 1536 ||
						worldX < -1536 && worldX > -2560 ) // orientation with faceside 3 facing bottom
					{
						rotateMovingVerticesUp = true;
					}
					else if( worldX < -2560 && worldX > -3584 ||
						worldX < 1536 && worldX > 512 ) // orientation with faceside 4 facing bottom
					{
						rotateMovingVerticesCounterClockwise = true;
					}
				}
				else if( getActiveFaceSide() == 6 )
				{
					if( (worldX > -512 && worldX < 512) || 
						worldX > 3584 ||
						worldX < -3584 ) // orientation with faceside 1 facing top
					{
						rotateMovingVerticesDown = true;
					}
					else if( worldX < -512 && worldX > -1536 ||
						worldX < 3584 && worldX > 2560 ) // orientation with faceside 2 facing top
					{
						rotateMovingVerticesClockwise = true;
					}
					else if( worldX < 2560 && worldX > 1536 ||
						worldX < -1536 && worldX > -2560 ) // orientation with faceside 3 facing top
					{
						rotateMovingVerticesUp = true;
					}
					else if( worldX < -2560 && worldX > -3584 ||
						worldX < 1536 && worldX > 512 ) // orientation with faceside 4 facing top
					{
						rotateMovingVerticesCounterClockwise = true;
					}
				}
				else if( getActiveFaceSide() == 1 )
				{
					if( reversedIndex == 1 ) // If the cubes are upside down, rotation changes to opposite
						rotateMovingVerticesDown = true;
					else
						rotateMovingVerticesUp = true;
				}
				else if( getActiveFaceSide() == 2 )
				{
					if( reversedIndex == 1 ) // If the cubes are upside down, rotation changes to opposite
						rotateMovingVerticesClockwise = true;
					else
						rotateMovingVerticesCounterClockwise = true;
				}
				else if( getActiveFaceSide() == 3 )
				{
					if( reversedIndex == 1 ) // If the cubes are upside down, rotation changes to opposite
						rotateMovingVerticesUp = true;
					else
						rotateMovingVerticesDown = true;
				}
				else if( getActiveFaceSide() == 4 )
				{
					if( reversedIndex == 1 ) // If the cubes are upside down, rotation changes to opposite
						rotateMovingVerticesCounterClockwise = true;
					else
						rotateMovingVerticesClockwise = true;
				}
			} // end of if rotateMovingCubes == true
			else
			{
				if( staticCubesAreRotating == false ) // only find active faceside if a cube is not rotating
				{
					if( getActiveFaceSide() == 5 ) // faceside 5
					{
						if( (worldX > -512 && worldX < 512) || // orientation with faceside 1 facing bottom
							worldX > 3584 ||
							worldX < -3584 )
						{
							rotateStaticVerticesDown = true;
						}
						else if( worldX < -512 && worldX > -1536 ||
							worldX < 3584 && worldX > 2560 ) // orientation with faceside 2 facing bottom
						{
							rotateStaticVerticesClockwise = true;
						}
						else if( worldX < 2560 && worldX > 1536 ||
							worldX < -1536 && worldX > -2560 ) // orientation with faceside 3 facing bottom
						{
							rotateStaticVerticesUp = true;
						}
						else if( worldX < -2560 && worldX > -3584 ||
							worldX < 1536 && worldX > 512 ) // orientation with faceside 4 facing bottom
						{
							rotateStaticVerticesCounterClockwise = true;
						}
					}
					else if( getActiveFaceSide() == 6 )
					{
						if( (worldX > -512 && worldX < 512) || 
							worldX > 3584 ||
							worldX < -3584 ) // orientation with faceside 1 facing top
						{
							rotateStaticVerticesDown = true;
						}
						else if( worldX < -512 && worldX > -1536 ||
							worldX < 3584 && worldX > 2560 ) // orientation with faceside 2 facing top
						{
							rotateStaticVerticesClockwise = true;
						}
						else if( worldX < 2560 && worldX > 1536 ||
							worldX < -1536 && worldX > -2560 ) // orientation with faceside 3 facing top
						{
							rotateStaticVerticesUp = true;
						}
						else if( worldX < -2560 && worldX > -3584 ||
							worldX < 1536 && worldX > 512 ) // orientation with faceside 4 facing top
						{
							rotateStaticVerticesCounterClockwise = true;
						}
					}
					else if( getActiveFaceSide() == 1 )
					{
						if( reversedIndex == 1 ) // If the cubes are upside down, rotation changes to opposite
							rotateStaticVerticesDown = true;
						else
							rotateStaticVerticesUp = true;
					}
					else if( getActiveFaceSide() == 2 )
					{
						if( reversedIndex == 1 ) // If the cubes are upside down, rotation changes to opposite
							rotateStaticVerticesClockwise = true;
						else
							rotateStaticVerticesCounterClockwise = true;
					}
					else if( getActiveFaceSide() == 3 )
					{
						if( reversedIndex == 1 ) // If the cubes are upside down, rotation changes to opposite
							rotateStaticVerticesUp = true;
						else
							rotateStaticVerticesDown = true;
					}
					else if( getActiveFaceSide() == 4 )
					{
						if( reversedIndex == 1 ) // If the cubes are upside down, rotation changes to opposite
							rotateStaticVerticesCounterClockwise = true;
						else
							rotateStaticVerticesClockwise = true;
					}
				} // end of if static cubes not rotating
			} // end of if rotateStaticCubes
		} // end of down button press
	} // end of if-statement for if a cube is dropping for executing rotate buttons

	// release the variables


	rightButton.pressed = false;
	rightButton.initialPressed = false;

	leftButton.pressed = false;
	leftButton.initialPressed = false;

	upButton.pressed = false;
	upButton.initialPressed = false;

	downButton.pressed = false;
	downButton.initialPressed = false;

	pauseButton.pressed = false;
	pauseButton.initialPressed = false;

	tutorialLeftButton.pressed = false;
	tutorialLeftButton.initialPressed = false;

	tutorialRightButton.pressed = false;
	tutorialRightButton.initialPressed = false;
	
	rotateButton.pressed = false;
	rotateButton.initialPressed = false;
} // end of ReleaseButtons()

void ReleaseChallengeMenuScreenButtons()
{
	for( int i = 0; i < menuScreen[0].buttonCount; i++ )
	{		
		if( menuScreen[0].button[i].pressed == true )
		{
		
			// load the levels depending on what 'i' is.
			switch( i )
			{
			case 0: // level 1
				planeSpawning = SINGLE_RANDOM;
				cubeSpawning = SINGLE_RANDOM;

				challengeMode = true;		
				cmDifficultyLevel = i;				
				GameState = AT_LOADING_LEVEL;
				break;
			case 1: // LEVEL 2
				planeSpawning = DOUBLE_ADJACENT;
				cubeSpawning = SINGLE_RANDOM;

				challengeMode = true;		
				cmDifficultyLevel = i;				
				GameState = AT_LOADING_LEVEL;
				break;
			case 2: // LEVEL 3
				planeSpawning = DOUBLE_ADJACENT;
				cubeSpawning = DOUBLE_INCOLOR;

				challengeMode = true;		
				cmDifficultyLevel = i;				
				GameState = AT_LOADING_LEVEL;
				break;
			case 3: // LEVEL 4
				planeSpawning = DOUBLE_RANDOM;
				cubeSpawning = DOUBLE_RANDOM;

				challengeMode = true;		
				cmDifficultyLevel = i;				
				GameState = AT_LOADING_LEVEL;
				break;
			case 4: // level 5
				planeSpawning = TRIPLE_RANDOM;
				cubeSpawning = DOUBLE_RANDOM;

				challengeMode = true;		
				cmDifficultyLevel = i;				
				GameState = AT_LOADING_LEVEL;
				break;
			case 5: // level 6
				planeSpawning = QUADRUPLE_RANDOM;
				cubeSpawning = DOUBLE_RANDOM;

				challengeMode = true;		
				cmDifficultyLevel = i;				
				GameState = AT_LOADING_LEVEL;
				break;
			case 6: // level 7
				planeSpawning = TRIPLE_RANDOM;
				cubeSpawning = TRIPLE_INCOLOR;

				challengeMode = true;		
				cmDifficultyLevel = i;				
				GameState = AT_LOADING_LEVEL;
				break;
			case 7: // level 8
				planeSpawning = TRIPLE_RANDOM;
				cubeSpawning = TRIPLE_RANDOM;

				challengeMode = true;		
				cmDifficultyLevel = i;				
				GameState = AT_LOADING_LEVEL;
				break;
			case 8: // level 9
				planeSpawning = QUADRUPLE_RANDOM;
				cubeSpawning = TRIPLE_RANDOM;

				challengeMode = true;		
				cmDifficultyLevel = i;				
				GameState = AT_LOADING_LEVEL;
				break;
			case 9: // level 10
				planeSpawning = QUINTUPLE_RANDOM;
				cubeSpawning = TRIPLE_RANDOM;

				challengeMode = true;		
				cmDifficultyLevel = i;				
				GameState = AT_LOADING_LEVEL;
				break;
			case 10: // level 11
				planeSpawning = SEXTUPLE;
				cubeSpawning = TRIPLE_RANDOM;

				challengeMode = true;		
				cmDifficultyLevel = i;				
				GameState = AT_LOADING_LEVEL;
				break;
			case 11: // level 12
				planeSpawning = QUADRUPLE_RANDOM;
				cubeSpawning = QUADRUPLE_INCOLOR;

				challengeMode = true;		
				cmDifficultyLevel = i;				
				GameState = AT_LOADING_LEVEL;
				break;
			case 12: // level 13
				planeSpawning = QUADRUPLE_RANDOM;
				cubeSpawning = QUADRUPLE_RANDOM;

				challengeMode = true;		
				cmDifficultyLevel = i;				
				GameState = AT_LOADING_LEVEL;
				break;
			case 13: // level 14
				planeSpawning = QUINTUPLE_RANDOM;
				cubeSpawning = QUADRUPLE_RANDOM;

				challengeMode = true;		
				cmDifficultyLevel = i;				
				GameState = AT_LOADING_LEVEL;
				break;
			case 14: // level 15
				planeSpawning = SEXTUPLE;
				cubeSpawning = QUADRUPLE_RANDOM;

				challengeMode = true;		
				cmDifficultyLevel = i;				
				GameState = AT_LOADING_LEVEL;
				break;
			case 15: // level 16
				planeSpawning = QUINTUPLE_RANDOM;
				cubeSpawning = QUINTUPLE_INCOLOR;

				challengeMode = true;		
				cmDifficultyLevel = i;				
				GameState = AT_LOADING_LEVEL;
				break;
			case 16: // level 17
				planeSpawning = QUINTUPLE_RANDOM;
				cubeSpawning = QUINTUPLE_RANDOM;

				challengeMode = true;		
				cmDifficultyLevel = i;				
				GameState = AT_LOADING_LEVEL;
				break;
			case 17: // level 18
				planeSpawning = SEXTUPLE;
				cubeSpawning = QUINTUPLE_RANDOM;

				challengeMode = true;		
				cmDifficultyLevel = i;				
				GameState = AT_LOADING_LEVEL;
				break;
			case 18: // level 19
				planeSpawning = SEXTUPLE;
				cubeSpawning = SEXTUPLE_INCOLOR;

				challengeMode = true;		
				cmDifficultyLevel = i;				
				GameState = AT_LOADING_LEVEL;
				break;
			case 19: // level 20
				planeSpawning = SEXTUPLE;
				cubeSpawning = SEXTUPLE_RANDOM;

				challengeMode = true;		
				cmDifficultyLevel = i;				
				GameState = AT_LOADING_LEVEL;
				break;

					// QFI Algorithm to determine leven increase or decrease
		/*
		difficulty  planeSpawn  cubeSpawn		NumOfSides NumOfCubes
		1			SINGLE_RAN	SINGLE_RAN		1			1
		2			DOUBLE_ADJ	SINGLE_RAN		2			1
		3			DOUBLE_ADJ	DOUBLE_INC - 3	2			2
		4			DOUBLE_RAN	DOUBLE_RAN		2			2
		5			TRIPLE_RAN	DOUBLE_RAN		3			2
		6			QUAD_RAN	DOUBLE_RAN		4			2
		7			TRIPLE_RAN	TRIPLE_INC - 7	3			3
		8			TRIPLE_RAN	TRIPLE_RAN		3			
		9			QUAD_RAN	TRIPLE_RAN		4
		10			QUIN_RAN	TRIPLE_RAN		5
		11			SEXTUP_RAN	TRIPLE_RAN		6
		12			QUAD_RAN	QUAD_INC - 12	4
		13			QUAD_RAN	QUAD_RAN		4	
		14			QUIN_RAN	QUAD_RAN		5
		15			SEXTUP_RAN	QUAD_RAN		6	
		16			QUIN_RAN	QUIN_INC - 16	5
		17			QUIN_RAN	QUIN_RAN		5
		18			SEXTUP		QUIN_RAN		6
		19			SEXTUP		SEXTUP_INC - 19	6
		20			SEXTUP		SEXTUP_RAN		6
		*/
			case 20:				

				menuScreen[0].setStartingPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );
				menuScreen[0].setEndingPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight() * 2 );
				menuScreen[0].setInterpolationTime( 500 );
				menuScreen[0].setAcceleration( 100, 2);
				
				challengeMode = false;
				GameState = AT_MENU;
				break;
			}
		}

		menuScreen[0].button[i].initialPressed = false;
		menuScreen[0].button[i].pressed = false;
	}
}

void ReleaseHighScoreMenuScreenButtons()
{
	for( int i = 0; i < menuScreen[1].buttonCount; i++ )
	{		
		if( menuScreen[1].button[i].pressed == true && limbo == false )
		{
			string trophyString;

			// load the levels depending on what 'i' is.
			switch( i )
			{
			case 0: // RATE App button
				s3eInetAddress addr;
				memset(&addr, 0, sizeof(addr));

				// Check for network connection
				if( s3eInetLookup( "www.apple.com", &addr, NULL, NULL) == S3E_RESULT_ERROR ) // if no connection
				{
					printf("\n\n No network connection! \n");

					trophyString = "Oops! You're not connected to the internet! Please try again when you have service!";
					strcpy( trophyCString, trophyString.c_str() );

					// show message that says no internet connection
					trophyMessageSprite.setImage( trophyMessageImage[10] );
					showTrophyMessage = true;					

					// flurry log rate no internet
					if( hasFlurry )
					{
						char cstring[50] = "Pressed HighScore-Rate (No Internet)";
						s3eFlurryLogEvent( cstring, false );
					}
				}
				else // if has connection
				{
					// launch the link
					if( s3eOSExecExecute( "itms-apps://itunes.apple.com/app/id500897011?ls=1&mt=8", false ) != S3E_RESULT_SUCCESS )
					{
						printf("Failed to launch link to app store\n");
					}
					else
					{
						trophies[2] = true; // successfully reached rating app
						SaveHighStats();

						// flurry log rate - success
						if( hasFlurry )
						{
							char cstring[50] = "Pressed HighScore-Rate (Success)";
							s3eFlurryLogEvent( cstring, false );
						}
					}
				}
				break;
			case 1: // BACK button
				menuScreen[1].setStartingPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );
				menuScreen[1].setEndingPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight() * 2 );
				menuScreen[1].setInterpolationTime( 500 );
				menuScreen[1].setAcceleration( 100, 2);
				
				GameState = AT_MENU;
				ResetMenuButtonBobble();

				break;
			case 2: // messages for how to obtain trophies
				// this conditional statement has to be here b/c both buttons are checked simultaneously
				if( trophies[0] == false ) // 100 000 points
				{
					trophyString = "How to get Trophy: Get a high score of 100,000 points!";
					strcpy( trophyCString, trophyString.c_str() );

					trophyMessageSprite.setImage( trophyMessageImage[0] );
					showTrophyMessage = true;

					// flurry log trophy
					if( hasFlurry )
					{
						char cstring[50] = "Pressed Trophy100k (no trophy)";
						s3eFlurryLogEvent( cstring, false );
					}
				}
				break;
			case 3:
				if( trophies[1] == false ) // 500,000 points
				{
					trophyString = "How to get Trophy: Get a high score of 500,000 points!";
					strcpy( trophyCString, trophyString.c_str() );

					trophyMessageSprite.setImage( trophyMessageImage[1] );
					showTrophyMessage = true;

					// flurry log trophy
					if( hasFlurry )
					{
						char cstring[50] = "Pressed Trophy500k (no trophy)";
						s3eFlurryLogEvent( cstring, false );
					}
				}
				break;
			case 4:
				if( trophies[2] == false ) // rated app
				{
					trophyString = "How to get Trophy: Rate this App on the App Store!";
					strcpy( trophyCString, trophyString.c_str() );

					trophyMessageSprite.setImage( trophyMessageImage[2] );
					showTrophyMessage = true;

					// flurry log trophy
					if( hasFlurry )
					{
						char cstring[50] = "Pressed TrophyRate (no trophy)";
						s3eFlurryLogEvent( cstring, false );
					}
				}
				break;
			case 5:
				if( trophies[3] == false ) // 1 million points
				{
					trophyString = "How to get Trophy: Get a high score of 1,000,000 points!";
					strcpy( trophyCString, trophyString.c_str() );

					trophyMessageSprite.setImage( trophyMessageImage[3] );
					showTrophyMessage = true;

					// flurry log trophy
					if( hasFlurry )
					{
						char cstring[50] = "Pressed Trophy1mill (no trophy)";
						s3eFlurryLogEvent( cstring, false );
					}
				}
				break;
			case 6:
				if( trophies[4] == false ) // beat game
				{
					trophyString = "How to get Trophy: Beat the game!";
					strcpy( trophyCString, trophyString.c_str() );

					trophyMessageSprite.setImage( trophyMessageImage[4] );
					showTrophyMessage = true;

					// flurry log trophy
					if( hasFlurry )
					{
						char cstring[50] = "Pressed TrophyFuzzyHero (no trophy)";
						s3eFlurryLogEvent( cstring, false );
					}
				}
				break;
			case 7: // messages for trophies already obtained
				if( trophies[0] == true ) // 100,000 points
				{
					trophyString = "Woo hoo! You got a high score of 100,000 points!";
					strcpy( trophyCString, trophyString.c_str() );

					trophyMessageSprite.setImage( trophyMessageImage[5] );
					showTrophyMessage = true;

					// flurry log trophy
					if( hasFlurry )
					{
						char cstring[50] = "Pressed Trophy100k (YES trophy)";
						s3eFlurryLogEvent( cstring, false );
					}
				}

				
				break;
			case 8:
				if( trophies[1] == true ) // 500,000 points
				{
					trophyString = "Insane! You got a high score of 500,000 points!!";
					strcpy( trophyCString, trophyString.c_str() );

					trophyMessageSprite.setImage( trophyMessageImage[6] );
					showTrophyMessage = true;

					// flurry log trophy
					if( hasFlurry )
					{
						char cstring[50] = "Pressed Trophy500k (YES trophy)";
						s3eFlurryLogEvent( cstring, false );
					}
				}
				break;
			case 9:
				if( trophies[2] == true ) // rate app
				{
					trophyString = "You are a Fuzzy Reviewer! Thanks for rating our App!";
					strcpy( trophyCString, trophyString.c_str() );

					trophyMessageSprite.setImage( trophyMessageImage[7] );
					showTrophyMessage = true;

					// flurry log trophy
					if( hasFlurry )
					{
						char cstring[50] = "Pressed TrophyRate (YES trophy)";
						s3eFlurryLogEvent( cstring, false );
					}
				}
				break;
			case 10:
				if( trophies[3] == true ) // 1 million points
				{
					trophyString = "You are a fuzzy Master!! You got a high score of 1,000,000 points!!!";
					strcpy( trophyCString, trophyString.c_str() );

					trophyMessageSprite.setImage( trophyMessageImage[8] );
					showTrophyMessage = true;

					// flurry log trophy
					if( hasFlurry )
					{
						char cstring[50] = "Pressed Trophy1mill (YES trophy)";
						s3eFlurryLogEvent( cstring, false );
					}
				}
				break;
			case 11:
				if( trophies[4] == true ) // beat game
				{
					trophyString = "You are THE Fuzzy Hero! You have cleared the entire game!!!";
					strcpy( trophyCString, trophyString.c_str() );

					trophyMessageSprite.setImage( trophyMessageImage[9] );
					showTrophyMessage = true;

					// flurry log trophy
					if( hasFlurry )
					{
						char cstring[50] = "Pressed TrophyFuzzyHero (YES trophy)";
						s3eFlurryLogEvent( cstring, false );
					}
				}
				break;
			}
		}		

		menuScreen[1].button[i].initialPressed = false;
		menuScreen[1].button[i].pressed = false;
	}
}

void ReleaseCreditsMenuScreenButtons()
{
	for( int i = 0; i < menuScreen[2].buttonCount; i++ )
	{		
		if( menuScreen[2].button[i].pressed == true && limbo == false )
		{
		
			// load the levels depending on what 'i' is.
			switch( i )
			{
			case 0: // this is Play end cinematics if unlocked

				break;
			case 1:

				menuScreen[2].setStartingPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );
				menuScreen[2].setEndingPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight() * 2 );
				menuScreen[2].setInterpolationTime( 500 );
				menuScreen[2].setAcceleration( 100, 2);
				
				GameState = AT_MENU;
				ResetMenuButtonBobble();

				break;
			}
		}

		menuScreen[2].button[i].initialPressed = false;
		menuScreen[2].button[i].pressed = false;
	}
}

void ReleaseTutorialMenuScreenButtons()
{
	for( int i = 0; i < menuScreen[3].buttonCount; i++ )
	{		
		if( menuScreen[3].button[i].pressed == true && limbo == false )
		{
			switch( i )
			{
			case 0:
				menuScreen[3].setStartingPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );
				menuScreen[3].setEndingPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight() * 2 );
				menuScreen[3].setInterpolationTime( 500 );
				menuScreen[3].setAcceleration( 100, 2);
				
				GameState = AT_MENU;
				ResetMenuButtonBobble();
				break;

			// play tutorial videos
			case 1:
				//s3eVideoPlay("tutorial_howto.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );				
				playedTutorialAtMenu = true;
				playingTutorialHowToFromMenu = true;

				limbo = true;

				TargetState = PLAY_CINEMATIC;
				transition = true;
				transitionIsSet = false;

				// flurry log tutorial
				if( hasFlurry )
				{
					char cstring[50] = "Pressed Tutorial Basic";
					s3eFlurryLogEvent( cstring, false );
				}
				break;
			case 2:
				//s3eVideoPlay("tutorial_warnings.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );
				playedTutorialAtMenu = true;
				playingTutorialWarningsFromMenu = true;

				limbo = true;

				TargetState = PLAY_CINEMATIC;
				transition = true;
				transitionIsSet = false;
				
				// flurry log tutorial
				if( hasFlurry )
				{
					char cstring[50] = "Pressed Tutorial Warnings";
					s3eFlurryLogEvent( cstring, false );
				}
				break;
			case 3:
				//s3eVideoPlay("tutorial_bomb.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );
				playedTutorialAtMenu = true;
				playingTutorialBombFromMenu = true;

				limbo = true;

				TargetState = PLAY_CINEMATIC;
				transition = true;
				transitionIsSet = false;

				// flurry log tutorial
				if( hasFlurry )
				{
					char cstring[50] = "Pressed Tutorial Bombs";
					s3eFlurryLogEvent( cstring, false );
				}
				break;
			}
		}

		menuScreen[3].button[i].initialPressed = false;
		menuScreen[3].button[i].pressed = false;
	}
}

void ReleaseScoreScreenButtons()
{
	if( quitButton.pressed == true && limbo == false )
	{
		// enable quit confirmation
		enableQuitConfirmationScreen = true;

		playLandSound();

		// flurry log quit
		if( hasFlurry )
		{
			char cstring[50] = "Pressed ScoreScreen - Quit";
			s3eFlurryLogEvent( cstring, false );
		}

		/*
		transition = true;
		transitionIsSet = false;
		TargetState = AT_LOADING_MENU;

		playingStory = false;
		gameOver = false;

		limbo = true;

		// target episode is automatically saved
		levelNumber = 1;

		ResetScoreAndLives();
		Save();

		// flurry log stop of episode-start-event
		if( hasFlurry )
		{
			s3eFlurryEndTimedEvent( timedEvent );
		}

		// flurry log quit
		if( hasFlurry )
		{
			char cstring[50] = "Pressed ScoreScreen - Quit";
			s3eFlurryLogEvent( cstring, false );
		}
		*/
	}

	if( restartButton.pressed == true && limbo == false  )
	{
		if( storyMode == true )
		{			
			// new restart method, should save state
			// load levels
			storyMode = true;
			limbo = true;

			// here
			if( gameOver == true )
			{
				targetEpisode = episode;


				// transition to loading levels			
				TargetState = PLAY_GAME;
				transition = true;				
				transitionIsSet = false;

				ResetScoreAndLives();
				Save();

				gameOver = false;	
			}
			else
			{
				targetEpisode = episode; // maintain initializing same episode

				// transition to loading levels. load when transition is finished
				TargetState = PLAY_CINEMATIC;
				transition = true;
				transitionIsSet = false;
			}

			SaveTargetEpisode();
			levelNumber = 1; // this is important for initialization. targetEpisode is already loaded

			// old restart method
			/* 
			transition = true;
			transitionIsSet = false;
			TargetState = PLAY_GAME;

			targetEpisode = episode;
			levelNumber = 1;

			ResetScoreAndLives();
			Save(); 

			limbo = true;
			*/

			// flurry log stop of episode-start-event
			if( hasFlurry )
			{
				s3eFlurryEndTimedEvent( timedEvent );
			}

			// flurry log restart
			if( hasFlurry )
			{
				char cstring[50] = "Pressed ScoreScreen - Restart";
				s3eFlurryLogEvent( cstring, false );
			}

			// flurry log start
			if( hasFlurry )
			{
				char cstring[50] = "Started episode: ";
				strcat( cstring, intToChar(targetEpisode) );
				s3eFlurryLogEvent( cstring, true );

				// this necessary to stop the TimedLogEvent
				strcpy( timedEvent, cstring );
			}
		}
		else if( qfiMode == true )
		{
			InitializeDifficulty(1);
			TargetState = PLAY_GAME;
		}
		else if( challengeMode == true )
		{
			
		}
		else if( developerLevels == true )
		{
			GameState = CHOOSE_DIFFICULTY;
		}
	}

	if( nextButton.pressed == true && limbo == false )
	{
		if( storyMode == true )
		{
			transition = true;
			transitionIsSet = false;
			TargetState = PLAY_CINEMATIC;

			if( episode >= 1 && episode <= 3 )
			{
				if( levelNumber == 10 )
				{
					targetEpisode = episode + 1;
					levelNumber = 1;

					limbo = true;
				}

				if( episode == 3 && levelNumber == 7 )
				{
					ep3TimerStart = true;
				}
			}
			else
			{
				if( levelNumber == 6 )
				{
					// let target episode go to 7
					targetEpisode = episode + 1;
					levelNumber = 1;

					limbo = true;
				}
			}
		}

		// flurry log next
		if( hasFlurry )
		{
			char cstring[50] = "Pressed ScoreScreen - Next";
			s3eFlurryLogEvent( cstring, false );
		}
	}

	quitButton.initialPressed = false;
	quitButton.pressed = false;
	restartButton.initialPressed = false;
	restartButton.pressed = false;
	nextButton.initialPressed = false;
	nextButton.pressed = false;
}

void ReleasePausedButtons()
{
	// testing			
	if( testButton.pressed == true ) // Test Button
	{
		// raise volume no matter what paused button is pressed
		//raiseVolume();
		
		//playTestSound();
				
		if( storyMode == true && limbo == false )
		{
			transition = true;
			transitionIsSet = false;
			if( episode >= 1 && episode <= 3 )
			{
				levelNumber = 10;
			}
			else
			{
				levelNumber = 6;
			}
			TargetState = AT_SCORE_SCREEN;

			playingStory = false;
			gameOver = false;
			advanceToNextLevel = true;

			limbo = true;

			// flurry log stop of episode-start-event
			if( hasFlurry )
			{
				s3eFlurryEndTimedEvent( timedEvent );
			}
		}
		
		
		//s3eVideoPlay("example.3gp", 1, 0, 0, s3eSurfaceGetInt(S3E_SURFACE_WIDTH), s3eSurfaceGetInt(S3E_SURFACE_HEIGHT)); // play movie
		//s3eVideoPlay("cinema1-4.3gp", 1, 0, 0, s3eSurfaceGetInt(S3E_SURFACE_WIDTH), s3eSurfaceGetInt(S3E_SURFACE_HEIGHT)); // play movie
		//s3eVideoPlay("cinema1.mp4", 1, 0, 0, IwGxGetScreenWidth(), IwGxGetScreenHeight() );
	}
	
	// Release paused button
	if( resumeButton.pressed == true && limbo == false ) // Pause Button
	{		
		// raise volume no matter what paused button is pressed
		//raiseVolume();

		if( atTutorial == true )
		{
			GameState = PLAY_TUTORIAL;
		}
		else
		{
			GameState = PLAY_GAME;
		}

		// flurry log resume
		if( hasFlurry )
		{
			char cstring[50] = "Pressed Paused - Resume";
			s3eFlurryLogEvent( cstring, false );
		}
	}

	if( quitButton.pressed == true && limbo == false )
	{
		// enable quit confirmation
		enableQuitConfirmationScreen = true;

		playLandSound();

		// flurry log resume
		if( hasFlurry )
		{
			char cstring[50] = "Pressed Quit";
			s3eFlurryLogEvent( cstring, false );
		}
	}

	if( restartButton.pressed == true && limbo == false )
	{
		// raise volume no matter what paused button is pressed
		//raiseVolume();

		if( storyMode == true )
		{			
			// new restart method, should save state
			// load levels
			storyMode = true;
			// transition to loading levels. load when transition is finished
			TargetState = PLAY_GAME;
			transition = true;				
			transitionIsSet = false;
				
			limbo = true;
			gameOver = false;

			targetEpisode = episode; // maintain initializing same episode
			SaveTargetEpisode();
			levelNumber = 1; // this is important for initialization. targetEpisode is already loaded

			/* old restart method
			transition = true;
			transitionIsSet = false;
			TargetState = PLAY_GAME;
				
			targetEpisode = episode;
			levelNumber = 1;
			ResetScoreAndLives();
			// checkpoint
			startAtCheckpoint = false;

			Save();			

			limbo = true;
			*/

			// flurry log stop of episode-start-event
			if( hasFlurry )
			{
				s3eFlurryEndTimedEvent( timedEvent );
			}

			// flurry log restart
			if( hasFlurry )
			{
				char cstring[50] = "Pressed Paused - Restart";
				s3eFlurryLogEvent( cstring, false );
			}

			// flurry log start
			if( hasFlurry )
			{
				char cstring[50] = "Started episode: ";
				strcat( cstring, intToChar(targetEpisode) );
				s3eFlurryLogEvent( cstring, true );

				// this necessary to stop the TimedLogEvent
				strcpy( timedEvent, cstring );
			}
		}
		else if( qfiMode == true )
		{
			InitializeDifficulty(1);
			GameState = PLAY_GAME;
		}
		else if( challengeMode == true )
		{
			setWhiteFadeOut( 1000 );
			TransitionState = START_GAME;
		}
		else if( developerLevels == true )
		{
			GameState = CHOOSE_DIFFICULTY;
		}
	}

	testButton.pressed = false;
	testButton.initialPressed = false;
	resumeButton.initialPressed = false;
	resumeButton.pressed = false;
	quitButton.initialPressed = false;
	quitButton.pressed = false;
	restartButton.initialPressed = false;
	restartButton.pressed = false;
}

void ReleaseQuitConfirmationButtons()
{
	for( int i = 0; i < quitConfirmationScreen.buttonCount; i++ )
	{		
		if( quitConfirmationScreen.button[i].pressed == true && limbo == false )
		{
			switch( i )
			{
			case 0:
				// QUIT

				// raise volume no matter what paused button is pressed
				//raiseVolume();
				transition = true;
				transitionIsSet = false;
				TargetState = AT_LOADING_MENU;

				playingStory = false;
				gameOver = false;

				limbo = true;
				levelNumber = 1;

				SaveHighStats();

				// release the quit confirmation screen
				enableQuitConfirmationScreen = false;

				// flurry log stop of episode-start-event
				if( hasFlurry )
				{
					s3eFlurryEndTimedEvent( timedEvent );
				}

				if( GameState == AT_SCORE_SCREEN )
				{
					// flurry log quit confirmation
					if( hasFlurry )
					{
						char cstring[50] = "Pressed ScoreScreen Quit Confirmation-YES";
						s3eFlurryLogEvent( cstring, false );
					}
				}
				else if( GameState == PAUSED )
				{
					// flurry log quit confirmation
					if( hasFlurry )
					{
						char cstring[50] = "Pressed PauseScreen Quit Confirmation-YES";
						s3eFlurryLogEvent( cstring, false );
					}
				}
				break;
			case 1:
				// Cancel and do not quit. Go back to paused screen
				enableQuitConfirmationScreen = false;

				if( GameState == AT_SCORE_SCREEN )
				{
					// flurry log quit confirmation
					if( hasFlurry )
					{
						char cstring[50] = "Pressed ScoreScreen Quit Confirmation-NO";
						s3eFlurryLogEvent( cstring, false );
					}
				}
				else if( GameState == PAUSED )
				{
					// flurry log quit confirmation
					if( hasFlurry )
					{
						char cstring[50] = "Pressed PauseScreen Quit Confirmation-NO";
						s3eFlurryLogEvent( cstring, false );
					}
				}
				break;
			}
		}

		quitConfirmationScreen.button[i].initialPressed = false;
		quitConfirmationScreen.button[i].pressed = false;
	}
}


void ReleaseNewStoryConfirmationButtons()
{
	for( int i = 0; i < newStoryConfirmationScreen.buttonCount; i++ )
	{		
		if( newStoryConfirmationScreen.button[i].pressed == true && limbo == false )
		{
			switch( i )
			{
			case 0:
				// newStory

				// load levels
				storyMode = true;				
				// transition to loading levels. load when transition is finished
				TargetState = AT_LOADING_LEVEL;
				transition = true;				
				transitionIsSet = false;
				
				//GameState = AT_LOADING_LEVEL;
				targetEpisode = 1;
				levelNumber = 1;
				scoreLivesBonusBucket = 0;
				limbo = true;

				// checkpoint
				startAtCheckpoint = false;

				Save(); // this saves the state

				// flurry log new Story confirmation
				if( hasFlurry )
				{
					char cstring[50] = "Pressed New Story Confirmation-YES";
					s3eFlurryLogEvent( cstring, false );
				}

				enableNewStoryConfirmationScreen = false;

				// set tutorial watch
				playedHowToTutorialOnce = false;
				playedBombTutorialOnce = false;
				playedWarningTutorialOnce = false;

				break;
			case 1:
				// Cancel and do not quit. Go back to paused screen
				enableNewStoryConfirmationScreen = false;

				ResetMenuButtonBobble();

				// flurry log new story confirmation
				if( hasFlurry )
				{
					char cstring[50] = "Pressed New Story Confirmation-NO";
					s3eFlurryLogEvent( cstring, false );
				}
				break;
			}
		}

		newStoryConfirmationScreen.button[i].initialPressed = false;
		newStoryConfirmationScreen.button[i].pressed = false;
	}
}

void ReleaseDifficultyButtons()
{
	// Release difficulty buttons
	if( difficultyStartButton.pressed == true )
	{
		switch( planeSpawning )
		{
		case SINGLE_RANDOM:
			planeSpawning = DOUBLE_ADJACENT;
			break;
		case DOUBLE_ADJACENT:
			planeSpawning = DOUBLE_RANDOM;
			break;
		case DOUBLE_RANDOM:
			planeSpawning = TRIPLE_RANDOM;
			break;
		case TRIPLE_RANDOM:
			planeSpawning = QUADRUPLE_RANDOM;
			break;
		case QUADRUPLE_RANDOM:
			planeSpawning = QUINTUPLE_RANDOM;
			break;
		case QUINTUPLE_RANDOM: 
			planeSpawning = SEXTUPLE;
			break;
		case SEXTUPLE:
			planeSpawning = SINGLE_RANDOM;
			break;
		}
	}
	if( difficultyEasyButton.pressed == true ) // Pause Button
	{		
		
		switch( cubeSpawning )
		{
		case SINGLE_RANDOM:
			cubeSpawning = SEXTUPLE_RANDOM;
			break;
		case DOUBLE_INCOLOR:
			cubeSpawning = SINGLE_RANDOM;
			break;
		case DOUBLE_RANDOM:
			cubeSpawning = DOUBLE_INCOLOR;
			break;
		case TRIPLE_INCOLOR:
			cubeSpawning = DOUBLE_RANDOM;
			break;
		case TRIPLE_RANDOM: 
			cubeSpawning = TRIPLE_INCOLOR;
			break;
		case QUADRUPLE_INCOLOR:
			cubeSpawning = TRIPLE_RANDOM;
			break;
		case QUADRUPLE_RANDOM:
			cubeSpawning = QUADRUPLE_INCOLOR;
			break;
		case QUINTUPLE_INCOLOR:
			cubeSpawning = QUADRUPLE_RANDOM;
			break;
		case QUINTUPLE_RANDOM:
			cubeSpawning = QUINTUPLE_INCOLOR;
			break;
		case SEXTUPLE_INCOLOR:
			cubeSpawning = QUINTUPLE_RANDOM;
			break;
		case SEXTUPLE_RANDOM:
			cubeSpawning = SEXTUPLE_INCOLOR;
			break;
		}
	}

	if( difficultyMediumButton.pressed == true ) // Pause Button
	{		
		switch( cubeSpawning )
		{
		case SINGLE_RANDOM:
			cubeSpawning = DOUBLE_INCOLOR;
			break;
		case DOUBLE_INCOLOR:
			cubeSpawning = DOUBLE_RANDOM;
			break;
		case DOUBLE_RANDOM:
			cubeSpawning = TRIPLE_INCOLOR;
			break;
		case TRIPLE_INCOLOR:
			cubeSpawning = TRIPLE_RANDOM;
			break;
		case TRIPLE_RANDOM: 
			cubeSpawning = QUADRUPLE_INCOLOR;
			break;
		case QUADRUPLE_INCOLOR:
			cubeSpawning = QUADRUPLE_RANDOM;
			break;
		case QUADRUPLE_RANDOM:
			cubeSpawning = QUINTUPLE_INCOLOR;
			break;
		case QUINTUPLE_INCOLOR:
			cubeSpawning = QUINTUPLE_RANDOM;
			break;
		case QUINTUPLE_RANDOM:
			cubeSpawning = SEXTUPLE_INCOLOR;
			break;
		case SEXTUPLE_INCOLOR:
			cubeSpawning = SEXTUPLE_RANDOM;
			break;
		case SEXTUPLE_RANDOM:
			cubeSpawning = SINGLE_RANDOM;
			break;
		}
	}

	if( difficultyHardButton.pressed == true ) // Pause Button
	{		
		switch( INITIAL_SPEED )
		{
		case 100:
			INITIAL_SPEED = 200;
			break;
		case 200:
			INITIAL_SPEED = 300;
			break;
		case 300:
			INITIAL_SPEED = 400;
			break;
		case 400:
			INITIAL_SPEED = 600;
			break;
		case 600:
			INITIAL_SPEED = 800;
			break;
		case 800:
			INITIAL_SPEED = 1000;
			break;
		case 1000:
			INITIAL_SPEED = 100;
			break;
		}
	}

	if( testButton.pressed == true )
	{
		InitializeDifficulty( 1 );
		GameState = PLAY_GAME;
	}

	testButton.pressed = false;
	testButton.initialPressed = false;

	difficultyStartButton.pressed = false;
	difficultyStartButton.initialPressed = false;
	difficultyEasyButton.pressed = false;
	difficultyEasyButton.initialPressed = false;
	difficultyMediumButton.initialPressed = false;
	difficultyMediumButton.pressed = false;
	difficultyHardButton.initialPressed = false;
	difficultyHardButton.pressed = false;
}

void ReleaseMenuButtons()
{
	for( int i = 0; i < numOfActiveMenuCubes; i++ )
	{
		if( menuCubes[i].type == MenuCube::NEW ) // load QFI
		{
			if( menuCubes[i].button.pressed == true && limbo == false)
			{
				// Activates Game

				if( targetEpisode != 1 || (targetEpisode == 1 && startAtCheckpoint == true) )
				{
					enableNewStoryConfirmationScreen = true;

					// flurry log play
					if( hasFlurry )
					{
						char cstring[50] = "Pressed Menu-Play";
						s3eFlurryLogEvent( cstring, false );
					}

					menuCubes[i].continueBobble = true;
				}
				else
				{
					// load levels
					storyMode = true;				
					// transition to loading levels. load when transition is finished
					TargetState = AT_LOADING_LEVEL;
					transition = true;				
					transitionIsSet = false;
				
					//GameState = AT_LOADING_LEVEL;
					targetEpisode = 1;
					levelNumber = 1;
					scoreLivesBonusBucket = 0;
					limbo = true;

					// checkpoint
					startAtCheckpoint = false;

					Save(); // this saves the state

					menuCubes[i].continueBobble = true;

					// flurry log play
					if( hasFlurry )
					{
						char cstring[50] = "Pressed Menu-Play";
						s3eFlurryLogEvent( cstring, false );
					}

					// set tutorial watch
					playedHowToTutorialOnce = false;
					playedBombTutorialOnce = false;
					playedWarningTutorialOnce = false;
				}
			}
		}
		else if( menuCubes[i].type == MenuCube::CONTINUE )
		{
			if( menuCubes[i].button.pressed == true && limbo == false)
			{
				// Activates Game

				// load levels
				storyMode = true;
				// transition to loading levels. load when transition is finished
				TargetState = AT_LOADING_LEVEL;
				transition = true;				
				transitionIsSet = false;
				
				//GameState = AT_LOADING_LEVEL;
				//targetEpisode = 1; this was already loaded. use this for New game. this release is Continue game for now
				//levelNumber = 1;
				//livesGained = 0;
				limbo = true;
				levelNumber = 1; // this is important for initialization. targetEpisode is already loaded

				menuCubes[i].continueBobble = true;

				// flurry log continue
				if( hasFlurry )
				{
					char cstring[50] = "Pressed Menu-Continue";
					s3eFlurryLogEvent( cstring, false );
				}
			}
		}
		/*
		else if( menuCubes[i].type ==  MenuCube::TUTORIAL ) // load tutorial
		{
			if( menuCubes[i].button.pressed == true )
			{
				GameState = AT_LOADING_TUTORIAL;
			}
		}
		else if( menuCubes[i].type ==  MenuCube::CREDITS ) // load iads
		{
			if( menuCubes[i].button.pressed == true )
			{
				//LoadBigImages();
				// initialize iAd
				s3eInetAddress addr;
				if( s3eInetLookup( "www.apple.com", &addr, NULL, NULL) == S3E_RESULT_ERROR )
				{
					printf("\n\n Lookup failed!! \n");
				}
				else
				{
					if( hasIAd == true )
					{
						s3eIOSIAdStart();				
					}
				}
			}
		}
		else if( menuCubes[i].type ==  MenuCube::HIGH_SCORE ) // close iads, load developerLevels
		{
			if( menuCubes[i].button.pressed == true )
			{
				if( hasIAd == true ) //initialize high score screen
				{
					if( s3eIOSIAdGetInt( S3E_IOSIAD_RUNNING ) == 1 )
					{
						if( s3eIOSIAdGetInt( S3E_IOSIAD_BANNER_LOADED ) == 1 )
						{
							s3eIOSIAdSetInt( S3E_IOSIAD_BANNER_SHOW, 0 );
						}
						s3eIOSIAdStop();
					}
				}
				developerLevels = true;
				planeSpawning = DOUBLE_ADJACENT;
				cubeSpawning = DOUBLE_INCOLOR;
				INITIAL_SPEED = 800;
				GameState = AT_LOADING_LEVEL;
			}
		}
		*/
		else if( menuCubes[i].type ==  MenuCube::CHALLENGE ) // load challenge menu
		{
			if( menuCubes[i].button.pressed == true )
			{
				menuScreen[0].setStartingPosition( IwGxGetScreenWidth()/2, -IwGxGetScreenHeight()/2 );
				menuScreen[0].setEndingPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );
				menuScreen[0].setInterpolationTime( 500 );
				menuScreen[0].setDeceleration( 100, -2);
				GameState = AT_CHALLENGE_MENU_SCREEN;

				menuCubes[i].continueBobble = true;
			}
		}
		else if( menuCubes[i].type ==  MenuCube::HIGH_SCORE ) // load challenge menu
		{
			if( menuCubes[i].button.pressed == true )
			{
				menuScreen[1].setStartingPosition( IwGxGetScreenWidth()/2, -IwGxGetScreenHeight()/2 );
				menuScreen[1].setEndingPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );
				menuScreen[1].setInterpolationTime( 500 );
				menuScreen[1].setDeceleration( 100, -2);
				GameState = AT_HIGH_SCORE_MENU_SCREEN;

				menuCubes[i].continueBobble = true;

				// flurry log highscore
				if( hasFlurry )
				{
					char cstring[50] = "Pressed Menu-HighScore";
					s3eFlurryLogEvent( cstring, false );
				}
			}
		}
		else if( menuCubes[i].type ==  MenuCube::CREDITS ) // load challenge menu
		{
			if( menuCubes[i].button.pressed == true )
			{
				menuScreen[2].setStartingPosition( IwGxGetScreenWidth()/2, -IwGxGetScreenHeight()/2 );
				menuScreen[2].setEndingPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );
				menuScreen[2].setInterpolationTime( 500 );
				menuScreen[2].setDeceleration( 100, -2);
				GameState = AT_CREDITS_MENU_SCREEN;

				menuCubes[i].continueBobble = true;

				// flurry log credits
				if( hasFlurry )
				{
					char cstring[50] = "Pressed Menu-Credits";
					s3eFlurryLogEvent( cstring, false );
				}
			}
		}
		else if( menuCubes[i].type ==  MenuCube::TUTORIAL ) // load challenge menu
		{
			if( menuCubes[i].button.pressed == true )
			{
				menuScreen[3].setStartingPosition( IwGxGetScreenWidth()/2, -IwGxGetScreenHeight()/2 );
				menuScreen[3].setEndingPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );
				menuScreen[3].setInterpolationTime( 500 );
				menuScreen[3].setDeceleration( 100, -2);
				GameState = AT_TUTORIAL_MENU_SCREEN;

				menuCubes[i].continueBobble = true;

				// flurry log highscore
				if( hasFlurry )
				{
					char cstring[50] = "Pressed Menu-Tutorial";
					s3eFlurryLogEvent( cstring, false );
				}
			}
		}
		else if( menuCubes[i].type == MenuCube::RAP_RECORD )
		{
			if( menuCubes[i].button.pressed == true && limbo == false)
			{
				if( trophies[4] == true )
				{
					TargetState = PLAY_CINEMATIC;
					transition = true;				
					transitionIsSet = false;

					limbo = true;

					// play rap video
					playingRapVideoFromMenu = true;

					menuCubes[i].continueBobble = true;
					
				}

				// flurry log question mark
				if( hasFlurry )
				{
					char cstring[50] = "Pressed Menu-Play Rap Video";
					s3eFlurryLogEvent( cstring, false );
				}
			}
		}
		else if( menuCubes[i].type == MenuCube::QUESTION_MARK )
		{
			if( menuCubes[i].button.pressed == true && limbo == false)
			{
				showQuestionMarkScreen = true;
				menuCubes[i].continueBobble = true;

				// flurry log question mark
				if( hasFlurry )
				{
					char cstring[50] = "Pressed Menu-Question Mark";
					s3eFlurryLogEvent( cstring, false );
				}
			}
		}
	}


	// release all variables and states

	for( int i = 0; i < numOfActiveMenuCubes; i++ )
	{
		menuCubes[i].button.pressed = false;
		menuCubes[i].button.initialPressed = false;
	}
} // end of ReleaseMenuButtons()

void ResetMenuButtonBobble()
{
	for( int i = 0; i < numOfActiveMenuCubes; i++ )
	{
		menuCubes[i].continueBobble = false;
	}
}

// Plane Side Spawning
void ActivateOneSide()
{
	int16 a = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
	while( plane[a].active == true ) // 'a' side cannot be equal to plane just deactivated. i here is not direction of plane, just index for diff. planes
	{
		a = IwRandMinMax( 0, 5+1 );
	}
	plane[a].active = true;
}

void ActivateTwoSides()
{
	int16 a = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
	int16 b = IwRandMinMax( 0, 5+1 );
	while( plane[a].active == true ) // 'a' side cannot be equal to plane just deactivated. i here is not direction of plane, just index for diff. planes
	{
		a = IwRandMinMax( 0, 5+1 );
	}
	plane[a].active = true;

	while( plane[b].active == true ) // b cannot be equal to a or i
	{
		b = IwRandMinMax( 0, 5+1 );
	}
	plane[b].active = true;
}

void DeactivateSide( int16 i )
{
	plane[i].active = false;
	plane[i].resetCounts();
}

void ActivateOneAdjacentSide( int16 b )
{
	int16 dir;
	int16 a;  // the indexes for planes datastructure

	do
	{
		dir = getAdjacentDirection( plane[b].direction );

		// find a, index of plane with the adjacent direction
		for( int j = 0; j < 6; j++ )
		{
			if( plane[j].direction == dir )
			{
				a = j;
				break;
			}
		}
	}
	while( plane[a].active == true );

	// activate the new plane
	plane[a].active = true;
}

void RotateMovingCubesRight()
{
	// prevents moving cubes from being updated and interrupting interpolation
	movingCubesAreRotating = true;

	// the initial rotation rotates several things instantly to final rotation before interpolation
	// must happen just once
	if( rotateMovingVerticesRight_firstIterationFinished == false )
	{
		// copy side vertices into interpolation arrays
		// Actually, use interpolation arrays as temp array to store copy of exact rotation
		rotateMovingVerticesRight_firstIterationFinished = true; // makes sure that this does not run again

		// when rotating the static cube, need to transform the cubes' positions as well as their display vertices
		srm.SetRotY( 1024 );

		// ROTATE MOVING CUBES
		for( int i = 0; i < numMovingCubesIndex; i++ )
		{
			// do NOT rotate faceside 5 and 6 cubes.
			if( cubeArrayMoving[i].direction != 5 && cubeArrayMoving[i].direction != 6 )
			{
				movingCubePositionsTemp[i] = srm.TransformVec( cubeArrayMoving[i].position ); // this only affects future collision
			}

			// change their direction and also the shadow's directions
			switch( cubeArrayMoving[i].direction )
			{
			case 1:
				cubeArrayMoving[i].direction = 2;
				break;
			case 2:
				cubeArrayMoving[i].direction = 3;
				break;
			case 3:
				cubeArrayMoving[i].direction = 4;
				break;
			case 4:
				cubeArrayMoving[i].direction = 1;
				break;
			}
		}

		// ROTATE THE SHADOWS
		for( int i = 0; i < numShadowsIndex; i++ )
		{
			// do NOT rotate facesides 5 and 6. messes with boundaries
			if( shadowArray[i].direction != 5 && shadowArray[i].direction != 6 )
				shadowArray[i].position = srm.TransformVec( shadowArray[i].position );

			// set all their directions
			switch( shadowArray[i].direction )
			{
			case 1:
				shadowArray[i].setDirection( 2 ); // one BECOMES 2
				break;
			case 2:
				shadowArray[i].setDirection( 3 ); // setDirection also sets the vertices used for picking
				break;
			case 3:
				shadowArray[i].setDirection( 4 );
				break;
			case 4:
				shadowArray[i].setDirection( 1 );
				break;
			}

			// set their shadowVertices to correct one
			for( int j = 0; j < 24; j++ )
			{
				switch( shadowArray[i].direction )
				{
				case 1:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide1[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide1[j];
					break;
				case 2:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide2[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide2[j];
					break;
				case 3:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide3[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide3[j];
					break;
				case 4:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide4[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide4[j];
					break;
				}
			} // end of shadow vertices correction
		} // end of looping through shadow array
			
		// UPDATE THE SHADOW GROUP BOUNDS
		UpdateShadowGroupBounds();
	} // end of if-statement for first iteration of Rotation
		
	// set delta rotation for interpolation animation
	srm.SetRotY( deltaYMovingRotation );

	// ROTATE MOVING CUBES
	for( int i = 0; i < numMovingCubesIndex; i++ )
	{
		if( cubeArrayMoving[i].direction != 5 && cubeArrayMoving[i].direction != 6 )
		{
			cubeArrayMoving[i].position = srm.TransformVec( cubeArrayMoving[i].position );
		}
	}

	// ROTATE SHADOW VERTICES
	for( int i = 0; i < numShadowsIndex; i++ )
	{
		for( int j = 0; j < 24; j++ )
		{
			if( shadowArray[i].direction != 5 && shadowArray[i].direction != 6 )
			{
				shadowVerticesTranslated[i*24 + j] = srm.TransformVec( shadowVerticesTranslated[i*24 + j] );
				shadowVerticesTransparentTranslated[i*24+j] = srm.TransformVec( shadowVerticesTransparentTranslated[i*24+j] );
				shadowNormals[i*24 + j] = srm.TransformVec( shadowNormals[i*24 + j] );
			}
		}
	}

	// keeps track of how many degrees rotated
	cumulativeDeltaYRotation += deltaYMovingRotation;

	// When rotation has stopped
	if( cumulativeDeltaYRotation == 1024 ) // stops rotation if limit of degrees-of-rotation is reached
	{
		rotateMovingVerticesRight = false;
		rotateMovingVerticesRight_firstIterationFinished = false;
		movingCubesAreRotating = false; // allows moving cubes to move again and shadows to be updated
		cumulativeDeltaYRotation = 0; // reset the count			
		
		// reset final position
		for( int i = 0; i < numMovingCubesIndex; i++ )
		{
			if( cubeArrayMoving[i].direction != 5 && cubeArrayMoving[i].direction != 6 )
			{
				cubeArrayMoving[i].position = movingCubePositionsTemp[i];
			}
		}

	} // end of reset, end of final destination of rotation
} // end of RotateMovingCubesRight()

void RotateMovingCubesLeft()
{
	// prevents moving cubes from being updated and interrupting interpolation
	movingCubesAreRotating = true;

	// the initial rotation rotates several things instantly to final rotation before interpolation
	// must happen just once
	if( rotateMovingVerticesLeft_firstIterationFinished == false )
	{
		// copy side vertices into interpolation arrays
		// Actually, use interpolation arrays as temp array to store copy of exact rotation
		rotateMovingVerticesLeft_firstIterationFinished = true; // makes sure that this does not run again

		// when rotating the static cube, need to transform the cubes' positions as well as their display vertices
		srm.SetRotY( -1024 );

		// ROTATE MOVING CUBES
		for( int i = 0; i < numMovingCubesIndex; i++ )
		{
			// do NOT rotate faceside 5 and 6 cubes.
			if( cubeArrayMoving[i].direction != 5 && cubeArrayMoving[i].direction != 6 )
			{
				movingCubePositionsTemp[i] = srm.TransformVec( cubeArrayMoving[i].position ); // this only affects future collision
			}

			// change their direction and also the shadow's directions
			switch( cubeArrayMoving[i].direction )
			{
			case 1:
				cubeArrayMoving[i].direction = 4;
				break;
			case 2:
				cubeArrayMoving[i].direction = 1;
				break;
			case 3:
				cubeArrayMoving[i].direction = 2;
				break;
			case 4:
				cubeArrayMoving[i].direction = 3;
				break;
			}
		}

		// ROTATE THE SHADOWS
		for( int i = 0; i < numShadowsIndex; i++ )
		{
			// do NOT rotate facesides 5 and 6. messes with boundaries
			if( shadowArray[i].direction != 5 && shadowArray[i].direction != 6 )
				shadowArray[i].position = srm.TransformVec( shadowArray[i].position );

			// set all their directions
			switch( shadowArray[i].direction )
			{
			case 1:
				shadowArray[i].setDirection( 4 ); // shadow side 1 BECOMES 2
				break;
			case 2:
				shadowArray[i].setDirection( 1 ); // setDirection also sets the vertices used for picking
				break;
			case 3:
				shadowArray[i].setDirection( 2 );
				break;
			case 4:
				shadowArray[i].setDirection( 3 );
				break;
			}

			// set their shadowVertices to correct one
			for( int j = 0; j < 24; j++ )
			{
				switch( shadowArray[i].direction )
				{
				case 1:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide1[j]; // facesides correspond to direction b/c directions are already changed
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide1[j];
					break;
				case 2:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide2[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide2[j];
					break;
				case 3:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide3[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide3[j];
					break;
				case 4:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide4[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide4[j];
					break;
				}
			} // end of shadow vertices correction
		} // end of looping through shadow array
			
		// UPDATE THE SHADOW GROUP BOUNDS
		UpdateShadowGroupBounds();
	} // end of if-statement for first iteration of Rotation
		
	// set delta rotation for interpolation animation
	srm.SetRotY( -1*deltaYMovingRotation );

	// ROTATE MOVING CUBES
	for( int i = 0; i < numMovingCubesIndex; i++ )
	{
		if( cubeArrayMoving[i].direction != 5 && cubeArrayMoving[i].direction != 6 )
		{
			cubeArrayMoving[i].position = srm.TransformVec( cubeArrayMoving[i].position );
		}
	}

	// ROTATE SHADOW VERTICES
	for( int i = 0; i < numShadowsIndex; i++ )
	{
		for( int j = 0; j < 24; j++ )
		{
			if( shadowArray[i].direction != 5 && shadowArray[i].direction != 6 )
			{
				shadowVerticesTranslated[i*24 + j] = srm.TransformVec( shadowVerticesTranslated[i*24 + j] );
				shadowVerticesTransparentTranslated[i*24 + j] = srm.TransformVec( shadowVerticesTransparentTranslated[i*24 + j] );
				shadowNormals[i*24 + j] = srm.TransformVec( shadowNormals[i*24 + j] );
			}
		}
	}

	// keeps track of how many degrees rotated
	cumulativeDeltaYRotation += deltaYMovingRotation;

	// When rotation has stopped
	if( cumulativeDeltaYRotation == 1024 ) // stops rotation if limit of degrees-of-rotation is reached
	{
		rotateMovingVerticesLeft = false;
		rotateMovingVerticesLeft_firstIterationFinished = false;
		movingCubesAreRotating = false; // allows moving cubes to move again and shadows to be updated
		cumulativeDeltaYRotation = 0; // reset the count			

		for( int i = 0; i < numMovingCubesIndex; i++ )
		{
			if( cubeArrayMoving[i].direction != 5 && cubeArrayMoving[i].direction != 6 )
			{
				cubeArrayMoving[i].position = movingCubePositionsTemp[i];
			}
		}
		
	} // end of reset, end of final destination of rotation

} // end of RotateMovingCubesLeft()

void RotateMovingCubesUp()
{
	// prevents moving cubes from being updated and interrupting interpolation
	movingCubesAreRotating = true;

	// the initial rotation rotates several things instantly to final rotation before interpolation
	// must happen just once
	if( rotateMovingVerticesUp_firstIterationFinished == false )
	{
		// copy side vertices into interpolation arrays
		// Actually, use interpolation arrays as temp array to store copy of exact rotation
		rotateMovingVerticesUp_firstIterationFinished = true; // makes sure that this does not run again

		// when rotating the static cube, need to transform the cubes' positions as well as their display vertices
		srm.SetRotX( 1024 ); // set rotX for the up and down rotations

		// ROTATE MOVING CUBES
		for( int i = 0; i < numMovingCubesIndex; i++ )
		{
			// do NOT rotate faceside 2 and 4 cubes.
			if( cubeArrayMoving[i].direction != 2 && cubeArrayMoving[i].direction != 4 )
			{
				movingCubePositionsTemp[i] = srm.TransformVec( cubeArrayMoving[i].position ); // this only affects future collision
			}

			// change their direction and also the shadow's directions
			switch( cubeArrayMoving[i].direction )
			{
			case 1:
				cubeArrayMoving[i].direction = 5;
				break;
			case 3:
				cubeArrayMoving[i].direction = 6;
				break;
			case 5:
				cubeArrayMoving[i].direction = 3;
				break;
			case 6:
				cubeArrayMoving[i].direction = 1;
				break;
			}
		}

		// ROTATE THE SHADOWS
		for( int i = 0; i < numShadowsIndex; i++ )
		{
			// do NOT rotate facesides 2 and 4. messes with boundaries
			if( shadowArray[i].direction != 2 && shadowArray[i].direction != 4 )
				shadowArray[i].position = srm.TransformVec( shadowArray[i].position );

			// set all their directions
			switch( shadowArray[i].direction )
			{
			case 1:
				shadowArray[i].setDirection( 5 ); // one BECOMES 2
				break;
			case 3:
				shadowArray[i].setDirection( 6 ); // setDirection also sets the vertices used for picking
				break;
			case 5:
				shadowArray[i].setDirection( 3 );
				break;
			case 6:
				shadowArray[i].setDirection( 1 );
				break;
			}

			// set their shadowVertices to correct one
			for( int j = 0; j < 24; j++ )
			{
				switch( shadowArray[i].direction )
				{
				case 1:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide1[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide1[j];
					break;
				case 3:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide3[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide3[j];
					break;
				case 5:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide5[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide5[j];
					break;
				case 6:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide6[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide6[j];
					break;
				}
			} // end of shadow vertices correction
		} // end of looping through shadow array
			
		// UPDATE THE SHADOW GROUP BOUNDS
		UpdateShadowGroupBounds();
	} // end of if-statement for first iteration of Rotation
		
	// set delta rotation for interpolation animation
	srm.SetRotX( deltaYMovingRotation );

	// ROTATE MOVING CUBES
	for( int i = 0; i < numMovingCubesIndex; i++ )
	{
		if( cubeArrayMoving[i].direction != 2 && cubeArrayMoving[i].direction != 4 )
		{
			cubeArrayMoving[i].position = srm.TransformVec( cubeArrayMoving[i].position );
		}
	}

	// ROTATE SHADOW VERTICES
	for( int i = 0; i < numShadowsIndex; i++ )
	{
		for( int j = 0; j < 24; j++ )
		{
			if( shadowArray[i].direction != 2 && shadowArray[i].direction != 4 )
			{
				shadowVerticesTranslated[i*24 + j] = srm.TransformVec( shadowVerticesTranslated[i*24 + j] );
				shadowVerticesTransparentTranslated[i*24 + j] = srm.TransformVec( shadowVerticesTransparentTranslated[i*24 + j] );
				shadowNormals[i*24 + j] = srm.TransformVec( shadowNormals[i*24 + j] );
			}
		}
	}

	// keeps track of how many degrees rotated
	cumulativeDeltaYRotation += deltaYMovingRotation;

	// When rotation has stopped
	if( cumulativeDeltaYRotation == 1024 ) // stops rotation if limit of degrees-of-rotation is reached
	{
		rotateMovingVerticesUp = false;
		rotateMovingVerticesUp_firstIterationFinished = false;
		movingCubesAreRotating = false; // allows moving cubes to move again and shadows to be updated
		cumulativeDeltaYRotation = 0; // reset the count			

		// reset final position
		for( int i = 0; i < numMovingCubesIndex; i++ )
		{
			if( cubeArrayMoving[i].direction != 2 && cubeArrayMoving[i].direction != 4 )
			{
				cubeArrayMoving[i].position = movingCubePositionsTemp[i];
			}
		}
		
	} // end of reset, end of final destination of rotation
}// end of RotateMovingCubesUp()

void RotateMovingCubesDown()
{
	// prevents moving cubes from being updated and interrupting interpolation
	movingCubesAreRotating = true;

	// the initial rotation rotates several things instantly to final rotation before interpolation
	// must happen just once
	if( rotateMovingVerticesDown_firstIterationFinished == false )
	{
		// copy side vertices into interpolation arrays
		// Actually, use interpolation arrays as temp array to store copy of exact rotation
		rotateMovingVerticesDown_firstIterationFinished = true; // makes sure that this does not run again

		// when rotating the static cube, need to transform the cubes' positions as well as their display vertices
		srm.SetRotX( -1024 ); // set rotX for the up and down rotations

		// ROTATE MOVING CUBES
		for( int i = 0; i < numMovingCubesIndex; i++ )
		{
			// do NOT rotate faceside 2 and 4 cubes.
			if( cubeArrayMoving[i].direction != 2 && cubeArrayMoving[i].direction != 4 )
			{
				movingCubePositionsTemp[i] = srm.TransformVec( cubeArrayMoving[i].position ); // this only affects future collision
			}

			// change their direction and also the shadow's directions
			switch( cubeArrayMoving[i].direction )
			{
			case 1:
				cubeArrayMoving[i].direction = 6;
				break;
			case 3:
				cubeArrayMoving[i].direction = 5;
				break;
			case 5:
				cubeArrayMoving[i].direction = 1;
				break;
			case 6:
				cubeArrayMoving[i].direction = 3;
				break;
			}
		}

		// ROTATE THE SHADOWS
		for( int i = 0; i < numShadowsIndex; i++ )
		{
			// do NOT rotate facesides 2 and 4. messes with boundaries
			if( shadowArray[i].direction != 2 && shadowArray[i].direction != 4 )
				shadowArray[i].position = srm.TransformVec( shadowArray[i].position );

			// set all their directions
			switch( shadowArray[i].direction )
			{
			case 1:
				shadowArray[i].setDirection( 6 ); // one BECOMES 2
				break;
			case 3:
				shadowArray[i].setDirection( 5 ); // setDirection also sets the vertices used for picking
				break;
			case 5:
				shadowArray[i].setDirection( 1 );
				break;
			case 6:
				shadowArray[i].setDirection( 3 );
				break;
			}

			// set their shadowVertices to correct one
			for( int j = 0; j < 24; j++ )
			{
				switch( shadowArray[i].direction )
				{
				case 1:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide1[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide1[j];
					break;
				case 3:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide3[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide3[j];
					break;
				case 5:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide5[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide5[j];
					break;
				case 6:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide6[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide6[j];
					break;
				}
			} // end of shadow vertices correction
		} // end of looping through shadow array
			
		// UPDATE THE SHADOW GROUP BOUNDS
		UpdateShadowGroupBounds();
	} // end of if-statement for first iteration of Rotation
		
	// set delta rotation for interpolation animation
	srm.SetRotX( -1*deltaYMovingRotation );

	// ROTATE MOVING CUBES
	for( int i = 0; i < numMovingCubesIndex; i++ )
	{
		if( cubeArrayMoving[i].direction != 2 && cubeArrayMoving[i].direction != 4 )
		{
			cubeArrayMoving[i].position = srm.TransformVec( cubeArrayMoving[i].position );
		}
	}

	// ROTATE SHADOW VERTICES
	for( int i = 0; i < numShadowsIndex; i++ )
	{
		for( int j = 0; j < 24; j++ )
		{
			if( shadowArray[i].direction != 2 && shadowArray[i].direction != 4 )
			{
				shadowVerticesTranslated[i*24 + j] = srm.TransformVec( shadowVerticesTranslated[i*24 + j] );
				shadowVerticesTransparentTranslated[i*24 + j] = srm.TransformVec( shadowVerticesTransparentTranslated[i*24 + j] );
				shadowNormals[i*24 + j] = srm.TransformVec( shadowNormals[i*24 + j] );
			}
		}
	}

	// keeps track of how many degrees rotated
	cumulativeDeltaYRotation += deltaYMovingRotation;

	// When rotation has stopped
	if( cumulativeDeltaYRotation == 1024 ) // stops rotation if limit of degrees-of-rotation is reached
	{
		rotateMovingVerticesDown = false;
		rotateMovingVerticesDown_firstIterationFinished = false;
		movingCubesAreRotating = false; // allows moving cubes to move again and shadows to be updated
		cumulativeDeltaYRotation = 0; // reset the count			

		// reset final position
		for( int i = 0; i < numMovingCubesIndex; i++ )
		{
			if( cubeArrayMoving[i].direction != 2 && cubeArrayMoving[i].direction != 4 )
			{
				cubeArrayMoving[i].position = movingCubePositionsTemp[i];
			}
		}
		
	} // end of reset, end of final destination of rotation
}// end of RotateMovingCubesDown()

void RotateMovingCubesClockwise()
{
	// prevents moving cubes from being updated and interrupting interpolation
	movingCubesAreRotating = true;

	// the initial rotation rotates several things instantly to final rotation before interpolation
	// must happen just once
	if( rotateMovingVerticesClockwise_firstIterationFinished == false )
	{
		// copy side vertices into interpolation arrays
		// Actually, use interpolation arrays as temp array to store copy of exact rotation
		rotateMovingVerticesClockwise_firstIterationFinished = true; // makes sure that this does not run again

		// when rotating the static cube, need to transform the cubes' positions as well as their display vertices
		srm.SetRotZ( -1024 ); // set rotX for the clockwise and counterclockwise rotations

		// ROTATE MOVING CUBES
		for( int i = 0; i < numMovingCubesIndex; i++ )
		{
			// do NOT rotate faceside 1 and 3 cubes.
			if( cubeArrayMoving[i].direction != 1 && cubeArrayMoving[i].direction != 3 )
			{
				movingCubePositionsTemp[i] = srm.TransformVec( cubeArrayMoving[i].position ); // this only affects future collision
			}

			// change their direction and also the shadow's directions
			switch( cubeArrayMoving[i].direction )
			{
			case 2:
				cubeArrayMoving[i].direction = 6;
				break;
			case 4:
				cubeArrayMoving[i].direction = 5;
				break;
			case 5:
				cubeArrayMoving[i].direction = 2;
				break;
			case 6:
				cubeArrayMoving[i].direction = 4;
				break;
			}
		}

		// ROTATE THE SHADOWS
		for( int i = 0; i < numShadowsIndex; i++ )
		{
			// do NOT rotate facesides 1 and 3. messes with boundaries
			if( shadowArray[i].direction != 1 && shadowArray[i].direction != 3 )
				shadowArray[i].position = srm.TransformVec( shadowArray[i].position );

			// set all their directions
			switch( shadowArray[i].direction )
			{
			case 2:
				shadowArray[i].setDirection( 6 ); // one BECOMES 2
				break;
			case 4:
				shadowArray[i].setDirection( 5 ); // setDirection also sets the vertices used for picking
				break;
			case 5:
				shadowArray[i].setDirection( 2 );
				break;
			case 6:
				shadowArray[i].setDirection( 4 );
				break;
			}

			// set their shadowVertices to correct one
			for( int j = 0; j < 24; j++ )
			{
				switch( shadowArray[i].direction )
				{
				case 2:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide2[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide2[j];
					break;
				case 4:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide4[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide4[j];
					break;
				case 5:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide5[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide5[j];
					break;
				case 6:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide6[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide6[j];
					break;
				}
			} // end of shadow vertices correction
		} // end of looping through shadow array
			
		// UPDATE THE SHADOW GROUP BOUNDS
		UpdateShadowGroupBounds();
	} // end of if-statement for first iteration of Rotation
		
	// set delta rotation for interpolation animation
	srm.SetRotZ( -1*deltaYMovingRotation );

	// ROTATE MOVING CUBES
	for( int i = 0; i < numMovingCubesIndex; i++ )
	{
		if( cubeArrayMoving[i].direction != 1 && cubeArrayMoving[i].direction != 3 )
		{
			cubeArrayMoving[i].position = srm.TransformVec( cubeArrayMoving[i].position );
		}
	}

	// ROTATE SHADOW VERTICES
	for( int i = 0; i < numShadowsIndex; i++ )
	{
		for( int j = 0; j < 24; j++ )
		{
			if( shadowArray[i].direction != 1 && shadowArray[i].direction != 3 )
			{
				shadowVerticesTranslated[i*24 + j] = srm.TransformVec( shadowVerticesTranslated[i*24 + j] );
				shadowVerticesTransparentTranslated[i*24 + j] = srm.TransformVec( shadowVerticesTransparentTranslated[i*24 + j] );
				shadowNormals[i*24 + j] = srm.TransformVec( shadowNormals[i*24 + j] );
			}
		}
	}

	// keeps track of how many degrees rotated
	cumulativeDeltaYRotation += deltaYMovingRotation;

	// When rotation has stopped
	if( cumulativeDeltaYRotation == 1024 ) // stops rotation if limit of degrees-of-rotation is reached
	{
		rotateMovingVerticesClockwise = false;
		rotateMovingVerticesClockwise_firstIterationFinished = false;
		movingCubesAreRotating = false; // allows moving cubes to move again and shadows to be updated
		cumulativeDeltaYRotation = 0; // reset the count			
		
		// reset final position
		for( int i = 0; i < numMovingCubesIndex; i++ )
		{
			if( cubeArrayMoving[i].direction != 1 && cubeArrayMoving[i].direction != 3 )
			{
				cubeArrayMoving[i].position = movingCubePositionsTemp[i];
			}
		}
	} // end of reset, end of final destination of rotation
} // end of RotateMovingCubesClockwise()

void RotateMovingCubesCounterClockwise()
{
	// prevents moving cubes from being updated and interrupting interpolation
	movingCubesAreRotating = true;

	// the initial rotation rotates several things instantly to final rotation before interpolation
	// must happen just once
	if( rotateMovingVerticesCounterClockwise_firstIterationFinished == false )
	{
		// copy side vertices into interpolation arrays
		// Actually, use interpolation arrays as temp array to store copy of exact rotation
		rotateMovingVerticesCounterClockwise_firstIterationFinished = true; // makes sure that this does not run again

		// when rotating the static cube, need to transform the cubes' positions as well as their display vertices
		srm.SetRotZ( 1024 ); // set rotX for the clockwise and counterclockwise rotations

		// ROTATE MOVING CUBES
		for( int i = 0; i < numMovingCubesIndex; i++ )
		{
			// do NOT rotate faceside 1 and 3 cubes.
			if( cubeArrayMoving[i].direction != 1 && cubeArrayMoving[i].direction != 3 )
			{
				movingCubePositionsTemp[i] = srm.TransformVec( cubeArrayMoving[i].position ); // this only affects future collision
			}

			// change their direction and also the shadow's directions
			switch( cubeArrayMoving[i].direction )
			{
			case 2:
				cubeArrayMoving[i].direction = 5;
				break;
			case 4:
				cubeArrayMoving[i].direction = 6;
				break;
			case 5:
				cubeArrayMoving[i].direction = 4;
				break;
			case 6:
				cubeArrayMoving[i].direction = 2;
				break;
			}
		}

		// ROTATE THE SHADOWS
		for( int i = 0; i < numShadowsIndex; i++ )
		{
			// do NOT rotate facesides 1 and 3. messes with boundaries
			if( shadowArray[i].direction != 1 && shadowArray[i].direction != 3 )
				shadowArray[i].position = srm.TransformVec( shadowArray[i].position );

			// set all their directions
			switch( shadowArray[i].direction )
			{
			case 2:
				shadowArray[i].setDirection( 5 ); // one BECOMES 2
				break;
			case 4:
				shadowArray[i].setDirection( 6 ); // setDirection also sets the vertices used for picking
				break;
			case 5:
				shadowArray[i].setDirection( 4 );
				break;
			case 6:
				shadowArray[i].setDirection( 2 );
				break;
			}

			// set their shadowVertices to correct one
			for( int j = 0; j < 24; j++ )
			{
				switch( shadowArray[i].direction )
				{
				case 2:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide2[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide2[j];
					break;
				case 4:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide4[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide4[j];
					break;
				case 5:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide5[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide5[j];
					break;
				case 6:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide6[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide6[j];
					break;
				}
			} // end of shadow vertices correction
		} // end of looping through shadow array
			
		// UPDATE THE SHADOW GROUP BOUNDS
		UpdateShadowGroupBounds();
	} // end of if-statement for first iteration of Rotation
		
	// set delta rotation for interpolation animation
	srm.SetRotZ( deltaYMovingRotation );


	// ROTATE MOVING CUBE VERTICES
	for( int i = 0; i < numMovingCubesIndex; i++ )
	{
		if( cubeArrayMoving[i].direction != 1 && cubeArrayMoving[i].direction != 3 )
		{
			cubeArrayMoving[i].position = srm.TransformVec( cubeArrayMoving[i].position );
		}
	}

	// ROTATE SHADOW VERTICES
	for( int i = 0; i < numShadowsIndex; i++ )
	{
		for( int j = 0; j < 24; j++ )
		{
			if( shadowArray[i].direction != 1 && shadowArray[i].direction != 3 )
			{
				shadowVerticesTranslated[i*24 + j] = srm.TransformVec( shadowVerticesTranslated[i*24 + j] );
				shadowVerticesTransparentTranslated[i*24 + j] = srm.TransformVec( shadowVerticesTransparentTranslated[i*24 + j] );
				shadowNormals[i*24 + j] = srm.TransformVec( shadowNormals[i*24 + j] );
			}
		}
	}

	// keeps track of how many degrees rotated
	cumulativeDeltaYRotation += deltaYMovingRotation;

	// When rotation has stopped
	if( cumulativeDeltaYRotation == 1024 ) // stops rotation if limit of degrees-of-rotation is reached
	{
		rotateMovingVerticesCounterClockwise = false;
		rotateMovingVerticesCounterClockwise_firstIterationFinished = false;
		movingCubesAreRotating = false; // allows moving cubes to move again and shadows to be updated
		cumulativeDeltaYRotation = 0; // reset the count			
		
		for( int i = 0; i < numMovingCubesIndex; i++ )
		{
			if( cubeArrayMoving[i].direction != 1 && cubeArrayMoving[i].direction != 3 )
			{
				cubeArrayMoving[i].position = movingCubePositionsTemp[i];
			}
		}
	} // end of reset, end of final destination of rotation
} // end of RotateMovingCubesCounterClockwise()

int16 getActiveFaceSide()
{
	int16 activeFaceSide = 0;
	CIwVec3 normal1, normal2, normal3, normal4, normal5, normal6;
	CIwVec3 largestNormal;
	CIwVec3 v1, v2; // vectors for calculating normal

	// faceside1's normal
	v1 = CIwVec3( staticSide1VerticesTranslated[3] - staticSide1VerticesTranslated[0] ); // v1 = point4 - point1
	v2 = CIwVec3( staticSide1VerticesTranslated[1] - staticSide1VerticesTranslated[0] ); // v2 = point2 - point1
	v1 = tt1.TransformVec( v1 );
	v2 = tt1.TransformVec( v2 );

	normal1 = CrossProduct( v1, v2 );

	// faceside2's normal
	v1 = CIwVec3( staticSide2VerticesTranslated[3] - staticSide2VerticesTranslated[0] ); // v1 = point4 - point1
	v2 = CIwVec3( staticSide2VerticesTranslated[1] - staticSide2VerticesTranslated[0] ); // v2 = point2 - point1
	v1 = tt1.TransformVec( v1 );
	v2 = tt1.TransformVec( v2 );

	normal2 = CrossProduct( v1, v2 );

	// faceside3's normal
	v1 = CIwVec3( staticSide3VerticesTranslated[3] - staticSide3VerticesTranslated[0] ); // v1 = point4 - point1
	v2 = CIwVec3( staticSide3VerticesTranslated[1] - staticSide3VerticesTranslated[0] ); // v2 = point2 - point1
	v1 = tt1.TransformVec( v1 );
	v2 = tt1.TransformVec( v2 );

	normal3 = CrossProduct( v1, v2 );

	// faceside4's normal
	v1 = CIwVec3( staticSide4VerticesTranslated[3] - staticSide4VerticesTranslated[0] ); // v1 = point4 - point1
	v2 = CIwVec3( staticSide4VerticesTranslated[1] - staticSide4VerticesTranslated[0] ); // v2 = point2 - point1
	v1 = tt1.TransformVec( v1 );
	v2 = tt1.TransformVec( v2 );

	normal4 = CrossProduct( v1, v2 );

	// faceside5's normal
	v1 = CIwVec3( staticSide5VerticesTranslated[3] - staticSide5VerticesTranslated[0] ); // v1 = point4 - point1
	v2 = CIwVec3( staticSide5VerticesTranslated[1] - staticSide5VerticesTranslated[0] ); // v2 = point2 - point1
	v1 = tt1.TransformVec( v1 );
	v2 = tt1.TransformVec( v2 );

	normal5 = CrossProduct( v1, v2 );

	// faceside6's normal
	v1 = CIwVec3( staticSide6VerticesTranslated[3] - staticSide6VerticesTranslated[0] ); // v1 = point4 - point1
	v2 = CIwVec3( staticSide6VerticesTranslated[1] - staticSide6VerticesTranslated[0] ); // v2 = point2 - point1
	v1 = tt1.TransformVec( v1 );
	v2 = tt1.TransformVec( v2 );

	normal6 = CrossProduct( v1, v2 );

	if( normal1.z > normal2.z )
		largestNormal = normal1;
	else
		largestNormal = normal2;

	if( normal3.z > largestNormal.z )
		largestNormal = normal3;
	
	if( normal4.z > largestNormal.z )
		largestNormal = normal4;

	if( normal5.z > largestNormal.z )
		largestNormal = normal5;

	if( normal6.z > largestNormal.z )
		largestNormal = normal6;

	if( largestNormal.z == normal1.z )
		activeFaceSide = 1;
	if( largestNormal.z == normal2.z )
		activeFaceSide = 2;
	if( largestNormal.z == normal3.z )
		activeFaceSide = 3;
	if( largestNormal.z == normal4.z )
		activeFaceSide = 4;
	if( largestNormal.z == normal5.z )
		activeFaceSide = 5;
	if( largestNormal.z == normal6.z )
		activeFaceSide = 6;
	
	return activeFaceSide;
}

// Generate adjacent side
int16 getAdjacentDirection( int16 dir )
{
	int16 adjacentDirection;
	IwRandSeed( (int32)s3eTimerGetMs() );


	if( dir == 1 )
	{
		do
		{
			adjacentDirection = IwRandMinMax( 1, 6+1 );
		}
		while( adjacentDirection == 3  || adjacentDirection == 1); // continue if adjDir does not equal 1 or 3
	}
	else if( dir == 2 )
	{
		do
		{
			adjacentDirection = IwRandMinMax( 1, 6+1 );
		}
		while( adjacentDirection == 4 || adjacentDirection == 2 );
	}
	else if( dir == 3 )
	{
		do
		{
			adjacentDirection = IwRandMinMax( 1, 6+1 );
		}
		while( adjacentDirection == 1 || adjacentDirection == 3 );
	}
	else if( dir == 4 )
	{
		do
		{
			adjacentDirection = IwRandMinMax( 1, 6+1 );
		}
		while( adjacentDirection == 2 || adjacentDirection == 4 );
	}
	else if( dir == 5 )
	{
		do
		{
			adjacentDirection = IwRandMinMax( 1, 6+1 );
		}
		while( adjacentDirection == 6 || adjacentDirection == 5 );
	}
	else if( dir == 6 )
	{
		do
		{
			adjacentDirection = IwRandMinMax( 1, 6+1 );
		}
		while( adjacentDirection == 5 || adjacentDirection == 6 );
	}

	return adjacentDirection;
}

// helper method for getActiveFaceSide()
CIwVec3 CrossProduct( CIwVec3 a, CIwVec3 b )
{
	CIwVec3 c;
	c.x = a.y * b.z - a.z * b.y;
	c.y = a.z * b.x - a.x * b.z;
	c.z = a.x * b.y - a.y * b.x;

	return c;
}

void RotateStaticCubesRight()
{
	staticCubesAreRotating = true;

	// the initial rotation rotates several things instantly to final rotation before interpolation
	// must happen just once
	if( rotateStaticVerticesRight_firstIterationFinished == false )
	{
		// copy side vertices into interpolation arrays
		// Actually, use interpolation arrays as temp array to store copy of exact rotation
		rotateStaticVerticesRight_firstIterationFinished = true; // makes sure that this does not run again

		// when rotating the static cube, need to transform the cubes' positions as well as their display vertices
		srm.SetRotY( 1024 );

		side1TempMaterial->Copy( *side1Material ); // copy material b/c it's a pointer
		side2TempMaterial->Copy( *side2Material );
		side3TempMaterial->Copy( *side3Material );
		side4TempMaterial->Copy( *side4Material );
		side5TempMaterial->Copy( *side5Material );
		side6TempMaterial->Copy( *side6Material );

		

		// ROTATE STATIC CUBES
		for( int i = numOriginalCubes; i < numStaticCubes; i++ )
		{
			cubePositionsTemp[i] = srm.TransformVec( cubeArray[i].position ); // this only affects future collision
			
			switch( cubeArray[i].direction )
			{
			case 1:
				// 1 = 2
				cubeArray[i].direction = 2;
				break;
			case 2:
				// 2 = 3
				cubeArray[i].direction = 3;
				break;
			case 3:
				// 3 = 4
				cubeArray[i].direction = 4;
				break;
			case 4:
				// 4 = 1
				cubeArray[i].direction = 1;
				break;
			case 5:
				// 5 = 5
				cubeArray[i].direction = 5;
				break;
			case 6:
				// 6 = 6
				cubeArray[i].direction = 6;
				break;
			}
		}

		for( int i = 0; i < numStaticSides1Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide1VerticesTranslatedInterp[i*4 + j] = staticSide1VerticesTranslated[i*4+j]; // copy
				//staticSide1VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide1VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide1NormalsInterp[i*4+j] = staticSide1Normals[i*4+j]; // copy
				//staticSide1NormalsInterp[i*4+j] = srm.TransformVec( staticSide1NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides2Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide2VerticesTranslatedInterp[i*4 + j] = staticSide2VerticesTranslated[i*4+j]; // copy
				//staticSide2VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide2VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide2NormalsInterp[i*4+j] = staticSide2Normals[i*4+j]; // copy
				//staticSide2NormalsInterp[i*4+j] = srm.TransformVec( staticSide2NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides3Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide3VerticesTranslatedInterp[i*4 + j] = staticSide3VerticesTranslated[i*4+j]; // copy
				//staticSide3VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide3VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide3NormalsInterp[i*4+j] = staticSide3Normals[i*4+j]; // copy
				//staticSide3NormalsInterp[i*4+j] = srm.TransformVec( staticSide3NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides4Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide4VerticesTranslatedInterp[i*4 + j] = staticSide4VerticesTranslated[i*4+j]; // copy
				//staticSide4VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide4VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide4NormalsInterp[i*4+j] = staticSide4Normals[i*4+j]; // copy
				//staticSide4NormalsInterp[i*4+j] = srm.TransformVec( staticSide4NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides5Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide5VerticesTranslatedInterp[i*4 + j] = staticSide5VerticesTranslated[i*4+j]; // copy
				//staticSide5VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide5VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide5NormalsInterp[i*4+j] = staticSide5Normals[i*4+j]; // copy
				//staticSide5NormalsInterp[i*4+j] = srm.TransformVec( staticSide5NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides6Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide6VerticesTranslatedInterp[i*4 + j] = staticSide6VerticesTranslated[i*4+j]; // copy
				//staticSide6VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide6VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide6NormalsInterp[i*4+j] = staticSide6Normals[i*4+j]; // copy
				//staticSide6NormalsInterp[i*4+j] = srm.TransformVec( staticSide6NormalsInterp[i*4+j] ); // rotate
			}
		}			
	}
		
	// set delta rotation for interpolation animation
	srm.SetRotY( deltaYStaticRotation );

	// ROTATE STATIC CUBES
	for( int i = numOriginalCubes; i < numStaticCubes; i++ )
	{
		cubeArray[i].position = srm.TransformVec( cubeArray[i].position );
	}

	// ROTATE STATIC SIDES VERTICES - side 1
	for( int i = 0; i < numStaticSides1Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide1VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide1VerticesTranslated[i*4 + j] );
			staticSide1Normals[i*4 + j] = srm.TransformVec( staticSide1Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 2
	for( int i = 0; i < numStaticSides2Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide2VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide2VerticesTranslated[i*4 + j] );
			staticSide2Normals[i*4 + j] = srm.TransformVec( staticSide2Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 3
	for( int i = 0; i < numStaticSides3Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide3VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide3VerticesTranslated[i*4 + j] );
			staticSide3Normals[i*4 + j] = srm.TransformVec( staticSide3Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 4
	for( int i = 0; i < numStaticSides4Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide4VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide4VerticesTranslated[i*4 + j] );
			staticSide4Normals[i*4 + j] = srm.TransformVec( staticSide4Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 5
	for( int i = 0; i < numStaticSides5Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide5VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide5VerticesTranslated[i*4 + j] );
			staticSide5Normals[i*4 + j] = srm.TransformVec( staticSide5Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 6
	for( int i = 0; i < numStaticSides6Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide6VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide6VerticesTranslated[i*4 + j] );
			staticSide6Normals[i*4 + j] = srm.TransformVec( staticSide6Normals[i*4 + j] );
		}
	}

	// ROTATE STATIC CUBE VERTICES 
	for( int i = numOriginalCubes; i < numStaticCubes; i++ ) // only rotate moving-to-static cubes
	{
		for( int j = 0; j < 24; j++ )
		{
			cubeTranslated2[i*24 + j] = srm.TransformVec( cubeTranslated2[i*24 + j] );
			cubeNormals2[i*24 + j] = srm.TransformVec( cubeNormals2[i*24 + j] );
		}
	}

	// keeps track of how many degrees rotated
	cumulativeDeltaYRotation += deltaYStaticRotation;

	// When rotation has stopped
	if( cumulativeDeltaYRotation == 1024 ) // stops rotation if limit of degrees-of-rotation is reached
	{
		rotateStaticVerticesRight = false;
		rotateStaticVerticesRight_firstIterationFinished = false;
		staticCubesAreRotating = false;
		cumulativeDeltaYRotation = 0; // reset the count		

		// reset final position
		for( int i = numOriginalCubes; i < numStaticCubes; i++ )
		{
			cubeArray[i].position = cubePositionsTemp[i];
		}

		PlaneSide planeTemp[6];
		// initialize temporary planes
		for( int i = 0; i < 6; i++ )
		{
			planeTemp[i] = PlaneSide();
			planeTemp[i] = plane[i];
		}

		// reassign planes
		for( int i = 0; i < 6; i++ )
		{
			if( plane[i].direction == 1 ) // 1 = 4
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 4 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break;
					}
				}
			}
			else if( plane[i].direction == 2 ) // 2 = 1
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 1 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break;
					}
				}
			}
			else if( plane[i].direction == 3 ) // 3 = 2
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 2 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break;
					}
				}
			}
			else if( plane[i].direction == 4 ) // 4 = 3
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 3 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break;
					}
				}
			}
			else if( plane[i].direction == 5 ) // 5 = 5
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 5 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break;
					}
				}
			}
			else if( plane[i].direction == 6 ) // 6 = 6
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 6 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break;
					}
				}
			}
		}

		// resets the final rotation position b/c of slight rotation error with integer division
		// the Normals for the sides are rotated and kept because they are not refreshed based on original cube positions
		// If implemented that way, it would be very expensive to refresh through every static cube
		// side 1 = side 4
		for( int i = 0; i < numStaticSides1Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide1VerticesTranslated[i*4+j] = staticSide1VerticesTranslatedInterp[i*4 + j];
				staticSide1Normals[i*4+j] = staticSide1NormalsInterp[i*4+j];
			}
		}
		side1Material->Copy( *side4TempMaterial );

		// side 2 = side 1
		for( int i = 0; i < numStaticSides2Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide2VerticesTranslated[i*4+j] = staticSide2VerticesTranslatedInterp[i*4 + j];
				staticSide2Normals[i*4+j] = staticSide2NormalsInterp[i*4+j];
			}
		}
		side2Material->Copy( *side1TempMaterial );

		// side 3 = side 2
		for( int i = 0; i < numStaticSides3Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide3VerticesTranslated[i*4+j] = staticSide3VerticesTranslatedInterp[i*4 + j];
				staticSide3Normals[i*4+j] = staticSide3NormalsInterp[i*4+j];
			}
		}
		side3Material->Copy( *side2TempMaterial );

		// side 4 = side 3
		for( int i = 0; i < numStaticSides4Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide4VerticesTranslated[i*4+j] = staticSide4VerticesTranslatedInterp[i*4 + j];
				staticSide4Normals[i*4+j] = staticSide4NormalsInterp[i*4+j];
			}
		}
		side4Material->Copy( *side3TempMaterial );

		// side 5 = side 5
		for( int i = 0; i < numStaticSides5Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide5VerticesTranslated[i*4+j] = staticSide5VerticesTranslatedInterp[i*4 + j];
				staticSide5Normals[i*4+j] = staticSide5NormalsInterp[i*4+j];
			}
		}
		// side 6 = side 6
		for( int i = 0; i < numStaticSides6Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide6VerticesTranslated[i*4+j] = staticSide6VerticesTranslatedInterp[i*4 + j];
				staticSide6Normals[i*4+j] = staticSide6NormalsInterp[i*4+j];
			}
		}

	} // end of reset, end of final destination of rotation
} // end of RotateStaticCubesRight()

void RotateStaticCubesLeft()
{
	staticCubesAreRotating = true;

	// the initial rotation rotates several things instantly to final rotation before interpolation
	// must happen just once
	if( rotateStaticVerticesLeft_firstIterationFinished == false )
	{
		// copy side vertices into interpolation arrays
		// Actually, use interpolation arrays as temp array to store copy of exact rotation
		rotateStaticVerticesLeft_firstIterationFinished = true; // makes sure that this does not run again

		// when rotating the static cube, need to transform the cubes' positions as well as their display vertices
		srm.SetRotY( -1024 );

		side1TempMaterial->Copy( *side1Material ); // copy material b/c it's a pointer
		side2TempMaterial->Copy( *side2Material );
		side3TempMaterial->Copy( *side3Material );
		side4TempMaterial->Copy( *side4Material );
		side5TempMaterial->Copy( *side5Material );
		side6TempMaterial->Copy( *side6Material );

		

		// ROTATE STATIC CUBES
		for( int i = 0; i < numStaticCubes; i++ )
		{
			cubePositionsTemp[i] = srm.TransformVec( cubeArray[i].position ); // this only affects future collision

			switch( cubeArray[i].direction )
			{
			case 1:
				// 1 = 4
				cubeArray[i].direction = 4;
				break;
			case 2:
				// 2 = 1
				cubeArray[i].direction = 1;
				break;
			case 3:
				// 3 = 2
				cubeArray[i].direction = 2;
				break;
			case 4:
				// 4 = 3
				cubeArray[i].direction = 3;
				break;
			case 5:
				// 5 = 5
				cubeArray[i].direction = 5;
				break;
			case 6:
				// 6 = 6
				cubeArray[i].direction = 6;
				break;
			}
		}

		for( int i = 0; i < numStaticSides1Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide1VerticesTranslatedInterp[i*4 + j] = staticSide1VerticesTranslated[i*4+j]; // copy
				//staticSide1VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide1VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide1NormalsInterp[i*4+j] = staticSide1Normals[i*4+j]; // copy
				//staticSide1NormalsInterp[i*4+j] = srm.TransformVec( staticSide1NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides2Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide2VerticesTranslatedInterp[i*4 + j] = staticSide2VerticesTranslated[i*4+j]; // copy
				//staticSide2VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide2VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide2NormalsInterp[i*4+j] = staticSide2Normals[i*4+j]; // copy
				//staticSide2NormalsInterp[i*4+j] = srm.TransformVec( staticSide2NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides3Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide3VerticesTranslatedInterp[i*4 + j] = staticSide3VerticesTranslated[i*4+j]; // copy
				//staticSide3VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide3VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide3NormalsInterp[i*4+j] = staticSide3Normals[i*4+j]; // copy
				//staticSide3NormalsInterp[i*4+j] = srm.TransformVec( staticSide3NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides4Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide4VerticesTranslatedInterp[i*4 + j] = staticSide4VerticesTranslated[i*4+j]; // copy
				//staticSide4VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide4VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide4NormalsInterp[i*4+j] = staticSide4Normals[i*4+j]; // copy
				//staticSide4NormalsInterp[i*4+j] = srm.TransformVec( staticSide4NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides5Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide5VerticesTranslatedInterp[i*4 + j] = staticSide5VerticesTranslated[i*4+j]; // copy
				//staticSide5VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide5VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide5NormalsInterp[i*4+j] = staticSide5Normals[i*4+j]; // copy
				//staticSide5NormalsInterp[i*4+j] = srm.TransformVec( staticSide5NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides6Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide6VerticesTranslatedInterp[i*4 + j] = staticSide6VerticesTranslated[i*4+j]; // copy
				//staticSide6VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide6VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide6NormalsInterp[i*4+j] = staticSide6Normals[i*4+j]; // copy
				//staticSide6NormalsInterp[i*4+j] = srm.TransformVec( staticSide6NormalsInterp[i*4+j] ); // rotate
			}
		}			
	}
		
	// set delta rotation for interpolation animation
	srm.SetRotY( -1*deltaYStaticRotation );

	// ROTATE STATIC CUBES
	for( int i = numOriginalCubes; i < numStaticCubes; i++ )
	{
		cubeArray[i].position = srm.TransformVec( cubeArray[i].position );
	}

	// ROTATE STATIC SIDES VERTICES - side 1
	for( int i = 0; i < numStaticSides1Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide1VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide1VerticesTranslated[i*4 + j] );
			staticSide1Normals[i*4 + j] = srm.TransformVec( staticSide1Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 2
	for( int i = 0; i < numStaticSides2Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide2VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide2VerticesTranslated[i*4 + j] );
			staticSide2Normals[i*4 + j] = srm.TransformVec( staticSide2Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 3
	for( int i = 0; i < numStaticSides3Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide3VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide3VerticesTranslated[i*4 + j] );
			staticSide3Normals[i*4 + j] = srm.TransformVec( staticSide3Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 4
	for( int i = 0; i < numStaticSides4Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide4VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide4VerticesTranslated[i*4 + j] );
			staticSide4Normals[i*4 + j] = srm.TransformVec( staticSide4Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 5
	for( int i = 0; i < numStaticSides5Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide5VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide5VerticesTranslated[i*4 + j] );
			staticSide5Normals[i*4 + j] = srm.TransformVec( staticSide5Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 6
	for( int i = 0; i < numStaticSides6Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide6VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide6VerticesTranslated[i*4 + j] );
			staticSide6Normals[i*4 + j] = srm.TransformVec( staticSide6Normals[i*4 + j] );
		}
	}

	// ROTATE STATIC CUBE VERTICES
	for( int i = numOriginalCubes; i < numStaticCubes; i++ ) // only rotate moving-to-static cubes
	{
		for( int j = 0; j < 24; j++ )
		{
			cubeTranslated2[i*24 + j] = srm.TransformVec( cubeTranslated2[i*24 + j] );
			cubeNormals2[i*24 + j] = srm.TransformVec( cubeNormals2[i*24 + j] );
		}
	}

	// keeps track of how many degrees rotated
	cumulativeDeltaYRotation += deltaYStaticRotation;

	// When rotation has stopped
	if( cumulativeDeltaYRotation == 1024 ) // stops rotation if limit of degrees-of-rotation is reached
	{
		rotateStaticVerticesLeft = false;
		rotateStaticVerticesLeft_firstIterationFinished = false;
		staticCubesAreRotating = false;
		cumulativeDeltaYRotation = 0; // reset the count		

		// reset final position
		for( int i = numOriginalCubes; i < numStaticCubes; i++ )
		{
			cubeArray[i].position = cubePositionsTemp[i];
		}

		PlaneSide planeTemp[6];
		// initialize temporary planes
		for( int i = 0; i < 6; i++ )
		{
			planeTemp[i] = PlaneSide();
			planeTemp[i] = plane[i];
		}

		// reassign planes
		for( int i = 0; i < 6; i++ )
		{
			if( plane[i].direction == 1 ) // 1 = 2
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 2 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes						
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 2 ) // 2 = 3
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 3 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 3 ) // 3 = 4
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 4 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 4 ) // 4 = 1
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 1 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 5 ) // 5 = 5
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 5 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 6 ) // 6 = 6
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 6 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
		}

		// resets the final rotation position b/c of slight rotation error with integer division
		// the Normals for the sides are rotated and kept because they are not refreshed based on original cube positions
		// If implemented that way, it would be very expensive to refresh through every static cube
		// side 1 = side 2
		for( int i = 0; i < numStaticSides1Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide1VerticesTranslated[i*4+j] = staticSide1VerticesTranslatedInterp[i*4 + j];
				staticSide1Normals[i*4+j] = staticSide1NormalsInterp[i*4+j];
			}
		}
		side1Material->Copy( *side2TempMaterial );

		// side 2 = side 3
		for( int i = 0; i < numStaticSides2Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide2VerticesTranslated[i*4+j] = staticSide2VerticesTranslatedInterp[i*4 + j];
				staticSide2Normals[i*4+j] = staticSide2NormalsInterp[i*4+j];
			}
		}
		side2Material->Copy( *side3TempMaterial );

		// side 3 = side 4
		for( int i = 0; i < numStaticSides3Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide3VerticesTranslated[i*4+j] = staticSide3VerticesTranslatedInterp[i*4 + j];
				staticSide3Normals[i*4+j] = staticSide3NormalsInterp[i*4+j];
			}
		}
		side3Material->Copy( *side4TempMaterial );

		// side 4 = side 1
		for( int i = 0; i < numStaticSides4Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide4VerticesTranslated[i*4+j] = staticSide4VerticesTranslatedInterp[i*4 + j];
				staticSide4Normals[i*4+j] = staticSide4NormalsInterp[i*4+j];
			}
		}
		side4Material->Copy( *side1TempMaterial );

		// side 5 = side 5
		for( int i = 0; i < numStaticSides5Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide5VerticesTranslated[i*4+j] = staticSide5VerticesTranslatedInterp[i*4 + j];
				staticSide5Normals[i*4+j] = staticSide5NormalsInterp[i*4+j];
			}
		}
		// side 6 = side 6
		for( int i = 0; i < numStaticSides6Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide6VerticesTranslated[i*4+j] = staticSide6VerticesTranslatedInterp[i*4 + j];
				staticSide6Normals[i*4+j] = staticSide6NormalsInterp[i*4+j];
			}
		}
	} // end of reset, end of final destination of rotation
} // end of RotateStaticCubesLeft()

void RotateStaticCubesUp()
{
	staticCubesAreRotating = true;

	// the initial rotation rotates several things instantly to final rotation before interpolation
	// must happen just once
	if( rotateStaticVerticesUp_firstIterationFinished == false )
	{
		// copy side vertices into interpolation arrays
		// Actually, use interpolation arrays as temp array to store copy of exact rotation
		rotateStaticVerticesUp_firstIterationFinished = true; // makes sure that this does not run again

		// when rotating the static cube, need to transform the cubes' positions as well as their display vertices
		srm.SetRotX( 1024 );

		side1TempMaterial->Copy( *side1Material ); // copy material b/c it's a pointer
		side2TempMaterial->Copy( *side2Material );
		side3TempMaterial->Copy( *side3Material );
		side4TempMaterial->Copy( *side4Material );
		side5TempMaterial->Copy( *side5Material );
		side6TempMaterial->Copy( *side6Material );

		// ROTATE STATIC CUBES
		for( int i = 0; i < numStaticCubes; i++ )
		{
			cubePositionsTemp[i] = srm.TransformVec( cubeArray[i].position ); // this only affects future collision

			switch( cubeArray[i].direction )
			{
			case 1:
				// 1 = 5
				cubeArray[i].direction = 5;
				break;
			case 2:
				// 2 = 2
				cubeArray[i].direction = 2;
				break;
			case 3:
				// 3 = 6
				cubeArray[i].direction = 6;
				break;
			case 4:
				// 4 = 4
				cubeArray[i].direction = 4;
				break;
			case 5:
				// 5 = 3
				cubeArray[i].direction = 3;
				break;
			case 6:
				// 6 = 1
				cubeArray[i].direction = 1;
				break;
			}
		}

		for( int i = 0; i < numStaticSides1Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide1VerticesTranslatedInterp[i*4 + j] = staticSide1VerticesTranslated[i*4+j]; // copy
				//staticSide1VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide1VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide1NormalsInterp[i*4+j] = staticSide1Normals[i*4+j]; // copy
				//staticSide1NormalsInterp[i*4+j] = srm.TransformVec( staticSide1NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides2Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide2VerticesTranslatedInterp[i*4 + j] = staticSide2VerticesTranslated[i*4+j]; // copy
				//staticSide2VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide2VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide2NormalsInterp[i*4+j] = staticSide2Normals[i*4+j]; // copy
				//staticSide2NormalsInterp[i*4+j] = srm.TransformVec( staticSide2NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides3Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide3VerticesTranslatedInterp[i*4 + j] = staticSide3VerticesTranslated[i*4+j]; // copy
				//staticSide3VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide3VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide3NormalsInterp[i*4+j] = staticSide3Normals[i*4+j]; // copy
				//staticSide3NormalsInterp[i*4+j] = srm.TransformVec( staticSide3NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides4Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide4VerticesTranslatedInterp[i*4 + j] = staticSide4VerticesTranslated[i*4+j]; // copy
				//staticSide4VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide4VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide4NormalsInterp[i*4+j] = staticSide4Normals[i*4+j]; // copy
				//staticSide4NormalsInterp[i*4+j] = srm.TransformVec( staticSide4NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides5Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide5VerticesTranslatedInterp[i*4 + j] = staticSide5VerticesTranslated[i*4+j]; // copy
				//staticSide5VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide5VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide5NormalsInterp[i*4+j] = staticSide5Normals[i*4+j]; // copy
				//staticSide5NormalsInterp[i*4+j] = srm.TransformVec( staticSide5NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides6Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide6VerticesTranslatedInterp[i*4 + j] = staticSide6VerticesTranslated[i*4+j]; // copy
				//staticSide6VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide6VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide6NormalsInterp[i*4+j] = staticSide6Normals[i*4+j]; // copy
				//staticSide6NormalsInterp[i*4+j] = srm.TransformVec( staticSide6NormalsInterp[i*4+j] ); // rotate
			}
		}			
	}
		
	// set delta rotation for interpolation animation
	srm.SetRotX( deltaYStaticRotation );

	// ROTATE STATIC CUBES
	for( int i = numOriginalCubes; i < numStaticCubes; i++ )
	{
		cubeArray[i].position = srm.TransformVec( cubeArray[i].position );
	}

	// ROTATE STATIC SIDES VERTICES - side 1
	for( int i = 0; i < numStaticSides1Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide1VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide1VerticesTranslated[i*4 + j] );
			staticSide1Normals[i*4 + j] = srm.TransformVec( staticSide1Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 2
	for( int i = 0; i < numStaticSides2Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide2VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide2VerticesTranslated[i*4 + j] );
			staticSide2Normals[i*4 + j] = srm.TransformVec( staticSide2Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 3
	for( int i = 0; i < numStaticSides3Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide3VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide3VerticesTranslated[i*4 + j] );
			staticSide3Normals[i*4 + j] = srm.TransformVec( staticSide3Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 4
	for( int i = 0; i < numStaticSides4Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide4VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide4VerticesTranslated[i*4 + j] );
			staticSide4Normals[i*4 + j] = srm.TransformVec( staticSide4Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 5
	for( int i = 0; i < numStaticSides5Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide5VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide5VerticesTranslated[i*4 + j] );
			staticSide5Normals[i*4 + j] = srm.TransformVec( staticSide5Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 6
	for( int i = 0; i < numStaticSides6Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide6VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide6VerticesTranslated[i*4 + j] );
			staticSide6Normals[i*4 + j] = srm.TransformVec( staticSide6Normals[i*4 + j] );
		}
	}

	// ROTATE STATIC CUBE VERTICES
	for( int i = numOriginalCubes; i < numStaticCubes; i++ ) // only rotate moving-to-static cubes
	{
		for( int j = 0; j < 24; j++ )
		{
			cubeTranslated2[i*24 + j] = srm.TransformVec( cubeTranslated2[i*24 + j] );
			cubeNormals2[i*24 + j] = srm.TransformVec( cubeNormals2[i*24 + j] );
		}
	}

	// keeps track of how many degrees rotated
	cumulativeDeltaYRotation += deltaYStaticRotation;

	// When rotation has stopped
	if( cumulativeDeltaYRotation == 1024 ) // stops rotation if limit of degrees-of-rotation is reached
	{
		rotateStaticVerticesUp = false;
		rotateStaticVerticesUp_firstIterationFinished = false;
		staticCubesAreRotating = false;
		cumulativeDeltaYRotation = 0; // reset the count	

		// reset final position
		for( int i = numOriginalCubes; i < numStaticCubes; i++ )
		{
			cubeArray[i].position = cubePositionsTemp[i];
		}

		PlaneSide planeTemp[6];
		// initialize temporary planes
		for( int i = 0; i < 6; i++ )
		{
			planeTemp[i] = PlaneSide();
			planeTemp[i] = plane[i];
		}

		// reassign planes
		for( int i = 0; i < 6; i++ )
		{
			if( plane[i].direction == 1 ) // 1 = 6
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 6 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes						
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 2 ) // 2 = 2
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 2 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 3 ) // 3 = 5
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 5 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 4 ) // 4 = 4
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 4 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 5 ) // 5 = 1
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 1 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 6 ) // 6 = 3
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 3 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
		}

		// resets the final rotation position b/c of slight rotation error with integer division
		// the Normals for the sides are rotated and kept because they are not refreshed based on original cube positions
		// If implemented that way, it would be very expensive to refresh through every static cube
		// side 1 = side 6
		for( int i = 0; i < numStaticSides1Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide1VerticesTranslated[i*4+j] = staticSide1VerticesTranslatedInterp[i*4 + j];
				staticSide1Normals[i*4+j] = staticSide1NormalsInterp[i*4+j];
			}
		}
		side1Material->Copy( *side6TempMaterial );

		// side 2 = side 2
		for( int i = 0; i < numStaticSides2Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide2VerticesTranslated[i*4+j] = staticSide2VerticesTranslatedInterp[i*4 + j];
				staticSide2Normals[i*4+j] = staticSide2NormalsInterp[i*4+j];
			}
		}
		side2Material->Copy( *side2TempMaterial );

		// side 3 = side 5
		for( int i = 0; i < numStaticSides3Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide3VerticesTranslated[i*4+j] = staticSide3VerticesTranslatedInterp[i*4 + j];
				staticSide3Normals[i*4+j] = staticSide3NormalsInterp[i*4+j];
			}
		}
		side3Material->Copy( *side5TempMaterial );

		// side 4 = side 4
		for( int i = 0; i < numStaticSides4Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide4VerticesTranslated[i*4+j] = staticSide4VerticesTranslatedInterp[i*4 + j];
				staticSide4Normals[i*4+j] = staticSide4NormalsInterp[i*4+j];
			}
		}
		side4Material->Copy( *side4TempMaterial );

		// side 5 = side 1
		for( int i = 0; i < numStaticSides5Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide5VerticesTranslated[i*4+j] = staticSide5VerticesTranslatedInterp[i*4 + j];
				staticSide5Normals[i*4+j] = staticSide5NormalsInterp[i*4+j];
			}
		}
		side5Material->Copy( *side1TempMaterial );

		// side 6 = side 3
		for( int i = 0; i < numStaticSides6Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide6VerticesTranslated[i*4+j] = staticSide6VerticesTranslatedInterp[i*4 + j];
				staticSide6Normals[i*4+j] = staticSide6NormalsInterp[i*4+j];
			}
		}
		side6Material->Copy( *side3TempMaterial );

	} // end of reset, end of final destination of rotation
} // end of RotateStaticCubesUp()

void RotateStaticCubesDown()
{
	staticCubesAreRotating = true;

	// the initial rotation rotates several things instantly to final rotation before interpolation
	// must happen just once
	if( rotateStaticVerticesDown_firstIterationFinished == false )
	{
		// copy side vertices into interpolation arrays
		// Actually, use interpolation arrays as temp array to store copy of exact rotation
		rotateStaticVerticesDown_firstIterationFinished = true; // makes sure that this does not run again

		// when rotating the static cube, need to transform the cubes' positions as well as their display vertices
		srm.SetRotX( -1024 );

		side1TempMaterial->Copy( *side1Material ); // copy material b/c it's a pointer
		side2TempMaterial->Copy( *side2Material );
		side3TempMaterial->Copy( *side3Material );
		side4TempMaterial->Copy( *side4Material );
		side5TempMaterial->Copy( *side5Material );
		side6TempMaterial->Copy( *side6Material );

		// ROTATE STATIC CUBES
		for( int i = 0; i < numStaticCubes; i++ )
		{
			cubePositionsTemp[i] = srm.TransformVec( cubeArray[i].position ); // this only affects future collision

			switch( cubeArray[i].direction )
			{
			case 1:
				// 1 = 6
				cubeArray[i].direction = 6;
				break;
			case 2:
				// 2 = 2
				cubeArray[i].direction = 2;
				break;
			case 3:
				// 3 = 5
				cubeArray[i].direction = 5;
				break;
			case 4:
				// 4 = 4
				cubeArray[i].direction = 4;
				break;
			case 5:
				// 5 = 1
				cubeArray[i].direction = 1;
				break;
			case 6:
				// 6 = 3
				cubeArray[i].direction = 3;
				break;
			}
		}

		for( int i = 0; i < numStaticSides1Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide1VerticesTranslatedInterp[i*4 + j] = staticSide1VerticesTranslated[i*4+j]; // copy
				//staticSide1VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide1VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide1NormalsInterp[i*4+j] = staticSide1Normals[i*4+j]; // copy
				//staticSide1NormalsInterp[i*4+j] = srm.TransformVec( staticSide1NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides2Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide2VerticesTranslatedInterp[i*4 + j] = staticSide2VerticesTranslated[i*4+j]; // copy
				//staticSide2VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide2VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide2NormalsInterp[i*4+j] = staticSide2Normals[i*4+j]; // copy
				//staticSide2NormalsInterp[i*4+j] = srm.TransformVec( staticSide2NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides3Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide3VerticesTranslatedInterp[i*4 + j] = staticSide3VerticesTranslated[i*4+j]; // copy
				//staticSide3VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide3VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide3NormalsInterp[i*4+j] = staticSide3Normals[i*4+j]; // copy
				//staticSide3NormalsInterp[i*4+j] = srm.TransformVec( staticSide3NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides4Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide4VerticesTranslatedInterp[i*4 + j] = staticSide4VerticesTranslated[i*4+j]; // copy
				//staticSide4VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide4VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide4NormalsInterp[i*4+j] = staticSide4Normals[i*4+j]; // copy
				//staticSide4NormalsInterp[i*4+j] = srm.TransformVec( staticSide4NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides5Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide5VerticesTranslatedInterp[i*4 + j] = staticSide5VerticesTranslated[i*4+j]; // copy
				//staticSide5VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide5VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide5NormalsInterp[i*4+j] = staticSide5Normals[i*4+j]; // copy
				//staticSide5NormalsInterp[i*4+j] = srm.TransformVec( staticSide5NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides6Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide6VerticesTranslatedInterp[i*4 + j] = staticSide6VerticesTranslated[i*4+j]; // copy
				//staticSide6VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide6VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide6NormalsInterp[i*4+j] = staticSide6Normals[i*4+j]; // copy
				//staticSide6NormalsInterp[i*4+j] = srm.TransformVec( staticSide6NormalsInterp[i*4+j] ); // rotate
			}
		}			
	}
		
	// set delta rotation for interpolation animation
	srm.SetRotX( -1*deltaYStaticRotation );

	// ROTATE STATIC CUBES
	for( int i = numOriginalCubes; i < numStaticCubes; i++ )
	{
		cubeArray[i].position = srm.TransformVec( cubeArray[i].position );
	}

	// ROTATE STATIC SIDES VERTICES - side 1
	for( int i = 0; i < numStaticSides1Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide1VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide1VerticesTranslated[i*4 + j] );
			staticSide1Normals[i*4 + j] = srm.TransformVec( staticSide1Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 2
	for( int i = 0; i < numStaticSides2Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide2VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide2VerticesTranslated[i*4 + j] );
			staticSide2Normals[i*4 + j] = srm.TransformVec( staticSide2Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 3
	for( int i = 0; i < numStaticSides3Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide3VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide3VerticesTranslated[i*4 + j] );
			staticSide3Normals[i*4 + j] = srm.TransformVec( staticSide3Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 4
	for( int i = 0; i < numStaticSides4Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide4VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide4VerticesTranslated[i*4 + j] );
			staticSide4Normals[i*4 + j] = srm.TransformVec( staticSide4Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 5
	for( int i = 0; i < numStaticSides5Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide5VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide5VerticesTranslated[i*4 + j] );
			staticSide5Normals[i*4 + j] = srm.TransformVec( staticSide5Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 6
	for( int i = 0; i < numStaticSides6Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide6VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide6VerticesTranslated[i*4 + j] );
			staticSide6Normals[i*4 + j] = srm.TransformVec( staticSide6Normals[i*4 + j] );
		}
	}

	// ROTATE STATIC CUBE VERTICES
	for( int i = numOriginalCubes; i < numStaticCubes; i++ ) // only rotate moving-to-static cubes
	{
		for( int j = 0; j < 24; j++ )
		{
			cubeTranslated2[i*24 + j] = srm.TransformVec( cubeTranslated2[i*24 + j] );
			cubeNormals2[i*24 + j] = srm.TransformVec( cubeNormals2[i*24 + j] );
		}
	}

	// keeps track of how many degrees rotated
	cumulativeDeltaYRotation += deltaYStaticRotation;

	// When rotation has stopped
	if( cumulativeDeltaYRotation == 1024 ) // stops rotation if limit of degrees-of-rotation is reached
	{
		rotateStaticVerticesDown = false;
		rotateStaticVerticesDown_firstIterationFinished = false;
		staticCubesAreRotating = false;
		cumulativeDeltaYRotation = 0; // reset the count		

		// reset final position
		for( int i = numOriginalCubes; i < numStaticCubes; i++ )
		{
			cubeArray[i].position = cubePositionsTemp[i];
		}

		PlaneSide planeTemp[6];
		// initialize temporary planes
		for( int i = 0; i < 6; i++ )
		{
			planeTemp[i] = PlaneSide();
			planeTemp[i] = plane[i];
		}

		// reassign planes
		for( int i = 0; i < 6; i++ )
		{
			if( plane[i].direction == 1 ) // 1 = 5
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 5 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes						
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 2 ) // 2 = 2
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 2 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 3 ) // 3 = 6
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 6 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 4 ) // 4 = 4
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 4 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 5 ) // 5 = 3
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 3 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 6 ) // 6 = 1
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 1 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
		}

		// resets the final rotation position b/c of slight rotation error with integer division
		// the Normals for the sides are rotated and kept because they are not refreshed based on original cube positions
		// If implemented that way, it would be very expensive to refresh through every static cube
		// side 1 = side 5
		for( int i = 0; i < numStaticSides1Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide1VerticesTranslated[i*4+j] = staticSide1VerticesTranslatedInterp[i*4 + j];
				staticSide1Normals[i*4+j] = staticSide1NormalsInterp[i*4+j];
			}
		}
		side1Material->Copy( *side5TempMaterial );

		// side 2 = side 2
		for( int i = 0; i < numStaticSides2Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide2VerticesTranslated[i*4+j] = staticSide2VerticesTranslatedInterp[i*4 + j];
				staticSide2Normals[i*4+j] = staticSide2NormalsInterp[i*4+j];
			}
		}
		side2Material->Copy( *side2TempMaterial );

		// side 3 = side 6
		for( int i = 0; i < numStaticSides3Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide3VerticesTranslated[i*4+j] = staticSide3VerticesTranslatedInterp[i*4 + j];
				staticSide3Normals[i*4+j] = staticSide3NormalsInterp[i*4+j];
			}
		}
		side3Material->Copy( *side6TempMaterial );

		// side 4 = side 4
		for( int i = 0; i < numStaticSides4Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide4VerticesTranslated[i*4+j] = staticSide4VerticesTranslatedInterp[i*4 + j];
				staticSide4Normals[i*4+j] = staticSide4NormalsInterp[i*4+j];
			}
		}
		side4Material->Copy( *side4TempMaterial );

		// side 5 = side 3
		for( int i = 0; i < numStaticSides5Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide5VerticesTranslated[i*4+j] = staticSide5VerticesTranslatedInterp[i*4 + j];
				staticSide5Normals[i*4+j] = staticSide5NormalsInterp[i*4+j];
			}
		}
		side5Material->Copy( *side3TempMaterial );

		// side 6 = side 1
		for( int i = 0; i < numStaticSides6Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide6VerticesTranslated[i*4+j] = staticSide6VerticesTranslatedInterp[i*4 + j];
				staticSide6Normals[i*4+j] = staticSide6NormalsInterp[i*4+j];
			}
		}
		side6Material->Copy( *side1TempMaterial );

	} // end of reset, end of final destination of rotation
} // end of RotateStaticCubesDown()

void RotateStaticCubesClockwise()
{
	staticCubesAreRotating = true;

	// the initial rotation rotates several things instantly to final rotation before interpolation
	// must happen just once
	if( rotateStaticVerticesClockwise_firstIterationFinished == false )
	{
		// copy side vertices into interpolation arrays
		// Actually, use interpolation arrays as temp array to store copy of exact rotation
		rotateStaticVerticesClockwise_firstIterationFinished = true; // makes sure that this does not run again

		// when rotating the static cube, need to transform the cubes' positions as well as their display vertices
		srm.SetRotZ( -1024 );

		side1TempMaterial->Copy( *side1Material ); // copy material b/c it's a pointer
		side2TempMaterial->Copy( *side2Material );
		side3TempMaterial->Copy( *side3Material );
		side4TempMaterial->Copy( *side4Material );
		side5TempMaterial->Copy( *side5Material );
		side6TempMaterial->Copy( *side6Material );

		// ROTATE STATIC CUBES
		for( int i = 0; i < numStaticCubes; i++ )
		{
			cubePositionsTemp[i] = srm.TransformVec( cubeArray[i].position ); // this only affects future collision

			switch( cubeArray[i].direction )
			{
			case 1:
				// 1 = 1
				cubeArray[i].direction = 1;
				break;
			case 2:
				// 2 = 6
				cubeArray[i].direction = 6;
				break;
			case 3:
				// 3 = 3
				cubeArray[i].direction = 3;
				break;
			case 4:
				// 4 = 5
				cubeArray[i].direction = 5;
				break;
			case 5:
				// 5 = 2
				cubeArray[i].direction = 2;
				break;
			case 6:
				// 6 = 4
				cubeArray[i].direction = 4;
				break;
			}
		}

		for( int i = 0; i < numStaticSides1Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide1VerticesTranslatedInterp[i*4 + j] = staticSide1VerticesTranslated[i*4+j]; // copy
				//staticSide1VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide1VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide1NormalsInterp[i*4+j] = staticSide1Normals[i*4+j]; // copy
				//staticSide1NormalsInterp[i*4+j] = srm.TransformVec( staticSide1NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides2Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide2VerticesTranslatedInterp[i*4 + j] = staticSide2VerticesTranslated[i*4+j]; // copy
				//staticSide2VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide2VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide2NormalsInterp[i*4+j] = staticSide2Normals[i*4+j]; // copy
				//staticSide2NormalsInterp[i*4+j] = srm.TransformVec( staticSide2NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides3Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide3VerticesTranslatedInterp[i*4 + j] = staticSide3VerticesTranslated[i*4+j]; // copy
				//staticSide3VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide3VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide3NormalsInterp[i*4+j] = staticSide3Normals[i*4+j]; // copy
				//staticSide3NormalsInterp[i*4+j] = srm.TransformVec( staticSide3NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides4Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide4VerticesTranslatedInterp[i*4 + j] = staticSide4VerticesTranslated[i*4+j]; // copy
				//staticSide4VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide4VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide4NormalsInterp[i*4+j] = staticSide4Normals[i*4+j]; // copy
				//staticSide4NormalsInterp[i*4+j] = srm.TransformVec( staticSide4NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides5Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide5VerticesTranslatedInterp[i*4 + j] = staticSide5VerticesTranslated[i*4+j]; // copy
				//staticSide5VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide5VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide5NormalsInterp[i*4+j] = staticSide5Normals[i*4+j]; // copy
				//staticSide5NormalsInterp[i*4+j] = srm.TransformVec( staticSide5NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides6Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide6VerticesTranslatedInterp[i*4 + j] = staticSide6VerticesTranslated[i*4+j]; // copy
				//staticSide6VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide6VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide6NormalsInterp[i*4+j] = staticSide6Normals[i*4+j]; // copy
				//staticSide6NormalsInterp[i*4+j] = srm.TransformVec( staticSide6NormalsInterp[i*4+j] ); // rotate
			}
		}			
	}
		
	// set delta rotation for interpolation animation
	srm.SetRotZ( -1*deltaYStaticRotation );

	// ROTATE STATIC CUBES
	for( int i = numOriginalCubes; i < numStaticCubes; i++ )
	{
		cubeArray[i].position = srm.TransformVec( cubeArray[i].position );
	}

	// ROTATE STATIC SIDES VERTICES - side 1
	for( int i = 0; i < numStaticSides1Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide1VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide1VerticesTranslated[i*4 + j] );
			staticSide1Normals[i*4 + j] = srm.TransformVec( staticSide1Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 2
	for( int i = 0; i < numStaticSides2Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide2VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide2VerticesTranslated[i*4 + j] );
			staticSide2Normals[i*4 + j] = srm.TransformVec( staticSide2Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 3
	for( int i = 0; i < numStaticSides3Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide3VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide3VerticesTranslated[i*4 + j] );
			staticSide3Normals[i*4 + j] = srm.TransformVec( staticSide3Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 4
	for( int i = 0; i < numStaticSides4Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide4VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide4VerticesTranslated[i*4 + j] );
			staticSide4Normals[i*4 + j] = srm.TransformVec( staticSide4Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 5
	for( int i = 0; i < numStaticSides5Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide5VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide5VerticesTranslated[i*4 + j] );
			staticSide5Normals[i*4 + j] = srm.TransformVec( staticSide5Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 6
	for( int i = 0; i < numStaticSides6Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide6VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide6VerticesTranslated[i*4 + j] );
			staticSide6Normals[i*4 + j] = srm.TransformVec( staticSide6Normals[i*4 + j] );
		}
	}

	// ROTATE STATIC CUBE VERTICES
	for( int i = numOriginalCubes; i < numStaticCubes; i++ ) // only rotate moving-to-static cubes
	{
		for( int j = 0; j < 24; j++ )
		{
			cubeTranslated2[i*24 + j] = srm.TransformVec( cubeTranslated2[i*24 + j] );
			cubeNormals2[i*24 + j] = srm.TransformVec( cubeNormals2[i*24 + j] );
		}
	}

	// keeps track of how many degrees rotated
	cumulativeDeltaYRotation += deltaYStaticRotation;

	// When rotation has stopped
	if( cumulativeDeltaYRotation == 1024 ) // stops rotation if limit of degrees-of-rotation is reached
	{
		rotateStaticVerticesClockwise = false;
		rotateStaticVerticesClockwise_firstIterationFinished = false;
		staticCubesAreRotating = false;
		cumulativeDeltaYRotation = 0; // reset the count		

		// reset final position
		for( int i = numOriginalCubes; i < numStaticCubes; i++ )
		{
			cubeArray[i].position = cubePositionsTemp[i];
		}

		PlaneSide planeTemp[6];
		// initialize temporary planes
		for( int i = 0; i < 6; i++ )
		{
			planeTemp[i] = PlaneSide();
			planeTemp[i] = plane[i];
		}

		// reassign planes
		for( int i = 0; i < 6; i++ )
		{
			if( plane[i].direction == 1 ) // 1 = 1
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 1 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes						
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 2 ) // 2 = 5
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 5 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 3 ) // 3 = 3
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 3 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 4 ) // 4 = 6
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 6 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 5 ) // 5 = 4
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 4 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 6 ) // 6 = 2
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 2 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
		}

		// resets the final rotation position b/c of slight rotation error with integer division
		// the Normals for the sides are rotated and kept because they are not refreshed based on original cube positions
		// If implemented that way, it would be very expensive to refresh through every static cube
		// side 1 = side 1
		for( int i = 0; i < numStaticSides1Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide1VerticesTranslated[i*4+j] = staticSide1VerticesTranslatedInterp[i*4 + j];
				staticSide1Normals[i*4+j] = staticSide1NormalsInterp[i*4+j];
			}
		}
		side1Material->Copy( *side1TempMaterial );

		// side 2 = side 5
		for( int i = 0; i < numStaticSides2Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide2VerticesTranslated[i*4+j] = staticSide2VerticesTranslatedInterp[i*4 + j];
				staticSide2Normals[i*4+j] = staticSide2NormalsInterp[i*4+j];
			}
		}
		side2Material->Copy( *side5TempMaterial );

		// side 3 = side 3
		for( int i = 0; i < numStaticSides3Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide3VerticesTranslated[i*4+j] = staticSide3VerticesTranslatedInterp[i*4 + j];
				staticSide3Normals[i*4+j] = staticSide3NormalsInterp[i*4+j];
			}
		}
		side3Material->Copy( *side3TempMaterial );

		// side 4 = side 6
		for( int i = 0; i < numStaticSides4Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide4VerticesTranslated[i*4+j] = staticSide4VerticesTranslatedInterp[i*4 + j];
				staticSide4Normals[i*4+j] = staticSide4NormalsInterp[i*4+j];
			}
		}
		side4Material->Copy( *side6TempMaterial );

		// side 5 = side 4
		for( int i = 0; i < numStaticSides5Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide5VerticesTranslated[i*4+j] = staticSide5VerticesTranslatedInterp[i*4 + j];
				staticSide5Normals[i*4+j] = staticSide5NormalsInterp[i*4+j];
			}
		}
		side5Material->Copy( *side4TempMaterial );

		// side 6 = side 2
		for( int i = 0; i < numStaticSides6Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide6VerticesTranslated[i*4+j] = staticSide6VerticesTranslatedInterp[i*4 + j];
				staticSide6Normals[i*4+j] = staticSide6NormalsInterp[i*4+j];
			}
		}
		side6Material->Copy( *side2TempMaterial );

	} // end of reset, end of final destination of rotation
} // end of RotateStaticCubesClockwise()

void RotateStaticCubesCounterClockwise()
{
	staticCubesAreRotating = true;

	// the initial rotation rotates several things instantly to final rotation before interpolation
	// must happen just once
	if( rotateStaticVerticesCounterClockwise_firstIterationFinished == false )
	{
		// copy side vertices into interpolation arrays
		// Actually, use interpolation arrays as temp array to store copy of exact rotation
		rotateStaticVerticesCounterClockwise_firstIterationFinished = true; // makes sure that this does not run again

		// when rotating the static cube, need to transform the cubes' positions as well as their display vertices
		srm.SetRotZ( 1024 );

		side1TempMaterial->Copy( *side1Material ); // copy material b/c it's a pointer
		side2TempMaterial->Copy( *side2Material );
		side3TempMaterial->Copy( *side3Material );
		side4TempMaterial->Copy( *side4Material );
		side5TempMaterial->Copy( *side5Material );
		side6TempMaterial->Copy( *side6Material );

		// ROTATE STATIC CUBES
		for( int i = 0; i < numStaticCubes; i++ )
		{
			cubePositionsTemp[i] = srm.TransformVec( cubeArray[i].position ); // this only affects future collision

			switch( cubeArray[i].direction )
			{
			case 1:
				// 1 = 1
				cubeArray[i].direction = 1;
				break;
			case 2:
				// 2 = 5
				cubeArray[i].direction = 5;
				break;
			case 3:
				// 3 = 3
				cubeArray[i].direction = 3;
				break;
			case 4:
				// 4 = 6
				cubeArray[i].direction = 6;
				break;
			case 5:
				// 5 = 4
				cubeArray[i].direction = 4;
				break;
			case 6:
				// 6 = 2
				cubeArray[i].direction = 2;
				break;
			}
		}

		for( int i = 0; i < numStaticSides1Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide1VerticesTranslatedInterp[i*4 + j] = staticSide1VerticesTranslated[i*4+j]; // copy
				//staticSide1VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide1VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide1NormalsInterp[i*4+j] = staticSide1Normals[i*4+j]; // copy
				//staticSide1NormalsInterp[i*4+j] = srm.TransformVec( staticSide1NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides2Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide2VerticesTranslatedInterp[i*4 + j] = staticSide2VerticesTranslated[i*4+j]; // copy
				//staticSide2VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide2VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide2NormalsInterp[i*4+j] = staticSide2Normals[i*4+j]; // copy
				//staticSide2NormalsInterp[i*4+j] = srm.TransformVec( staticSide2NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides3Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide3VerticesTranslatedInterp[i*4 + j] = staticSide3VerticesTranslated[i*4+j]; // copy
				//staticSide3VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide3VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide3NormalsInterp[i*4+j] = staticSide3Normals[i*4+j]; // copy
				//staticSide3NormalsInterp[i*4+j] = srm.TransformVec( staticSide3NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides4Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide4VerticesTranslatedInterp[i*4 + j] = staticSide4VerticesTranslated[i*4+j]; // copy
				//staticSide4VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide4VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide4NormalsInterp[i*4+j] = staticSide4Normals[i*4+j]; // copy
				//staticSide4NormalsInterp[i*4+j] = srm.TransformVec( staticSide4NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides5Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide5VerticesTranslatedInterp[i*4 + j] = staticSide5VerticesTranslated[i*4+j]; // copy
				//staticSide5VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide5VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide5NormalsInterp[i*4+j] = staticSide5Normals[i*4+j]; // copy
				//staticSide5NormalsInterp[i*4+j] = srm.TransformVec( staticSide5NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides6Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide6VerticesTranslatedInterp[i*4 + j] = staticSide6VerticesTranslated[i*4+j]; // copy
				//staticSide6VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide6VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide6NormalsInterp[i*4+j] = staticSide6Normals[i*4+j]; // copy
				//staticSide6NormalsInterp[i*4+j] = srm.TransformVec( staticSide6NormalsInterp[i*4+j] ); // rotate
			}
		}			
	}
		
	// set delta rotation for interpolation animation
	srm.SetRotZ( deltaYStaticRotation );

	// ROTATE STATIC CUBES
	for( int i = numOriginalCubes; i < numStaticCubes; i++ )
	{
		cubeArray[i].position = srm.TransformVec( cubeArray[i].position );
	}

	// ROTATE STATIC SIDES VERTICES - side 1
	for( int i = 0; i < numStaticSides1Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide1VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide1VerticesTranslated[i*4 + j] );
			staticSide1Normals[i*4 + j] = srm.TransformVec( staticSide1Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 2
	for( int i = 0; i < numStaticSides2Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide2VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide2VerticesTranslated[i*4 + j] );
			staticSide2Normals[i*4 + j] = srm.TransformVec( staticSide2Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 3
	for( int i = 0; i < numStaticSides3Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide3VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide3VerticesTranslated[i*4 + j] );
			staticSide3Normals[i*4 + j] = srm.TransformVec( staticSide3Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 4
	for( int i = 0; i < numStaticSides4Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide4VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide4VerticesTranslated[i*4 + j] );
			staticSide4Normals[i*4 + j] = srm.TransformVec( staticSide4Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 5
	for( int i = 0; i < numStaticSides5Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide5VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide5VerticesTranslated[i*4 + j] );
			staticSide5Normals[i*4 + j] = srm.TransformVec( staticSide5Normals[i*4 + j] );
		}
	}
	// ROTATE STATIC SIDES VERTICES - side 6
	for( int i = 0; i < numStaticSides6Index; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			staticSide6VerticesTranslated[i*4 + j] = srm.TransformVec( staticSide6VerticesTranslated[i*4 + j] );
			staticSide6Normals[i*4 + j] = srm.TransformVec( staticSide6Normals[i*4 + j] );
		}
	}

	// ROTATE STATIC CUBE VERTICES
	for( int i = numOriginalCubes; i < numStaticCubes; i++ ) // only rotate moving-to-static cubes
	{
		for( int j = 0; j < 24; j++ )
		{
			cubeTranslated2[i*24 + j] = srm.TransformVec( cubeTranslated2[i*24 + j] );
			cubeNormals2[i*24 + j] = srm.TransformVec( cubeNormals2[i*24 + j] );
		}
	}

	// keeps track of how many degrees rotated
	cumulativeDeltaYRotation += deltaYStaticRotation;

	// When rotation has stopped
	if( cumulativeDeltaYRotation == 1024 ) // stops rotation if limit of degrees-of-rotation is reached
	{
		rotateStaticVerticesCounterClockwise = false;
		rotateStaticVerticesCounterClockwise_firstIterationFinished = false;
		staticCubesAreRotating = false;
		cumulativeDeltaYRotation = 0; // reset the count			

		// reset final position
		for( int i = numOriginalCubes; i < numStaticCubes; i++ )
		{
			cubeArray[i].position = cubePositionsTemp[i];
		}

		PlaneSide planeTemp[6];
		// initialize temporary planes
		for( int i = 0; i < 6; i++ )
		{
			planeTemp[i] = PlaneSide();
			planeTemp[i] = plane[i];
		}

		// reassign planes
		for( int i = 0; i < 6; i++ )
		{
			if( plane[i].direction == 1 ) // 1 = 1
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 1 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes						
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 2 ) // 2 = 6
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 6 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 3 ) // 3 = 3
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 3 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 4 ) // 4 = 5
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 5 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 5 ) // 5 = 2
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 2 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 6 ) // 6 = 4
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 4 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
		}

		// resets the final rotation position b/c of slight rotation error with integer division
		// the Normals for the sides are rotated and kept because they are not refreshed based on original cube positions
		// If implemented that way, it would be very expensive to refresh through every static cube
		// side 1 = side 1
		for( int i = 0; i < numStaticSides1Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide1VerticesTranslated[i*4+j] = staticSide1VerticesTranslatedInterp[i*4 + j];
				staticSide1Normals[i*4+j] = staticSide1NormalsInterp[i*4+j];
			}
		}
		side1Material->Copy( *side1TempMaterial );

		// side 2 = side 6
		for( int i = 0; i < numStaticSides2Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide2VerticesTranslated[i*4+j] = staticSide2VerticesTranslatedInterp[i*4 + j];
				staticSide2Normals[i*4+j] = staticSide2NormalsInterp[i*4+j];
			}
		}
		side2Material->Copy( *side6TempMaterial );

		// side 3 = side 3
		for( int i = 0; i < numStaticSides3Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide3VerticesTranslated[i*4+j] = staticSide3VerticesTranslatedInterp[i*4 + j];
				staticSide3Normals[i*4+j] = staticSide3NormalsInterp[i*4+j];
			}
		}
		side3Material->Copy( *side3TempMaterial );

		// side 4 = side 5
		for( int i = 0; i < numStaticSides4Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide4VerticesTranslated[i*4+j] = staticSide4VerticesTranslatedInterp[i*4 + j];
				staticSide4Normals[i*4+j] = staticSide4NormalsInterp[i*4+j];
			}
		}
		side4Material->Copy( *side5TempMaterial );

		// side 5 = side 2
		for( int i = 0; i < numStaticSides5Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide5VerticesTranslated[i*4+j] = staticSide5VerticesTranslatedInterp[i*4 + j];
				staticSide5Normals[i*4+j] = staticSide5NormalsInterp[i*4+j];
			}
		}
		side5Material->Copy( *side2TempMaterial );

		// side 6 = side 4
		for( int i = 0; i < numStaticSides6Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide6VerticesTranslated[i*4+j] = staticSide6VerticesTranslatedInterp[i*4 + j];
				staticSide6Normals[i*4+j] = staticSide6NormalsInterp[i*4+j];
			}
		}
		side6Material->Copy( *side4TempMaterial );

	} // end of reset, end of final destination of rotation
} // end of RotateStaticCubesCounterClockwise()

void SpawnMovingSets()
{
	
	if( GameState == PLAY_GAME ) // if the game mode is free play
	{
		// Level = 1,2 Speed is 1600. Cube spawns .5 seconds. 1 active side. 1 cube falling
		// Level = 3. Speed is 600. Cubes spawn .5 sec, 2 active sides. 2 cubes falling
		// level = 4. speed is 600. cubes spawn .5 sec, 4 active sides. 2 cubes falling
		// level = 5. speed is 400. cubes spawn 3. sec. 6 active sides. 4 cubes falling

		// check number of activeplanes here. Used to make sure only spawn if numMovingSets is less than numActivePlanes
		int16 numActivePlanes = 0;
		for( int i = 0; i < 6; i++ )
		{
			if( plane[i].active == true )
			{
				numActivePlanes++;
			}
		}

		// Spawning Algorithm Version 3
		if( numActivePlanes > 0 ) // general spawning algorithm. May not need for a condition to exist. Every part is handled individually by level and phase number
		{

			// NO EXPLODING CUBES and WARPING check to activate spawn timer
			cubeIsExploding = false;
			cubeIsWarping = false;			
			for( int i = numOriginalCubes; i < numStaticCubes; i++ )
			{
				if( cubeArray[i].exploding == true )
					cubeIsExploding = true;

				if( cubeArray[i].material == Cube::WARPING_MATERIAL )
					cubeIsWarping = true;
			}

			bool numFallingCubesLessThanPlanes = false; // determines when spawning can take place

			// handles when the spawning will take place determined by NUMBER OF CUBE SETS in play.
			if( cubeSpawning == SINGLE_RANDOM )
			{
				if( numMovingSets == 0 ) // spawn if no cubes in play
				{
					// Enable spawning
					numFallingCubesLessThanPlanes = true;
				}
				else
				{
					// Reset Spawn Timer, disable spawning
					SpawnTime0 = 0; // resetting spawn timers for when subsequent cubes will spawn if not-spawning condition is NOT met
					SpawnTime1 = 0;
					// Disable spawning
					numFallingCubesLessThanPlanes = false;
				}
			}
			else if( cubeSpawning == DOUBLE_INCOLOR || cubeSpawning == DOUBLE_RANDOM )
			{
				if( numMovingSets <= 1 && numMovingSets < numActivePlanes) // spawn if less than 1 or less cubes in play
				{
					// Enable spawning
					numFallingCubesLessThanPlanes = true;
				}
				else
				{
					// Reset Spawn Timer, disable spawning
					SpawnTime0 = 0; // resetting spawn timers for when subsequent cubes will spawn if not-spawning condition is NOT met
					SpawnTime1 = 0;
					// Disable spawning
					numFallingCubesLessThanPlanes = false;
				}
			}
			else if( cubeSpawning == TRIPLE_INCOLOR || cubeSpawning == TRIPLE_RANDOM )
			{
				if( numMovingSets <= 2 && numMovingSets < numActivePlanes) // spawn if less than 2 cubes in play
				{
					// Enable spawning
					numFallingCubesLessThanPlanes = true;
				}
				else
				{
					// Reset Spawn Timer, disable spawning
					SpawnTime0 = 0; // resetting spawn timers for when subsequent cubes will spawn if not-spawning condition is NOT met
					SpawnTime1 = 0;
					// Disable spawning
					numFallingCubesLessThanPlanes = false;
				}
			}
			else if( cubeSpawning == QUADRUPLE_INCOLOR || cubeSpawning == QUADRUPLE_RANDOM )
			{
				if( numMovingSets <= 3 && numMovingSets < numActivePlanes) // spawn if less than 3 cubes in play
				{
					// Enable spawning
					numFallingCubesLessThanPlanes = true;
				}
				else
				{
					// Reset Spawn Timer, disable spawning
					SpawnTime0 = 0; // resetting spawn timers for when subsequent cubes will spawn if not-spawning condition is NOT met
					SpawnTime1 = 0;
					// Disable spawning
					numFallingCubesLessThanPlanes = false;
				}
			}
			else if( cubeSpawning == QUINTUPLE_INCOLOR || cubeSpawning == QUINTUPLE_RANDOM )
			{
				if( numMovingSets <= 4 && numMovingSets < numActivePlanes) // spawn if less than 4 cubes in play
				{
					// Enable spawning
					numFallingCubesLessThanPlanes = true;
				}
				else
				{
					// Reset Spawn Timer, disable spawning
					SpawnTime0 = 0; // resetting spawn timers for when subsequent cubes will spawn if not-spawning condition is NOT met
					SpawnTime1 = 0;
					// Disable spawning
					numFallingCubesLessThanPlanes = false;
				}
			}
			else if( cubeSpawning == SEXTUPLE_INCOLOR || cubeSpawning == SEXTUPLE_RANDOM )
			{
				if( numMovingSets <= 5 && numMovingSets < numActivePlanes) // spawn if less than 5 cubes in play
				{
					// Enable spawning
					numFallingCubesLessThanPlanes = true;
				}
				else
				{
					// Reset Spawn Timer, disable spawning
					SpawnTime0 = 0; // resetting spawn timers for when subsequent cubes will spawn if not-spawning condition is NOT met
					SpawnTime1 = 0;
					// Disable spawning
					numFallingCubesLessThanPlanes = false;
				}
			}

			if( numFallingCubesLessThanPlanes == true && 
				(cubeSpawning == DOUBLE_INCOLOR ||
				 cubeSpawning == TRIPLE_INCOLOR ||
				 cubeSpawning == QUADRUPLE_INCOLOR ||
				 cubeSpawning == QUINTUPLE_INCOLOR ||
				 cubeSpawning == SEXTUPLE_INCOLOR ))// check to see if there are cubes on sides where plane material does not match 
			{
				for( int i = 0; i < 6; i++ )
				{
					if( plane[i].active == true ) // for each active plane side, find moving cube that is in its direction
					{
						for( int j = 0; j < 6; j++ )
						{
							if( cubeArrayMoving[j].direction == plane[i].direction )
							{
								if( cubeArrayMoving[j].color != plane[i].color ) // if there is at least one cube that doesn't match plane
								{
									numFallingCubesLessThanPlanes = false; // do not let cubes spawn
									break;
								}
							}
						}
					}
				}
			}

			// if there is 1 or less moving cube, wait 2 second and spawn a set randomly on any side
			// only start spawn timer if no cubes are warping and exploding
			if( numFallingCubesLessThanPlanes == true )
			{
				if( cubeIsExploding == false && cubeIsWarping == false )
				{
					SpawnTime0 = SpawnTime1;
					SpawnTime1 += 1;

					if( SpawnTime1 >= 30 ) // if half a second second passed. 30 frames per second, so 15 frames = half second
					{
						// booleans to tell when it starting to spawn
						isSpawning = true;
						completeComplete = false;
						spawningSetCounter = 0;

						// Random seed
						IwRandSeed( (int32)s3eTimerGetMs() );

						// Find RANDOM Material via Pigeonhole effect
						// materials are: SOLID_RED, SOLID_GREEN, SOLID_BLUE, SOLID_YELLOW, SOLID_PURPLE, SOLID_ORANGE
						int16 material = -1;
						// only spawn material if that plane is active
						// keep material if material is one of active plane's color
						bool duplicateMaterial = false;
						bool found = false;
						bool allInactive = true; // helps determine if all planes are active

						while( found == false )
						{
							// Generate the Material
							// if there are moving cubes in play, only spawn material that is different than those
							// keep looping until the material spawned is not a duplicate
							do							
							{
								material = IwRandMinMax( Cube::SOLID_RED, Cube::SOLID_ORANGE+1	);
								
								// check to make sure numMovingCubesIndex is not zero 
								if( numMovingCubesIndex != 0 )
								{
									// loop through current cubes to see if there is duplicate of material
									for( int i = 0; i < numMovingCubesIndex; i++ ) 
									{
										if( cubeArrayMoving[i].color == material ) // if there is a duplicate material
										{
											duplicateMaterial = true;
											break;
										}
										else // if there are no duplicates at end of for-loop, give signal to exit while loop
										{
											duplicateMaterial = false;
										}
									}

									// if there is a duplicate material, checks to see if the spawn type is in-color. if it is, do not spawn
									if( duplicateMaterial == true && (cubeSpawning == DOUBLE_INCOLOR ||
																		cubeSpawning == TRIPLE_INCOLOR ||
																		cubeSpawning == QUADRUPLE_INCOLOR ||
																		cubeSpawning == QUINTUPLE_INCOLOR ||
																		cubeSpawning == SEXTUPLE_INCOLOR) )
									{
										duplicateMaterial = true;
										break;
									}
								}
								else // if no moving cubes are in play, automatically accept material for further checking
								{
									duplicateMaterial = false;
								}
								
							}
							while( duplicateMaterial == true ); // loop if there is a duplicate material
						
							// checks to see if material is active
							for( int i = 0; i < 6; i++ )
							{
								// checks to see if cubeSpawning is incolor and if there was duplicate material. do not spawn if true
								if( duplicateMaterial == true && (cubeSpawning == DOUBLE_INCOLOR ||
																		cubeSpawning == TRIPLE_INCOLOR ||
																		cubeSpawning == QUADRUPLE_INCOLOR ||
																		cubeSpawning == QUINTUPLE_INCOLOR ||
																		cubeSpawning == SEXTUPLE_INCOLOR) )
								{
									material = -1;
									found = true; // get out of while loop
									break;
								}
								// checks if side of the material spawned is "active"
								else if( plane[i].color == material && plane[i].active == true )
								{
									// if the material of the plane is active, let it spawn
									found = true;
									break;
								}
								else if( plane[i].active == true ) // checks to tell loop that it is not infinite loop
								{
									// says there cannot be infinite loop, so it's ok to loop again
									allInactive = false; // the statement that all sides are inactive is false.
								}

								if( i == 5 && allInactive == true ) // if all planes are inactive at end of iteration, break to prevent infinite loop
								{
									material = -1; // sets material so that nothing is spawned
									found = true; // breaks out of infinite loop
									break;
								}
							}
						} // end of while loop for generating material
						
						// FACESIDE 
						int16 faceSide = IwRandMinMax( 1, 6+1 ); // the maximum is NOT inclusive

						if( cubeSpawning == SINGLE_RANDOM )
						{
							// spawn ONE set randomly within active planes
							// generate a random faceside
							// find the plane with that direction
							// if that plane is not active, generate a new side
							// loop back to step #1
							
							for( int i = 0; i < 6; i++ )
							{
								if( plane[i].color == material ) // find the plane that material was generated for
								{
									// if the plane is active, set boolean to not loop
									if( plane[i].active == true )
									{
										faceSide = plane[i].direction;
										break;
									}
								}								
							}
						}
						else if( cubeSpawning == DOUBLE_INCOLOR ||
									cubeSpawning == TRIPLE_INCOLOR ||
									cubeSpawning == QUADRUPLE_INCOLOR ||
									cubeSpawning == QUINTUPLE_INCOLOR ||
									cubeSpawning == SEXTUPLE_INCOLOR ) // double in-color
						{
							if( material != -1 ) // if material was not null
							{
								// spawn within plane that material was found for
								for( int i = 0; i < 6; i++ )
								{
									if( plane[i].color == material )
									{
										faceSide = plane[i].direction;

										// do a check to see if that plane side already has a cube on it. if it does, do not spawn
										for( int j = 0; j < numMovingCubesIndex; j++ )
										{
											if( cubeArrayMoving[j].direction == faceSide ) // if there was a cube occupied in that color
											{
												// do not spawn
												material = -1;
												break;
											}
										}
									}
								}

								
							}
						}
						else if( cubeSpawning == DOUBLE_RANDOM || 
								cubeSpawning == TRIPLE_RANDOM ||
								cubeSpawning == QUADRUPLE_RANDOM ||
								cubeSpawning == QUINTUPLE_RANDOM ||
								cubeSpawning == SEXTUPLE_RANDOM ) // Random faceside generation: spawn on faceside that has no cubes there. 
						{
							
							bool emptySide = true;						
							do
							{
								faceSide = IwRandMinMax( 1, 6+1 ); // the maximum is NOT inclusive
								emptySide = true;

								for( int i = 0; i < numMovingCubesIndex; i++ )
								{
									if( faceSide == cubeArrayMoving[i].direction )
									{
										emptySide = false;
										break;
									}
								}
							}
							while( emptySide == false );
						}

						// Set the starting 

						int16 height = startingHeight;
						
					
						int16 oneInXChance = 2; // the one in X chance to spawn a fuzzy in a cube
						fuzzyLimit = 200;

						// types are: SINGLE, DOUBLE, TRIPLE_CORNER, TRIPLE_LINE, QUAD_SQUARE, QUAD_T
						//int16 type = IwRandMinMax( SINGLE, TRIPLE_LINE + 1);  // the maximum is NOT inclusive
						int16 type = IwRandMinMax( SINGLE, TRIPLE_LINE + 1);  // the maximum is NOT inclusive

						// testing
						/*
						if( levelNumber < 10 )
						{
							type = TRIPLE_LINE; // for testing in story or anywhere type equals
						}
						*/

						if( developerLevels == true )
						{
							type = TRIPLE_LINE;
						}

						// Control the TYPE spawning
						for( int i = 0; i < 6; i++ )
						{
							if( plane[i].color == material ) // finds the active plane
							{
								// if there is ONE CUBE LEFT, generate a single cube
								if( plane[i].count == 8 ) // if there is 1 cube not touching plane, generate single cube for guaranteed warp if done right
								{
									type = SINGLE; // have a single no matter what
									/*
									if( plane[i].allowSingleCubeSpawn == true )
									{
										type = SINGLE;

										// allow generating a single cube to fill hole to happen just ONCE. 
										// should be reset when a plane warps
										plane[i].allowSingleCubeSpawn = false;
									}
									*/
								}
								else if( episode == 1 && levelNumber >= 1 && levelNumber <= 3 && percentComplete > .999 && plane[i].count == 7 )
								{
									// this is spawning for tutorial. It makes it easier to get a perfect clear when they need it
									type = SINGLE;
								}
								// if there are TWO CUBES LEFT, generate a double or single
								else if( plane[i].count ==  7 ) 
								{
									if( IwRandMinMax( 1, 2+1 ) == 2 )
									{	
										type = DOUBLE;
									}
									else
									{
										type = SINGLE;
									}
								}
							}
						}

						// show tutorial rotate
						// contorl type spawning for tutorial - makes sure no single spawns until rotate is pressed
						if( episode == 1 && levelNumber == 1 && triggeredHideTutorialRotate == false )
						{
							while( type == SINGLE )
							{
								type = IwRandMinMax( SINGLE, TRIPLE_LINE + 1);
							}
						}

						// if there is a bomb landed, spawn single spawns
						for( int i = numOriginalCubes; i < numStaticCubes; i++ )
						{
							if( cubeArray[i].hasBomb == true && bombType == FBOMB ) // only generate single defuses for fbombs, not wtfbombs
							{
								type = SINGLE;
							}
						}

						if( spawnBomb == true && bombType == WTFBOMB ) // if the bombtype is wtfbomb and spawning bomb is true, spawn sets according to episode
						{
							// if a bomb is spawning for ep 4, 5, or 6, only certain cube types are allowed for that set
							switch( episode )
							{
							case 4:
								type = SINGLE;
								break;
							case 5:
								type = DOUBLE;
								break;
							case 6:
								IwRandSeed( (int32)s3eTimerGetMs() );
								int randomNum = IwRandMinMax(0, 1+1);
								if( randomNum == 0 ) // give bomb 50/50 chance to spawn triple line or corner
								{
									type = TRIPLE_LINE;
								}
								else
								{
									type = TRIPLE_CORNER;
								}
								break;
							}
						}

						if( material != -1 )
						{
							// the height is in units of side length. Rate is the lowest speed
							SpawnCubesAndShadows( faceSide, height, type, material, INITIAL_SPEED, oneInXChance );					
							numMovingSets++;
							SpawnTime1 = 0; // reset spawn time so there is interval between 2 spawning cubes
						}
					
						isSpawning = false;
					} // end of if( spawn time = 30 )
				} // end of if( not warping && not exploding )
			} // end of if numFallingCubes less than planes
		} // end of if number of active planes greater than zero
		// end of Spawning Algorithm version 3


		/* // Old spawning algorithm version 2
		if( numActivePlanes > 0 ) // general spawning algorithm. May not need for a condition to exist. Every part is handled individually by level and phase number
		{

			
			
			// NO EXPLODING CUBES and WARPING check to activate spawn timer
			cubeIsExploding = false;
			cubeIsWarping = false;			
			for( int i = numOriginalCubes; i < numStaticCubes; i++ )
			{
				if( cubeArray[i].exploding == true )
					cubeIsExploding = true;

				if( cubeArray[i].material == Cube::WARPING_MATERIAL )
					cubeIsWarping = true;
			}

			bool numFallingCubesLessThanPlanes = false; // determines when spawning can take place

			// handles when the spawning will take place. Spawning happens when this condition is not true
			if( levelNumber == 1  ||
				levelNumber == 2)
			{				
				if( numMovingSets == 0 ) // spawn if no cubes in play
				{
					// Enable spawning
					numFallingCubesLessThanPlanes = true;
				}
				else
				{
					// Reset Spawn Timer, disable spawning
					SpawnTime0 = 0; // resetting spawn timers for when subsequent cubes will spawn if not-spawning condition is NOT met
					SpawnTime1 = 0;
					// Disable spawning
					numFallingCubesLessThanPlanes = false;
				}
			}
			else if( levelNumber == 3 ||
					levelNumber == 4)
			{
				if( numMovingSets <= 1 && numMovingSets < numActivePlanes) // spawn if less than 1 or less cubes in play
				{
					// Enable spawning
					numFallingCubesLessThanPlanes = true;
				}
				else
				{
					// Reset Spawn Timer, disable spawning
					SpawnTime0 = 0; // resetting spawn timers for when subsequent cubes will spawn if not-spawning condition is NOT met
					SpawnTime1 = 0;
					// Disable spawning
					numFallingCubesLessThanPlanes = false;
				}
			}

			// if there is 1 or less moving cube, wait 2 second and spawn a set randomly on any side
			// only start spawn timer if no cubes are warping and exploding
			if( numFallingCubesLessThanPlanes == true )
			{
				if( cubeIsExploding == false && cubeIsWarping == false )
				{
					SpawnTime0 = SpawnTime1;
					SpawnTime1 += 1;

					if( SpawnTime1 >= 30 ) // if half a second second passed. 30 frames per second, so 15 frames = half second
					{
						// booleans to tell when it starting to spawn
						isSpawning = true;
						completeComplete = false;
						spawningSetCounter = 0;

						// Random seed
						IwRandSeed( (int32)s3eTimerGetMs() );

						// FACESIDE 
						int16 faceSide = IwRandMinMax( 1, 6+1 ); // the maximum is NOT inclusive

						if( numActivePlanes == 1 ) // if there is only 1 active plane left
						{
							// spawn single cube on the only active side
							for( int i = 0; i < 6; i++ ) // Find the active plane side
							{
								if( plane[i].active == true )
								{
									faceSide = plane[i].direction;
								}
							}
						}
						else if( levelNumber == 2 ) // for level 2, 
						{			
							// spawn ONE set randomly within active planes
							int activeSide[2];
							int activeSideIndex = 0;
							for( int i = 0; i < 6; i++ )
							{
								if( plane[i].active == true ) // this should happen twice, just enough to fill activeSide
								{
									activeSide[activeSideIndex] = plane[i].direction;
									activeSideIndex++;
								}								
							}
							do
							{
								faceSide = IwRandMinMax(1, 6+1 );
							}
							while( faceSide != activeSide[0] && faceSide != activeSide[1] );
						}
						else if( levelNumber == 3 )
						{
							// spawn MULTIPLE sets randomly within active planes
							int activeSide[2];
							int activeSideIndex = 0;
							bool emptySide = true;		

							for( int i = 0; i < 6; i++ ) // find the directions that are active
							{
								if( plane[i].active == true ) // this should happen twice, just enough to fill activeSide
								{
									activeSide[activeSideIndex] = plane[i].direction;
									activeSideIndex++;
								}								
							}

							do
							{
								emptySide = true;	
								faceSide = IwRandMinMax(1, 6+1 );

								for( int i = 0; i < numMovingCubesIndex; i++ ) // eliminate the directions that are occupied
								{
									if( faceSide == cubeArrayMoving[i].direction )
									{
										emptySide = false;
										break;
									}
								}
							}
							while( (faceSide != activeSide[0] && faceSide != activeSide[1]) || emptySide == false );
							// only continue through if faceSide equals activeS1 or ActiveS2 AND emptySide == false
							// invert to get the loop condition
						}
						else 
						{
							// Random faceside generation: spawn on faceside that has no cubes there. 
							bool emptySide = true;						
							do
							{
								faceSide = IwRandMinMax( 1, 6+1 ); // the maximum is NOT inclusive
								emptySide = true;

								for( int i = 0; i < numMovingCubesIndex; i++ )
								{
									if( faceSide == cubeArrayMoving[i].direction )
									{
										emptySide = false;
										break;
									}
								}
							}
							while( emptySide == false );
						} // end of else-if for random faceside generation

						int16 height = 18;

						// materials are: SOLID_RED, SOLID_GREEN, SOLID_BLUE, SOLID_YELLOW, SOLID_PURPLE, SOLID_ORANGE
						int16 material = -1;
						// only spawn material if that plane is active
						// keep material if material is one of active plane's color
						bool duplicateMaterial = false;
						bool found = false;
						bool allInactive = true; // helps determine if all planes are active

						// FIND MATERIAL
						// only find material if there are more active sides than there are movingSets in play
						if( levelNumber == 3 )
						{
							for( int i = 0; i < 6; i++ )
							{
								if( plane[i].direction == faceSide )
								{
									// get material of plane side for level 3
									material = plane[i].color;
									break;
								}
							}
						}
						// Find RANDOM Material via Pigeonhole effect
						else if( numMovingSets < numActivePlanes )
						{
							while( found == false )
							{
							
								// Generate the Material
								// if there are moving cubes in play, only spawn material that is different than those
								// keep looping until the material spawned is not a duplicate
								do							
								{
								
									material = IwRandMinMax( Cube::SOLID_RED, Cube::SOLID_ORANGE+1	);
								
									// check to make sure numMovingCubesIndex is not zero 
									if( numMovingCubesIndex != 0 )
									{
										// loop through current cubes to see if there is duplicate of material
										for( int i = 0; i < numMovingCubesIndex; i++ ) 
										{
											if( cubeArrayMoving[i].color == material ) // if there is a duplicate material. use COLOR
											{
												duplicateMaterial = true;
												break;
											}
											else // if there are no duplicates at end of for-loop, give signal to exit while loop
											{
												duplicateMaterial = false;
											}
										}
									}
									else // if no moving cubes are in play, automatically accept material for further checking
									{
										duplicateMaterial = false;
									}
								
								}
								while( duplicateMaterial == true ); // loop if there is a duplicate material
						
								// checks to see if material is active
								for( int i = 0; i < 6; i++ )
								{
									// checks if the material spawned is "active"
									if( plane[i].active == true && plane[i].color == material )
									{
										// if the material of the plane is active, let it spawn
										found = true;
										break;
									}
									else if( plane[i].active == true ) // checks to tell loop that it is not infinite loop
									{
										// says there cannot be infinite loop
										allInactive = false; // the statement that all sides are inactive is false.
									}

									if( i == 5 && allInactive == true ) // if all planes are inactive at end of iteration, break to prevent infinite loop
									{
										material = -1;
										found = true;
										break;
									}
								}
							} // end of while loop for generating material
						} // end of if numMovingSets <= numActivePlanes
						else
						{
							material = -1; // no material, no spawning
						}
					
						int16 oneInXChance = 2; // the one in X chance to spawn a fuzzy in a cube
						fuzzyLimit = 200;

						// types are: SINGLE, DOUBLE, TRIPLE_CORNER, TRIPLE_LINE, QUAD_SQUARE, QUAD_T
						//int16 type = IwRandMinMax( SINGLE, TRIPLE_LINE + 1);  // the maximum is NOT inclusive
						int16 type = IwRandMinMax( SINGLE, TRIPLE_LINE + 1);  // the maximum is NOT inclusive

						//type = TRIPLE_LINE;

						// if there is one cube left, generate a single cube
						for( int i = 0; i < 6; i++ )
						{
							if( plane[i].color == material ) // finds the active plane
							{
								if( plane[i].count == 8 ) // if there is 1 cube not touching plane, generate single cube for guaranteed warp if done right
								{
									if( plane[i].allowSingleCubeSpawn == true )
									{
										type = SINGLE;

										// allow generating a single cube to fill hole to happen just ONCE. 
										// should be reset when a plane warps
										plane[i].allowSingleCubeSpawn = false;
									}
								}
							}
						}

						if( material != -1 )
						{
							// the height is in units of side length. Rate is the lowest speed
							SpawnCubesAndShadows( faceSide, height, type, material, 600, oneInXChance );
							numMovingSets++;
							SpawnTime1 = 0; // reset spawn time so there is interval between 2 spawning cubes
						}
					
						isSpawning = false;
					} // end of if( spawn time = 30 )
				} // end of if( not warping && not exploding )
			} // end of if numFallingCubes less than planes
		} // end of if number of active planes greater than zero
		*/ // end of comment out of OLD SPAWNING ALGORITHM version 2

		
		// The following spawning algorithms may be obsolete
		/*
		if( levelNumber == 1 || levelNumber == 2) // difficulty level 1 of free play
		{
			// NO EXPLODING CUBES and WARPING check to activate spawn timer
			cubeIsExploding = false;
			cubeIsWarping = false;			
			for( int i = numOriginalCubes; i < numStaticCubes; i++ )
			{
				if( cubeArray[i].exploding == true )
					cubeIsExploding = true;

				if( cubeArray[i].material == Cube::WARPING_MATERIAL )
					cubeIsWarping = true;
			}

			// if there are moving cubes, do nothing
			if( numMovingSets != 0 )
			{
				SpawnTime0 = 0;
				SpawnTime1 = 0;
				// do nothing
			}
			// if there are no moving cubes, wait 2 second and spawn a set randomly on any side
			// only start spawn timer if no cubes are warping and exploding
			else if( cubeIsExploding == false && cubeIsWarping == false )
			{
				SpawnTime0 = SpawnTime1;
				SpawnTime1 += 1;

				if( SpawnTime1 >= 30 ) // if half a second second passed. 30 frames per second, so 15 frames = half second
				{
					// boolean to tell when it starting to spawn
					isSpawning = true;
					completeComplete = false;
					spawningSetCounter = 0;

					// spawn a set of cubes
					IwRandSeed( (int32)s3eTimerGetMs() );

					// faceSide spawns on current faceside ?
					int16 faceSide = IwRandMinMax( 1, 6+1 ); // the maximum is NOT inclusive
					faceSide = getActiveFaceSide();

					int16 height = 18;

					
					// materials are: SOLID_RED, SOLID_GREEN, SOLID_BLUE, SOLID_YELLOW, SOLID_PURPLE, SOLID_ORANGE
					int16 material = -1;
					// only spawn material if that plane is active
					// keep material if material is one of active plane's color
					bool duplicateMaterial = true;
					bool found = false;
					bool allInactive = true; // helps determine if all planes are active
					
					// FIND MATERIAL
					// only find material if there are more active sides than there are movingSets in play
					if( numMovingSets < numActivePlanes )
					{
						
						while( found == false )
						{
							
							// Generate the Material
							// if there are moving cubes in play, only spawn material that is different than those
							// keep looping until the material spawned is not a duplicate
							do							
							{
								
								material = IwRandMinMax( Cube::SOLID_RED, Cube::SOLID_ORANGE+1	);
								
								// check to make sure numMovingCubesIndex is not zero 
								if( numMovingCubesIndex != 0 )
								{
									// loop through current cubes to see if there is duplicate of material
									for( int i = 0; i < numMovingCubesIndex; i++ ) 
									{
										if( cubeArrayMoving[i].color == material ) // if there is a duplicate material. use COLOR to match
										{
											duplicateMaterial = true;
											break;
										}
										else // if there are no duplicates at end of for-loop, give signal to exit while loop
										{
											duplicateMaterial = false;
										}
									}
								}
								else // if no moving cubes are in play, automatically accept material for further checking
								{
									duplicateMaterial = false;
								}
								
							}
							while( duplicateMaterial == true ); // loop if there is a duplicate material
						
							// checks to see if material is active
							for( int i = 0; i < 6; i++ )
							{
								// checks if the material spawned is "active"
								if( plane[i].active == true && plane[i].color == material )
								{
									// if the material of the plane is active, let it spawn
									found = true;
									break;
								}
								else if( plane[i].active == true ) // checks to tell loop that it is not infinite loop
								{
									// says there cannot be infinite loop
									allInactive = false; // the statement that all sides are inactive is false.
								}

								if( i == 5 && allInactive == true ) // if all planes are inactive at end of iteration, break to prevent infinite loop
								{
									material = -1;
									found = true;
									break;
								}
							}
						} // end of while loop for generating material
					} // end of if numMovingSets <= numActivePlanes
					else
					{
						material = -1; // no material, no spawning
					}

					int16 oneInXChance = 2; // the one in X chance to spawn a fuzzy in a cube
					fuzzyLimit = 200;

					// types are: SINGLE, DOUBLE, TRIPLE_CORNER, TRIPLE_LINE, QUAD_SQUARE, QUAD_T
					//int16 type = IwRandMinMax( SINGLE, TRIPLE_LINE + 1);  // the maximum is NOT inclusive
					int16 type = IwRandMinMax( SINGLE, TRIPLE_LINE + 1);  // the maximum is NOT inclusive
					
					//type = TRIPLE_LINE;

					// if there is one cube left, generate a single cube
					for( int i = 0; i < 6; i++ )
					{
						if( plane[i].color == material ) // finds the active plane
						{
							if( plane[i].count == 8 ) // if there is 1 cube not touching plane, generate single cube for guaranteed warp if done right
							{
								if( plane[i].allowSingleCubeSpawn == true )
								{
									type = SINGLE;

									// allow generating a single cube to fill hole to happen just ONCE. 
									// should be reset when a plane warps
									plane[i].allowSingleCubeSpawn = false;
								}
							}
						}
					}
					

					//type = TRIPLE_LINE;

					if( material != -1 )
					{
						// the height is in units of side length. Rate is the lowest speed
						SpawnCubesAndShadows( faceSide, height, type, material, 800, oneInXChance );
						numMovingSets++;
					}

					isSpawning = false;
				}
			}
		} // end of if level == 1
		else if( levelNumber == 3 ) 
		{
			// NO EXPLODING CUBES and WARPING check to activate spawn timer
			cubeIsExploding = false;
			cubeIsWarping = false;			
			for( int i = numOriginalCubes; i < numStaticCubes; i++ )
			{
				if( cubeArray[i].exploding == true )
					cubeIsExploding = true;

				if( cubeArray[i].material == Cube::WARPING_MATERIAL )
					cubeIsWarping = true;
			}

			// if there are 2 moving cube sets, do nothing
			if( numMovingSets >= 2 || numMovingSets >= numActivePlanes)
			{
				SpawnTime0 = 0;
				SpawnTime1 = 0;
				// do nothing
			}
			// if there is 1 or less moving cube, wait 2 second and spawn a set randomly on any side
			// only start spawn timer if no cubes are warping and exploding
			else if( cubeIsExploding == false && cubeIsWarping == false )
			{
				SpawnTime0 = SpawnTime1;
				SpawnTime1 += 1;

				if( SpawnTime1 >= 30 ) // if half a second second passed. 30 frames per second, so 15 frames = half second
				{
					// boolean to tell when it starting to spawn
					isSpawning = true;
					completeComplete = false;
					spawningSetCounter = 0;

					// spawn a set of cubes
					IwRandSeed( (int32)s3eTimerGetMs() );

					// FACESIDE 
					int16 faceSide = IwRandMinMax( 1, 6+1 ); // the maximum is NOT inclusive
					if( numActivePlanes == 1 ) // if there is only 1 active plane left, spawn on activefaceside
					{
						faceSide = getActiveFaceSide();
					}
					else // if there are more than 1 plane sides left, use this algorithm
					{
						bool emptySide = true;
						// spawn on faceside that has no cubes there
						do
						{
							faceSide = IwRandMinMax( 1, 6+1 ); // the maximum is NOT inclusive
							emptySide = true;

							for( int i = 0; i < numMovingCubesIndex; i++ )
							{
								if( faceSide == cubeArrayMoving[i].direction )
								{
									emptySide = false;
									break;
								}
							}
						}
						while( emptySide == false );
					}

					int16 height = 18;

					// materials are: SOLID_RED, SOLID_GREEN, SOLID_BLUE, SOLID_YELLOW, SOLID_PURPLE, SOLID_ORANGE
					int16 material = -1;
					// only spawn material if that plane is active
					// keep material if material is one of active plane's color
					bool duplicateMaterial = false;
					bool found = false;
					bool allInactive = true; // helps determine if all planes are active

					// FIND MATERIAL
					// only find material if there are more active sides than there are movingSets in play
					if( numMovingSets < numActivePlanes )
					{
						while( found == false )
						{
							
							// Generate the Material
							// if there are moving cubes in play, only spawn material that is different than those
							// keep looping until the material spawned is not a duplicate
							do							
							{
								
								material = IwRandMinMax( Cube::SOLID_RED, Cube::SOLID_ORANGE+1	);
								
								// check to make sure numMovingCubesIndex is not zero 
								if( numMovingCubesIndex != 0 )
								{
									// loop through current cubes to see if there is duplicate of material
									for( int i = 0; i < numMovingCubesIndex; i++ ) 
									{
										if( cubeArrayMoving[i].color == material ) // if there is a duplicate material. use COLOR
										{
											duplicateMaterial = true;
											break;
										}
										else // if there are no duplicates at end of for-loop, give signal to exit while loop
										{
											duplicateMaterial = false;
										}
									}
								}
								else // if no moving cubes are in play, automatically accept material for further checking
								{
									duplicateMaterial = false;
								}
								
							}
							while( duplicateMaterial == true ); // loop if there is a duplicate material
						
							// checks to see if material is active
							for( int i = 0; i < 6; i++ )
							{
								// checks if the material spawned is "active"
								if( plane[i].active == true && plane[i].color == material )
								{
									// if the material of the plane is active, let it spawn
									found = true;
									break;
								}
								else if( plane[i].active == true ) // checks to tell loop that it is not infinite loop
								{
									// says there cannot be infinite loop
									allInactive = false; // the statement that all sides are inactive is false.
								}

								if( i == 5 && allInactive == true ) // if all planes are inactive at end of iteration, break to prevent infinite loop
								{
									material = -1;
									found = true;
									break;
								}
							}
						} // end of while loop for generating material
					} // end of if numMovingSets <= numActivePlanes
					else
					{
						material = -1; // no material, no spawning
					}
					
					int16 oneInXChance = 2; // the one in X chance to spawn a fuzzy in a cube
					fuzzyLimit = 200;

					// types are: SINGLE, DOUBLE, TRIPLE_CORNER, TRIPLE_LINE, QUAD_SQUARE, QUAD_T
					//int16 type = IwRandMinMax( SINGLE, TRIPLE_LINE + 1);  // the maximum is NOT inclusive
					int16 type = IwRandMinMax( SINGLE, TRIPLE_LINE + 1);  // the maximum is NOT inclusive

					// if there is one cube left, generate a single cube
					for( int i = 0; i < 6; i++ )
					{
						if( plane[i].color == material ) // finds the active plane
						{
							if( plane[i].count == 8 ) // if there is 1 cube not touching plane, generate single cube for guaranteed warp if done right
							{
								if( plane[i].allowSingleCubeSpawn == true )
								{
									type = SINGLE;

									// allow generating a single cube to fill hole to happen just ONCE. 
									// should be reset when a plane warps
									plane[i].allowSingleCubeSpawn = false;
								}
							}
						}
					}

					//type = TRIPLE_LINE;

					if( material != -1 )
					{
						// the height is in units of side length. Rate is the lowest speed
						SpawnCubesAndShadows( faceSide, height, type, material, 600, oneInXChance );
						numMovingSets++;
						SpawnTime1 = 0; // reset spawn time so there is interval between 2 spawning cubes
					}
					
					isSpawning = false;
				} // end of if( spawn time = 45 )
			} // end of if( not warping && not exploding )
		} // end of if level == 3
		else if( levelNumber == 4 ) 
		{
			// NO EXPLODING CUBES and WARPING check to activate spawn timer
			cubeIsExploding = false;
			cubeIsWarping = false;			
			for( int i = numOriginalCubes; i < numStaticCubes; i++ )
			{
				if( cubeArray[i].exploding == true )
					cubeIsExploding = true;

				if( cubeArray[i].material == Cube::WARPING_MATERIAL )
					cubeIsWarping = true;
			}

			// if there are 3 moving cube sets, do nothing
			if( numMovingSets >= 2 || numMovingSets >= numActivePlanes)
			{
				SpawnTime0 = 0;
				SpawnTime1 = 0;
				// do nothing
			}
			// if there is 1 or less moving cube, wait 2 second and spawn a set randomly on any side
			// only start spawn timer if no cubes are warping and exploding
			else if( cubeIsExploding == false && cubeIsWarping == false )
			{
				SpawnTime0 = SpawnTime1;
				SpawnTime1 += 1;

				if( SpawnTime1 >= 30 ) // if half a second second passed. 30 frames per second, so 15 frames = half second
				{
					// boolean to tell when it starting to spawn
					isSpawning = true;
					completeComplete = false;
					spawningSetCounter = 0;

					// spawn a set of cubes
					IwRandSeed( (int32)s3eTimerGetMs() );

					// FACESIDE 
					int16 faceSide = IwRandMinMax( 1, 6+1 ); // the maximum is NOT inclusive
					if( numActivePlanes == 1 ) // if there is only 1 active plane left, spawn on activefaceside
					{
						faceSide = getActiveFaceSide();
					}
					else // if there are more than 1 plane sides left, use this algorithm
					{
						bool emptySide = true;
						// spawn on faceside that has no cubes there
						do
						{
							faceSide = IwRandMinMax( 1, 6+1 ); // the maximum is NOT inclusive
							emptySide = true;

							for( int i = 0; i < numMovingCubesIndex; i++ )
							{
								if( faceSide == cubeArrayMoving[i].direction )
								{
									emptySide = false;
									break;
								}
							}
						}
						while( emptySide == false );
					}

					int16 height = 18;

					// materials are: SOLID_RED, SOLID_GREEN, SOLID_BLUE, SOLID_YELLOW, SOLID_PURPLE, SOLID_ORANGE
					int16 material = -1;
					// only spawn material if that plane is active
					// keep material if material is one of active plane's color
					bool duplicateMaterial = false;
					bool found = false;
					bool allInactive = true; // helps determine if all planes are active

					// FIND MATERIAL
					// only find material if there are more active sides than there are movingSets in play
					if( numMovingSets < numActivePlanes )
					{
						while( found == false )
						{
							
							// Generate the Material
							// if there are moving cubes in play, only spawn material that is different than those
							// keep looping until the material spawned is not a duplicate
							do							
							{
								
								material = IwRandMinMax( Cube::SOLID_RED, Cube::SOLID_ORANGE+1	);
								
								// check to make sure numMovingCubesIndex is not zero 
								if( numMovingCubesIndex != 0 )
								{
									// loop through current cubes to see if there is duplicate of material
									for( int i = 0; i < numMovingCubesIndex; i++ ) 
									{
										if( cubeArrayMoving[i].color == material ) // if there is a duplicate material. use COLOR
										{
											duplicateMaterial = true;
											break;
										}
										else // if there are no duplicates at end of for-loop, give signal to exit while loop
										{
											duplicateMaterial = false;
										}
									}
								}
								else // if no moving cubes are in play, automatically accept material for further checking
								{
									duplicateMaterial = false;
								}
								
							}
							while( duplicateMaterial == true ); // loop if there is a duplicate material
						
							// checks to see if material is active
							for( int i = 0; i < 6; i++ )
							{
								// checks if the material spawned is "active"
								if( plane[i].active == true && plane[i].color == material )
								{
									// if the material of the plane is active, let it spawn
									found = true;
									break;
								}
								else if( plane[i].active == true ) // checks to tell loop that it is not infinite loop
								{
									// says there cannot be infinite loop
									allInactive = false; // the statement that all sides are inactive is false.
								}

								if( i == 5 && allInactive == true ) // if all planes are inactive at end of iteration, break to prevent infinite loop
								{
									material = -1;
									found = true;
									break;
								}
							}
						} // end of while loop for generating material
					} // end of if numMovingSets <= numActivePlanes
					else
					{
						material = -1; // no material, no spawning
					}
					
					int16 oneInXChance = 2; // the one in X chance to spawn a fuzzy in a cube
					fuzzyLimit = 200;

					// types are: SINGLE, DOUBLE, TRIPLE_CORNER, TRIPLE_LINE, QUAD_SQUARE, QUAD_T
					//int16 type = IwRandMinMax( SINGLE, TRIPLE_LINE + 1);  // the maximum is NOT inclusive
					int16 type = IwRandMinMax( SINGLE, TRIPLE_LINE + 1);  // the maximum is NOT inclusive

					// if there is one cube left, generate a single cube
					for( int i = 0; i < 6; i++ )
					{
						if( plane[i].color == material ) // finds the active plane
						{
							if( plane[i].count == 8 ) // if there is 1 cube not touching plane, generate single cube for guaranteed warp if done right
							{
								if( plane[i].allowSingleCubeSpawn == true )
								{
									type = SINGLE;

									// allow generating a single cube to fill hole to happen just ONCE. 
									// should be reset when a plane warps
									plane[i].allowSingleCubeSpawn = false;
								}
							}
						}
					}

					//type = TRIPLE_LINE;

					if( material != -1 )
					{
						// the height is in units of side length. Rate is the lowest speed
						SpawnCubesAndShadows( faceSide, height, type, material, 600, oneInXChance );
						numMovingSets++;
						SpawnTime1 = 0; // reset spawn time so there is interval between 2 spawning cubes
					}
					
					isSpawning = false;
				} // end of if( spawn time = 45 )
			} // end of if( not warping && not exploding )
		} // end of if level == 4
		else if( levelNumber == 5 ) 
		{
			// NO EXPLODING CUBES and WARPING check to activate spawn timer
			cubeIsExploding = false;
			cubeIsWarping = false;			
			for( int i = numOriginalCubes; i < numStaticCubes; i++ )
			{
				if( cubeArray[i].exploding == true )
					cubeIsExploding = true;

				if( cubeArray[i].material == Cube::WARPING_MATERIAL )
					cubeIsWarping = true;
			}

			// if there are 3 moving cube sets, do nothing
			if( numMovingSets >= 4 || numMovingSets >= numActivePlanes)
			{
				SpawnTime0 = 0;
				SpawnTime1 = 0;
				// do nothing
			}
			// if there is 1 or less moving cube, wait 2 second and spawn a set randomly on any side
			// only start spawn timer if no cubes are warping and exploding
			else if( cubeIsExploding == false && cubeIsWarping == false )
			{
				SpawnTime0 = SpawnTime1;
				SpawnTime1 += 1;

				if( SpawnTime1 >= 30 ) // if half a second second passed. 30 frames per second, so 15 frames = half second
				{
					// boolean to tell when it starting to spawn
					isSpawning = true;
					completeComplete = false;
					spawningSetCounter = 0;

					// spawn a set of cubes
					IwRandSeed( (int32)s3eTimerGetMs() );

					// FACESIDE 
					int16 faceSide = IwRandMinMax( 1, 6+1 ); // the maximum is NOT inclusive
					if( numActivePlanes == 1 ) // if there is only 1 active plane left, spawn on activefaceside
					{
						faceSide = getActiveFaceSide();
					}
					else // if there are more than 1 plane sides left, use this algorithm
					{
						bool emptySide = true;
						// spawn on faceside that has no cubes there
						do
						{
							faceSide = IwRandMinMax( 1, 6+1 ); // the maximum is NOT inclusive
							emptySide = true;

							for( int i = 0; i < numMovingCubesIndex; i++ )
							{
								if( faceSide == cubeArrayMoving[i].direction )
								{
									emptySide = false;
									break;
								}
							}
						}
						while( emptySide == false );
					}

					int16 height = 18;

					// materials are: SOLID_RED, SOLID_GREEN, SOLID_BLUE, SOLID_YELLOW, SOLID_PURPLE, SOLID_ORANGE
					int16 material = -1;
					// only spawn material if that plane is active
					// keep material if material is one of active plane's color
					bool duplicateMaterial = false;
					bool found = false;
					bool allInactive = true; // helps determine if all planes are active

					// FIND MATERIAL
					// only find material if there are more active sides than there are movingSets in play
					if( numMovingSets < numActivePlanes )
					{
						while( found == false )
						{
							
							// Generate the Material
							// if there are moving cubes in play, only spawn material that is different than those
							// keep looping until the material spawned is not a duplicate
							do							
							{
								
								material = IwRandMinMax( Cube::SOLID_RED, Cube::SOLID_ORANGE+1	);
								
								// check to make sure numMovingCubesIndex is not zero 
								if( numMovingCubesIndex != 0 )
								{
									// loop through current cubes to see if there is duplicate of material
									for( int i = 0; i < numMovingCubesIndex; i++ ) 
									{
										if( cubeArrayMoving[i].color == material ) // if there is a duplicate material. use COLOR
										{
											duplicateMaterial = true;
											break;
										}
										else // if there are no duplicates at end of for-loop, give signal to exit while loop
										{
											duplicateMaterial = false;
										}
									}
								}
								else // if no moving cubes are in play, automatically accept material for further checking
								{
									duplicateMaterial = false;
								}
								
							}
							while( duplicateMaterial == true ); // loop if there is a duplicate material
						
							// checks to see if material is active
							for( int i = 0; i < 6; i++ )
							{
								// checks if the material spawned is "active"
								if( plane[i].active == true && plane[i].color == material )
								{
									// if the material of the plane is active, let it spawn
									found = true;
									break;
								}
								else if( plane[i].active == true ) // checks to tell loop that it is not infinite loop
								{
									// says there cannot be infinite loop
									allInactive = false; // the statement that all sides are inactive is false.
								}

								if( i == 5 && allInactive == true ) // if all planes are inactive at end of iteration, break to prevent infinite loop
								{
									material = -1;
									found = true;
									break;
								}
							}
						} // end of while loop for generating material
					} // end of if numMovingSets <= numActivePlanes
					else
					{
						material = -1; // no material, no spawning
					}
					
					int16 oneInXChance = 2; // the one in X chance to spawn a fuzzy in a cube
					fuzzyLimit = 200;

					// types are: SINGLE, DOUBLE, TRIPLE_CORNER, TRIPLE_LINE, QUAD_SQUARE, QUAD_T
					//int16 type = IwRandMinMax( SINGLE, TRIPLE_LINE + 1);  // the maximum is NOT inclusive
					int16 type = IwRandMinMax( SINGLE, TRIPLE_LINE + 1);  // the maximum is NOT inclusive

					// if there is one cube left, generate a single cube
					for( int i = 0; i < 6; i++ )
					{
						if( plane[i].color == material ) // finds the active plane
						{
							if( plane[i].count == 8 ) // if there is 1 cube not touching plane, generate single cube for guaranteed warp if done right
							{
								if( plane[i].allowSingleCubeSpawn == true )
								{
									type = SINGLE;

									// allow generating a single cube to fill hole to happen just ONCE. 
									// should be reset when a plane warps
									plane[i].allowSingleCubeSpawn = false;
								}
							}
						}
					}

					//type = TRIPLE_LINE;

					if( material != -1 )
					{
						// the height is in units of side length. Rate is the lowest speed
						SpawnCubesAndShadows( faceSide, height, type, material, 400, oneInXChance );
						numMovingSets++;
						SpawnTime1 = 0; // reset spawn time so there is interval between 2 spawning cubes
					}
					
					isSpawning = false;
				} // end of if( spawn time = 45 )
			} // end of if( not warping && not exploding )
		} // end of if level == 5
		*/ 

		/*
		else if( originalmethod )
		{
			// NO EXPLODING CUBES and WARPING check to activate spawn timer
			cubeIsExploding = false;
			cubeIsWarping = false;			
			for( int i = numOriginalCubes; i < numStaticCubes; i++ )
			{
				if( cubeArray[i].exploding == true )
					cubeIsExploding = true;

				if( cubeArray[i].material == Cube::WARPING_MATERIAL )
					cubeIsWarping = true;
			}

			// if there are moving cubes, do nothing
			if( numMovingCubesIndex != 0 )
			{
				SpawnTime0 = 0;
				SpawnTime1 = 0;
				// do nothing
			}
			// if there are no moving cubes, wait 1 second and spawn a set randomly on any side
			// only start spawn timer if no cubes are warping and exploding
			else if( cubeIsExploding == false && cubeIsWarping == false )
			{
				SpawnTime0 = SpawnTime1;
				SpawnTime1 += 1;

				if( SpawnTime1 >= 30 ) // if half a second second passed. 30 frames per second, so 15 frames = half second
				{
					// spawn a set of cubes
					IwRandSeed( (int32)s3eTimerGetMs() );
					int16 faceSide = IwRandMinMax( 1, 6+1 ); // the maximum is NOT inclusive
					int16 height = 18;

					// types are: SINGLE, DOUBLE, TRIPLE_CORNER, TRIPLE_LINE, QUAD_SQUARE, QUAD_T
					//int16 type = IwRandMinMax( SINGLE, TRIPLE_LINE + 1);  // the maximum is NOT inclusive
					int16 type = IwRandMinMax( DOUBLE, TRIPLE_LINE + 1);  // the maximum is NOT inclusive
					//type = TRIPLE_LINE;

					// materials are: SOLID_RED, SOLID_GREEN, SOLID_BLUE, SOLID_YELLOW, SOLID_PURPLE, SOLID_ORANGE
					int16 material = IwRandMinMax( Cube::SOLID_RED, Cube::SOLID_ORANGE+1	);
					// take away green and yellow for facesides 5 and 6
					while( material == Cube::SOLID_GREEN || material == Cube::SOLID_YELLOW )
					{
						material = IwRandMinMax( Cube::SOLID_RED, Cube::SOLID_ORANGE+1	);
					}
					//material = Cube::SOLID_BLUE;

					int16 oneInXChance = 4; // the one in X chance to spawn a fuzzy in a cube
					fuzzyLimit = 200;

					// the height is in units of side length. Rate is the lowest speed
					SpawnCubesAndShadows( faceSide, height, type, material, INITIAL_SPEED, oneInXChance );
				}
			}
		} // end of original method */

	} // end of if Play_Game

	if( GameState == PLAY_TUTORIAL )
	{
		// check number of activeplanes here. Used to make sure only spawn if numMovingSets is less than numActivePlanes
		int16 numActivePlanes = 0;
		for( int i = 0; i < 6; i++ )
		{
			if( plane[i].active == true )
			{
				numActivePlanes++;
			}
		}

		// do NOT spawn cubes for the ROTATE CAMERA part of tutorial
		if( tutorialNumber != 5 ) // no restrictions.
		{
			// NO EXPLODING CUBES and WARPING check to activate spawn timer
			cubeIsExploding = false;
			cubeIsWarping = false;			
			for( int i = numOriginalCubes; i < numStaticCubes; i++ )
			{
				if( cubeArray[i].exploding == true )
					cubeIsExploding = true;

				if( cubeArray[i].material == Cube::WARPING_MATERIAL )
					cubeIsWarping = true;
			}

			// if there are moving cubes, do nothing
			if( numMovingSets != 0 )
			{
				SpawnTime0 = 0;
				SpawnTime1 = 0;
				// do nothing
			}
			// if there are no moving cubes, wait 2 second and spawn a set randomly on any side
			// only start spawn timer if no cubes are warping and exploding
			else if( cubeIsExploding == false && cubeIsWarping == false )
			{
				SpawnTime0 = SpawnTime1;
				SpawnTime1 += 1;

				if( SpawnTime1 >= 30 ) // if half a second second passed. 30 frames per second, so 15 frames = half second
				{
					// boolean to tell when it starting to spawn
					isSpawning = true;
					completeComplete = false;
					spawningSetCounter = 0;

					// spawn a set of cubes
					IwRandSeed( (int32)s3eTimerGetMs() );

					// faceSide spawns on current faceside ?
					int16 faceSide = IwRandMinMax( 1, 6+1 ); // the maximum is NOT inclusive
					//faceSide = getActiveFaceSide();
					
					if( tutorialNumber < 6 )
					{
						faceSide = 1; // always spawn at the FRONT if on tutorial levels 1-5
					}
					else if( tutorialNumber == 6 ) // during the Cube Flipping portion of the tutorial, spawn cubes not on the faceside
					{
						faceSide = 5; // always spawn at the TOP if tutorial on level 6
					}
					else if( tutorialNumber == 7 ) // spawn randomly but not the back side
					{
						while( faceSide == 3 )
						{
							faceSide = IwRandMinMax( 1, 6+1 ); // spawn randomly but NOT at the back side
						}
					}

					int16 height = 18;

					
					// materials are: SOLID_RED, SOLID_GREEN, SOLID_BLUE, SOLID_YELLOW, SOLID_PURPLE, SOLID_ORANGE
					int16 material = -1;
					// only spawn material if that plane is active
					// keep material if material is one of active plane's color
					bool duplicateMaterial = true;
					bool found = false;
					bool allInactive = true; // helps determine if all planes are active
					
					// FIND MATERIAL
					// only find material if there are more active sides than there are movingSets in play
					if( numMovingSets < numActivePlanes )
					{
						
						while( found == false )
						{
							
							// Generate the Material
							// if there are moving cubes in play, only spawn material that is different than those
							// keep looping until the material spawned is not a duplicate
							do							
							{
								
								material = IwRandMinMax( Cube::SOLID_RED, Cube::SOLID_ORANGE+1	);
								
								// check to make sure numMovingCubesIndex is not zero 
								if( numMovingCubesIndex != 0 )
								{
									// loop through current cubes to see if there is duplicate of material
									for( int i = 0; i < numMovingCubesIndex; i++ ) 
									{
										if( cubeArrayMoving[i].color == material ) // if there is a duplicate material. use COLOR to match
										{
											duplicateMaterial = true;
											break;
										}
										else // if there are no duplicates at end of for-loop, give signal to exit while loop
										{
											duplicateMaterial = false;
										}
									}
								}
								else // if no moving cubes are in play, automatically accept material for further checking
								{
									duplicateMaterial = false;
								}
								
							}
							while( duplicateMaterial == true ); // loop if there is a duplicate material
						
							// checks to see if material is active
							for( int i = 0; i < 6; i++ )
							{
								// checks if the material spawned is "active"
								if( plane[i].active == true && plane[i].color == material )
								{
									// if the material of the plane is active, let it spawn
									found = true;
									break;
								}
								else if( plane[i].active == true ) // checks to tell loop that it is not infinite loop
								{
									// says there cannot be infinite loop
									allInactive = false; // the statement that all sides are inactive is false.
								}

								if( i == 5 && allInactive == true ) // if all planes are inactive at end of iteration, break to prevent infinite loop
								{
									material = -1;
									found = true;
									break;
								}
							}
						} // end of while loop for generating material
					} // end of if numMovingSets <= numActivePlanes
					else
					{
						material = -1; // no material, no spawning
					}

					int16 oneInXChance = 2; // the one in X chance to spawn a fuzzy in a cube
					fuzzyLimit = 200;

					// types are: SINGLE, DOUBLE, TRIPLE_CORNER, TRIPLE_LINE, QUAD_SQUARE, QUAD_T
					//int16 type = IwRandMinMax( SINGLE, TRIPLE_LINE + 1);  // the maximum is NOT inclusive
					int16 type = IwRandMinMax( SINGLE, TRIPLE_LINE + 1);  // the maximum is NOT inclusive

					// if there is one cube left, generate a single cube
					for( int i = 0; i < 6; i++ )
					{
						if( plane[i].color == material ) // finds the active plane
						{
							if( plane[i].count == 8 ) // if there is 1 cube not touching plane, generate single cube for guaranteed warp if done right
							{
								if( plane[i].allowSingleCubeSpawn == true )
								{
									type = SINGLE;

									// allow generating a single cube to fill hole to happen just ONCE. 
									// should be reset when a plane warps
									plane[i].allowSingleCubeSpawn = false;
								}
							}
							else if( plane[i].count == 7 ) // helps win faster
							{
								type = DOUBLE;
							}
						}
					}

					// spawn specific types for each tutorial level according to sprite
					if( tutorialNumber == 1 )
					{
						type = SINGLE;
					}
					else if( tutorialNumber == 2 )
					{
						type = TRIPLE_LINE;
					}
					else if( tutorialNumber == 3 )
					{
						type = SINGLE;
					}

					if( material != -1 )
					{
						// the height is in units of side length. Rate is the lowest speed
						SpawnCubesAndShadows( faceSide, height, type, material, INITIAL_SPEED, oneInXChance );
						numMovingSets++;
					}

					isSpawning = false;
				}
			}
		} // end of (true) condition
	} // end of if tutorial level 
} // end of SpawnMovingSets()

// helper method to SpawnMovingSets()
void SpawnCubesAndShadows( int16 faceSide, int16 height, int16 type, int16 material, int16 speed, int16 oneInXChance)
{	
	SpawnMovingCubes( faceSide, type, height * s ); // spawns the cubes for each faceSide
	int16 amount = 0; // amount is the number of cubes that are spawned for each set type
	if( type == SINGLE )
		amount = 1;
	else if( type == DOUBLE )
		amount = 2;
	else if( type == TRIPLE_CORNER || type == TRIPLE_LINE )
		amount = 3;
	else
		amount = 4;
			
	SpawnShadows( faceSide, amount );

	// seed for random fuzzy generation
	IwRandSeed( (int32)s3eTimerGetMs() );

	// used to limit one spawned fuzzy per set
	bool spawnedFuzzy = false;

	// gives cubes their properties and links shadows
	for( int k = numMovingCubesIndex-amount; k < numMovingCubesIndex; k++ ) // gives each cube a unique id for their spawn
	{
		cubeArrayMoving[k].setInitialSpeed( speed ); // initialize their speed
		cubeArrayMoving[k].acceleration = ACCELERATION;
		cubeArrayMoving[k].setID( uniqueID );
		uniqueID++;

		// later initialize color, material, etc.
		//cubeArrayMoving[k].material = RANDOM_MATERIAL;
		cubeArrayMoving[k].material = material;
		cubeArrayMoving[k].color = material % (Cube::ORANGE + 1); // color and material sync, with wrapping. This works b/c enum of material and color are same for the first 6

		// Gives cube fuzzy if it generates it with percent chance
		int16 fuzzyResult = IwRandMinMax(1, oneInXChance+1); // determines if a cube will spawn a fuzzy. 1/3 chance

		// spawning a bomb takes priority over fuzzy
		if( spawnBomb == true )
		{
			if( bombType == FBOMB )
			{
				// Use spawning fuzzy requirement to make a bomb in one of randomly generated cubes
				if( ( fuzzyResult == 1 && spawnedFuzzy == false ) || spawnedFuzzy == false && k == numMovingCubesIndex - 1) // if 1 is generated from random number, a fuzzy will be in cube. also, spawn just one fuzzy. old additional req: fuzzyCount != fuzzyLimit
															// or if no fuzzy was spawned and it is last cube without fuzzy, give it a fuzzy
				{
					// Create bombs
					spawnedFuzzy = true;
					cubeArrayMoving[k].hasBomb = true;

					// for some reason putting these here prevents null pointer from happening after they get deleted
					//cubeArrayMoving[k].fuzzyMaterial = fuzzyMaterial[ IwRandMinMax( 0, 1 + 1 ) ];
					//cubeArrayMoving[k].fuzzyExplodeMaterial = fuzzyExplodeMaterial[ IwRandMinMax( 0, 0 + 1 ) ];

					// Initialize bombs
					cubeArrayMoving[k].bomb.Initialize(s);

				
					// Set bomb material
					// tried to copy materials to give them their own animation times, but may be easier to make diff animations for desyncing
					for( int b = 0; b < 3; b++ )
					{
						cubeArrayMoving[k].bomb.material[b] = new CIwMaterial;
						cubeArrayMoving[k].bomb.material[b]->Copy( bombMaterial[b] );
						cubeArrayMoving[k].bomb.material[b]->SetTexture( bombMaterial[b]->GetTexture() );

						cubeArrayMoving[k].bomb.material[b]->CreateAnim();
						cubeArrayMoving[k].bomb.material[b]->SetAnimCelW( 64 );
						cubeArrayMoving[k].bomb.material[b]->SetAnimCelH( 64 );
						cubeArrayMoving[k].bomb.material[b]->SetAnimCelPeriod( 1 );
						cubeArrayMoving[k].bomb.material[b]->SetAnimCelNum( 30 );

						// the third bomb material has 32 frames instead of 30
						if( b == 2 )
						{
							cubeArrayMoving[k].bomb.material[b]->SetAnimCelNum( 32 );
						}

						cubeArrayMoving[k].bomb.material[b]->SetColAmbient( 255, 255, 255, 255 );
						cubeArrayMoving[k].bomb.material[b]->SetColDiffuse( 255, 255, 255, 255 );	
					}

					// set bomb Defuse Material
					cubeArrayMoving[k].bomb.defuseMaterial = new CIwMaterial;
					cubeArrayMoving[k].bomb.defuseMaterial->Copy( bombDefuseMaterial );
					cubeArrayMoving[k].bomb.defuseMaterial->SetTexture( bombDefuseMaterial->GetTexture() );

					// Set bomb explodingMaterial
					cubeArrayMoving[k].bomb.explodeMaterial = new CIwMaterial;
					cubeArrayMoving[k].bomb.explodeMaterial->Copy( bombExplodeMaterial );
					cubeArrayMoving[k].bomb.explodeMaterial->SetTexture( bombExplodeMaterial->GetTexture() );

					// set the material as the transparent counterpart color
					cubeArrayMoving[k].material += 6;

					// set bomb spawning to false if one bomb has spawned.
					spawnBomb = false;
				} // end of spawning an Fbomb condition
			} // end of if bombType == FBOMB
			else if( bombType == WTFBOMB )
			{
				// WTF bombs spawn in every cube in the set, so there are no restrictions, unlike f-bombs

				// Create bombs
				cubeArrayMoving[k].hasBomb = true;

				// for some reason putting these here prevents null pointer from happening after they get deleted
				//cubeArrayMoving[k].fuzzyMaterial = fuzzyMaterial[ IwRandMinMax( 0, 1 + 1 ) ];
				//cubeArrayMoving[k].fuzzyExplodeMaterial = fuzzyExplodeMaterial[ IwRandMinMax( 0, 0 + 1 ) ];

				// Initialize bombs
				cubeArrayMoving[k].bomb.Initialize(s);

				
				// Set bomb material
				// tried to copy materials to give them their own animation times, but may be easier to make diff animations for desyncing
				for( int b = 0; b < 3; b++ )
				{
					cubeArrayMoving[k].bomb.material[b] = new CIwMaterial;
					cubeArrayMoving[k].bomb.material[b]->Copy( bombMaterial[b+3] );
					cubeArrayMoving[k].bomb.material[b]->SetTexture( bombMaterial[b+3]->GetTexture() );

					cubeArrayMoving[k].bomb.material[b]->CreateAnim();
					cubeArrayMoving[k].bomb.material[b]->SetAnimCelW( 64 );
					cubeArrayMoving[k].bomb.material[b]->SetAnimCelH( 64 );
					cubeArrayMoving[k].bomb.material[b]->SetAnimCelPeriod( 1 );
					cubeArrayMoving[k].bomb.material[b]->SetAnimCelNum( 30 );

					// the third bomb material has 32 frames instead of 30
					if( b == 2 )
					{
						cubeArrayMoving[k].bomb.material[b]->SetAnimCelNum( 32 );
					}

					cubeArrayMoving[k].bomb.material[b]->SetColAmbient( 255, 255, 255, 255 );
					cubeArrayMoving[k].bomb.material[b]->SetColDiffuse( 255, 255, 255, 255 );	
				}

				// set bomb Defuse Material
				cubeArrayMoving[k].bomb.defuseMaterial = new CIwMaterial;
				cubeArrayMoving[k].bomb.defuseMaterial->Copy( bombDefuseMaterial );
				cubeArrayMoving[k].bomb.defuseMaterial->SetTexture( bombDefuseMaterial->GetTexture() );

				// Set bomb explodingMaterial
				cubeArrayMoving[k].bomb.explodeMaterial = new CIwMaterial;
				cubeArrayMoving[k].bomb.explodeMaterial->Copy( bombExplodeMaterial );
				cubeArrayMoving[k].bomb.explodeMaterial->SetTexture( bombExplodeMaterial->GetTexture() );

				// set the material as the transparent counterpart color
				cubeArrayMoving[k].material += 6;

				// if this was the last cube in the set of cubes, stop the bomb spawning
				if( k == numMovingCubesIndex - 1 )
				{
					spawnBomb = false;
				}
			} // end of if bombType == WTFBOMB
		}
		// Spawn a fuzzy
		else if( ( fuzzyResult == 1 && spawnedFuzzy == false ) || spawnedFuzzy == false && k == numMovingCubesIndex - 1) // if 1 is generated from random number, a fuzzy will be in cube. also, spawn just one fuzzy. old additional req: fuzzyCount != fuzzyLimit
														// or if no fuzzy was spawned and it is last cube without fuzzy, give it a fuzzy
		{
			spawnedFuzzy = true;
			cubeArrayMoving[k].hasFuzzy = true;

			// pick fuzzy material
			int16 rand = IwRandMinMax( 0, 2 + 1 );

			if( episode == 1 )
			{
				rand = 0;
			}
			else if( episode == 2 )
			{
				rand = 1;
			}
			else if( episode == 3 )
			{
				rand = 2;
			}
			else if( episode == 4 )
			{
				rand = IwRandMinMax( 0, 2 + 1 );
			}

			// set fuzzy materials

			// for some reason putting these here prevents null pointer from happening after they get deleted
			//cubeArrayMoving[k].fuzzyMaterial = fuzzyMaterial[ IwRandMinMax( 0, 1 + 1 ) ];
			//cubeArrayMoving[k].fuzzyExplodeMaterial = fuzzyExplodeMaterial[ IwRandMinMax( 0, 0 + 1 ) ];
			cubeArrayMoving[k].fuzzyExplodeMaterial = new CIwMaterial;
			cubeArrayMoving[k].fuzzyExplodeMaterial->Copy( fuzzyExplodeMaterial[0] );
			cubeArrayMoving[k].fuzzyExplodeMaterial->SetTexture( fuzzyExplodeMaterial[0]->GetTexture() );

			// tried to copy materials to give them their own animation times, but may be easier to make diff animations for desyncing
			cubeArrayMoving[k].fuzzyMaterial = new CIwMaterial;	
			cubeArrayMoving[k].fuzzyMaterial->Copy( fuzzyMaterial[ rand ]);	
			cubeArrayMoving[k].fuzzyMaterial->SetTexture( fuzzyMaterial[rand]->GetTexture() );

			// create fuzzy animation

			cubeArrayMoving[k].fuzzyMaterial->CreateAnim();
			cubeArrayMoving[k].fuzzyMaterial->SetAnimCelW( 64 );
			cubeArrayMoving[k].fuzzyMaterial->SetAnimCelH( 64 );
			cubeArrayMoving[k].fuzzyMaterial->SetAnimCelPeriod( 1 );
			cubeArrayMoving[k].fuzzyMaterial->SetAnimCelNum( 64 );

			cubeArrayMoving[k].fuzzyMaterial->SetColAmbient( 255, 255, 255, 255 );
			cubeArrayMoving[k].fuzzyMaterial->SetColDiffuse( 255, 255, 255, 255 );	
			cubeArrayMoving[k].fuzzyMaterial->SetAlphaMode( alphaValue_fuzzyMaterial );

			
			
			// set the material as the transparent counterpart color
			cubeArrayMoving[k].material += 6;

			fuzzyCount++;
		}

		// link to shadows
		LinkShadowToCube( k );
	}

	// create the shadow group
	ShadowGroup *shadowGroupPointer = new ShadowGroup(0);

	// Cycles through every shadow created, and Link shadows together with group
	for( int l = numShadowsIndex - amount; l < numShadowsIndex; l++ )
	{
		shadowArray[l].shadowGroup = shadowGroupPointer; // assign shadow group to each shadow

		// if on first iteration, set all the bounds
		if( l == numShadowsIndex - amount )
		{
			shadowGroupPointer->direction = shadowArray[l].direction; // sets the direction
			switch( shadowGroupPointer->direction )
			{
			case 1:
				shadowGroupPointer->topBound = shadowArray[l].position.y;
				shadowGroupPointer->bottomBound = shadowArray[l].position.y;
				shadowGroupPointer->leftBound = shadowArray[l].position.x;
				shadowGroupPointer->rightBound = shadowArray[l].position.x;
				break;
			case 2:
				shadowGroupPointer->topBound = shadowArray[l].position.y;
				shadowGroupPointer->bottomBound = shadowArray[l].position.y;
				shadowGroupPointer->leftBound = shadowArray[l].position.z;
				shadowGroupPointer->rightBound = shadowArray[l].position.z;
				break;
			case 3:
				shadowGroupPointer->topBound = shadowArray[l].position.y;
				shadowGroupPointer->bottomBound = shadowArray[l].position.y;
				shadowGroupPointer->leftBound = shadowArray[l].position.x;
				shadowGroupPointer->rightBound = shadowArray[l].position.x;
				break;
			case 4:
				shadowGroupPointer->topBound = shadowArray[l].position.y;
				shadowGroupPointer->bottomBound = shadowArray[l].position.y;
				shadowGroupPointer->leftBound = shadowArray[l].position.z;
				shadowGroupPointer->rightBound = shadowArray[l].position.z;
				break;
			case 5:
				shadowGroupPointer->topBound = shadowArray[l].position.z;
				shadowGroupPointer->bottomBound = shadowArray[l].position.z;
				shadowGroupPointer->leftBound = shadowArray[l].position.x;
				shadowGroupPointer->rightBound = shadowArray[l].position.x;
				break;
			case 6:
				shadowGroupPointer->topBound = shadowArray[l].position.z;
				shadowGroupPointer->bottomBound = shadowArray[l].position.z;
				shadowGroupPointer->leftBound = shadowArray[l].position.x;
				shadowGroupPointer->rightBound = shadowArray[l].position.x;
				break;
			}
		}
		else // if on the other iterations, do comparison to find the bounds
		{
			switch( shadowGroupPointer->direction )
			{
			case 1:
				if( shadowArray[l].position.y < shadowGroupPointer->topBound )
					shadowGroupPointer->topBound = shadowArray[l].position.y;
				if( shadowArray[l].position.y > shadowGroupPointer->bottomBound)
					shadowGroupPointer->bottomBound = shadowArray[l].position.y;
				if( shadowArray[l].position.x < shadowGroupPointer->leftBound )
					shadowGroupPointer->leftBound = shadowArray[l].position.x;
				if( shadowArray[l].position.x > shadowGroupPointer->rightBound )
					shadowGroupPointer->rightBound = shadowArray[l].position.x;
				break;
			case 2:
				if( shadowArray[l].position.y < shadowGroupPointer->topBound )
					shadowGroupPointer->topBound = shadowArray[l].position.y;
				if( shadowArray[l].position.y > shadowGroupPointer->bottomBound )
					shadowGroupPointer->bottomBound = shadowArray[l].position.y;
				if( shadowArray[l].position.z < shadowGroupPointer->leftBound )
					shadowGroupPointer->leftBound = shadowArray[l].position.z;
				if( shadowArray[l].position.z > shadowGroupPointer->rightBound )
					shadowGroupPointer->rightBound = shadowArray[l].position.z;
				break;
			case 3:
				if( shadowArray[l].position.y < shadowGroupPointer->topBound )
					shadowGroupPointer->topBound = shadowArray[l].position.y;
				if( shadowArray[l].position.y > shadowGroupPointer->bottomBound )
					shadowGroupPointer->bottomBound = shadowArray[l].position.y;
				if( shadowArray[l].position.x > shadowGroupPointer->leftBound )
					shadowGroupPointer->leftBound = shadowArray[l].position.x;
				if( shadowArray[l].position.x < shadowGroupPointer->rightBound )
					shadowGroupPointer->rightBound = shadowArray[l].position.x;
				break;
			case 4:
				if( shadowArray[l].position.y < shadowGroupPointer->topBound )
					shadowGroupPointer->topBound = shadowArray[l].position.y;
				if( shadowArray[l].position.y > shadowGroupPointer->bottomBound )
					shadowGroupPointer->bottomBound = shadowArray[l].position.y;
				if( shadowArray[l].position.z > shadowGroupPointer->leftBound )
					shadowGroupPointer->leftBound = shadowArray[l].position.z;
				if( shadowArray[l].position.z < shadowGroupPointer->rightBound )
					shadowGroupPointer->rightBound = shadowArray[l].position.z;
				break;
			case 5:
				if( shadowArray[l].position.z > shadowGroupPointer->topBound )
					shadowGroupPointer->topBound = shadowArray[l].position.z;
				if( shadowArray[l].position.z < shadowGroupPointer->bottomBound )
					shadowGroupPointer->bottomBound = shadowArray[l].position.z;
				if( shadowArray[l].position.x < shadowGroupPointer->leftBound )
					shadowGroupPointer->leftBound = shadowArray[l].position.x;
				if( shadowArray[l].position.x > shadowGroupPointer->rightBound )
					shadowGroupPointer->rightBound = shadowArray[l].position.x;
				break;
			case 6:
				if( shadowArray[l].position.z < shadowGroupPointer->topBound )
					shadowGroupPointer->topBound = shadowArray[l].position.z;
				if( shadowArray[l].position.z > shadowGroupPointer->bottomBound )
					shadowGroupPointer->bottomBound = shadowArray[l].position.z;
				if( shadowArray[l].position.x < shadowGroupPointer->leftBound )
					shadowGroupPointer->leftBound = shadowArray[l].position.x;
				if( shadowArray[l].position.x > shadowGroupPointer->rightBound )
					shadowGroupPointer->rightBound = shadowArray[l].position.x;
				break;
			}
		} // end of if-statement for checking either first shadow or successive shadows
	} // end of for loop linking shadows with a group		
}

// shakes the camera on impact of landing cubes
void ShakeCamera()
{
	int16 shakeIncrement = 20;
	// shake path has 10 points
	/*
	CIwSVec2 shakePath1[6] =
	{
		CIwSVec2( -2*shakeIncrement, -5*shakeIncrement ),
		CIwSVec2( 2*shakeIncrement, 4*shakeIncrement ),
		CIwSVec2( 1*shakeIncrement, 0*shakeIncrement ),
		CIwSVec2( -3*shakeIncrement, 3*shakeIncrement ),
		CIwSVec2( 1*shakeIncrement, -1*shakeIncrement ),
		CIwSVec2( 0, 0 ),
	};
	*/
	CIwSVec2 shakePath1[10] =
	{
		CIwSVec2( -2*shakeIncrement, -5*shakeIncrement ),
		CIwSVec2( 2*shakeIncrement, 4*shakeIncrement ),
		CIwSVec2( 3*shakeIncrement, -4*shakeIncrement ),
		CIwSVec2( -3*shakeIncrement, 3*shakeIncrement ),
		CIwSVec2( 2*shakeIncrement, 2*shakeIncrement ),
		CIwSVec2( -1*shakeIncrement, -2*shakeIncrement ),
		CIwSVec2( 1*shakeIncrement, 0*shakeIncrement ),
		CIwSVec2( 1*shakeIncrement, -1*shakeIncrement ),
		CIwSVec2( -1*shakeIncrement, 1*shakeIncrement ),
		CIwSVec2( 0, 0 ),
	};
	

	// translate the camera position by shake path
	view.t.x = shakePath1[shakeCounter].x;
	view.t.y = shakePath1[shakeCounter].y;

	shakeCounter++;

	if( shakeCounter == 10 )
	{
		shakeCamera = false;
		shakeCounter = 0;
	}
}

void ShakeCameraMedium()
{
	int16 shakeIncrement = 500;
	// shake path has 10 points
	/*
	CIwSVec2 shakePath1[6] =
	{
		CIwSVec2( -2*shakeIncrement, -5*shakeIncrement ),
		CIwSVec2( 2*shakeIncrement, 4*shakeIncrement ),
		CIwSVec2( 1*shakeIncrement, 0*shakeIncrement ),
		CIwSVec2( -3*shakeIncrement, 3*shakeIncrement ),
		CIwSVec2( 1*shakeIncrement, -1*shakeIncrement ),
		CIwSVec2( 0, 0 ),
	};
	*/
	CIwSVec2 shakePath1[20] =
	{
		CIwSVec2( -2*shakeIncrement, -5*shakeIncrement ),
		CIwSVec2( 2*shakeIncrement, 4*shakeIncrement ),
		CIwSVec2( 3*shakeIncrement, -4*shakeIncrement ),
		CIwSVec2( -3*shakeIncrement, 3*shakeIncrement ),
		CIwSVec2( 2*shakeIncrement, 2*shakeIncrement ),
		CIwSVec2( -1*shakeIncrement, -2*shakeIncrement ),
		CIwSVec2( 1*shakeIncrement, 0*shakeIncrement ),
		CIwSVec2( 1*shakeIncrement, -1*shakeIncrement ),
		CIwSVec2( -1*shakeIncrement, 1*shakeIncrement ),
		CIwSVec2( -2*shakeIncrement, -5*shakeIncrement ),
		CIwSVec2( 2*shakeIncrement, 4*shakeIncrement ),
		CIwSVec2( 3*shakeIncrement, -4*shakeIncrement ),
		CIwSVec2( -3*shakeIncrement, 3*shakeIncrement ),
		CIwSVec2( 2*shakeIncrement, 2*shakeIncrement ),
		CIwSVec2( -1*shakeIncrement, -2*shakeIncrement ),
		CIwSVec2( 1*shakeIncrement, 0*shakeIncrement ),
		CIwSVec2( 1*shakeIncrement, -1*shakeIncrement ),
		CIwSVec2( -1*shakeIncrement, 1*shakeIncrement ),
		CIwSVec2( -1*shakeIncrement, -1*shakeIncrement ),
		CIwSVec2( 0, 0 ),
	};
	

	// translate the camera position by shake path
	view.t.x = shakePath1[shakeCounterMedium].x;
	view.t.y = shakePath1[shakeCounterMedium].y;

	shakeCounterMedium++;

	if( shakeCounterMedium == 20 )
	{
		shakeCameraMedium = false;
		shakeCounterMedium = 0;
		// no need to reset planes after explosion. plane count auto decreases.
	}
}

void ShakeCameraGigantic()
{
	/* do not use
	// flurry log death
	if( gameOver == false ) // ensures death is only logged once
	{
		if( hasFlurry )
		{
			char cstring[50] = "Died on episode ";
			strcat( cstring, levelToCstring( episode, levelNumber ) );
			s3eFlurryLogEvent( cstring, false );

			char cstring2[50] = "Died on episode ";
			strcat( cstring2, levelToCstring( episode, levelNumber ) );
			strcat( cstring2, " by: high-stack" );
			s3eFlurryLogEvent( cstring2, false );

			s3eFlurryEndTimedEvent( timedEvent );
		}
	}
	*/

	// sets state for gameover
	transition = true;
	transitionIsSet = false;
	TargetState = AT_SCORE_SCREEN;
	gameOver = true;

	if( episode == 3 && (levelNumber >= 7 && levelNumber <= 9 ) )
	{
		transition = true;
		transitionIsSet = false;
		TargetState = PLAY_CINEMATIC; // go to cut scene first before score screen

		gameOver = true;
	}


	int16 shakeIncrement = 2000;
	// shake path has 10 points
	/*
	CIwSVec2 shakePath1[6] =
	{
		CIwSVec2( -2*shakeIncrement, -5*shakeIncrement ),
		CIwSVec2( 2*shakeIncrement, 4*shakeIncrement ),
		CIwSVec2( 1*shakeIncrement, 0*shakeIncrement ),
		CIwSVec2( -3*shakeIncrement, 3*shakeIncrement ),
		CIwSVec2( 1*shakeIncrement, -1*shakeIncrement ),
		CIwSVec2( 0, 0 ),
	};
	*/
	CIwSVec2 shakePath1[20] =
	{
		CIwSVec2( -2*shakeIncrement, -5*shakeIncrement ),
		CIwSVec2( 2*shakeIncrement, 4*shakeIncrement ),
		CIwSVec2( 3*shakeIncrement, -4*shakeIncrement ),
		CIwSVec2( -3*shakeIncrement, 3*shakeIncrement ),
		CIwSVec2( 2*shakeIncrement, 2*shakeIncrement ),
		CIwSVec2( -1*shakeIncrement, -2*shakeIncrement ),
		CIwSVec2( 1*shakeIncrement, 0*shakeIncrement ),
		CIwSVec2( 1*shakeIncrement, -1*shakeIncrement ),
		CIwSVec2( -1*shakeIncrement, 1*shakeIncrement ),
		CIwSVec2( -2*shakeIncrement, -5*shakeIncrement ),
		CIwSVec2( 2*shakeIncrement, 4*shakeIncrement ),
		CIwSVec2( 3*shakeIncrement, -4*shakeIncrement ),
		CIwSVec2( -3*shakeIncrement, 3*shakeIncrement ),
		CIwSVec2( 2*shakeIncrement, 2*shakeIncrement ),
		CIwSVec2( -1*shakeIncrement, -2*shakeIncrement ),
		CIwSVec2( 1*shakeIncrement, 0*shakeIncrement ),
		CIwSVec2( 1*shakeIncrement, -1*shakeIncrement ),
		CIwSVec2( -1*shakeIncrement, 1*shakeIncrement ),
		CIwSVec2( -2*shakeIncrement, -5*shakeIncrement ),
		CIwSVec2( 0, 0 ),
	};
	

	// translate the camera position by shake path
	view.t.x = shakePath1[shakeCounterGigantic].x;
	view.t.y = shakePath1[shakeCounterGigantic].y;

	shakeCounterGigantic++;

	if( shakeCounterGigantic == 20 )
	{
		shakeCameraGigantic = false;
		shakeCounterGigantic = 0;
		// no need to reset planes after explosion. plane count auto decreases.
		resetPlaneCount = true;
	}
}

// not used. not as easy, b/c you need interpolation for smoothness
void SwayCamera()
{
	int16 swayIncrement = 20;
	// shake path has 10 points
	CIwSVec2 swayPath[6] =
	{
		CIwSVec2( -2*swayIncrement, -5*swayIncrement ),
		CIwSVec2( 2*swayIncrement, 4*swayIncrement ),
		CIwSVec2( 1*swayIncrement, 0*swayIncrement ),
		CIwSVec2( -3*swayIncrement, 3*swayIncrement ),
		CIwSVec2( 1*swayIncrement, -1*swayIncrement ),
		CIwSVec2( 0, 0 ),
	};
	/*
	CIwSVec2 shakePath1[10] =
	{
		CIwSVec2( -2*shakeIncrement, -5*shakeIncrement ),
		CIwSVec2( 2*shakeIncrement, 4*shakeIncrement ),
		CIwSVec2( 3*shakeIncrement, -4*shakeIncrement ),
		CIwSVec2( -3*shakeIncrement, 3*shakeIncrement ),
		CIwSVec2( 2*shakeIncrement, 2*shakeIncrement ),
		CIwSVec2( -1*shakeIncrement, -2*shakeIncrement ),
		CIwSVec2( 1*shakeIncrement, 0*shakeIncrement ),
		CIwSVec2( 1*shakeIncrement, -1*shakeIncrement ),
		CIwSVec2( -1*shakeIncrement, 1*shakeIncrement ),
		CIwSVec2( 0, 0 ),
	};
	*/

	// translate the camera position by shake path
	view.t.x = swayPath[swayCounter].x;
	view.t.y = swayPath[swayCounter].y;

	swayCounter++;

	if( swayCounter == 6 )
	{
		swayCamera = false;
		swayCounter = 0;
	}
}

// autosnapping camera when rotation is let go
void AutoSnap()
{
	/*
	if( getActiveFaceSide() == 1 )
		SnapToFaceSide1();
	else if( getActiveFaceSide() == 2 )
		SnapToFaceSide2();
	else if( getActiveFaceSide() == 3 )
		SnapToFaceSide3();
	else if( getActiveFaceSide() == 4 )
		SnapToFaceSide4();
	else if( getActiveFaceSide() == 5 )
		SnapToFaceSide5();
	else if( getActiveFaceSide() == 6 )
		SnapToFaceSide6();
		*/
	if( getActiveFaceSide() == 1 )
		SnapToFaceSide1();
	if( getActiveFaceSide() == 2 )
		SnapToFaceSide2();
	if( getActiveFaceSide() == 3 )
		SnapToFaceSide3();
	if( getActiveFaceSide() == 4 )
		SnapToFaceSide4();
	if( getActiveFaceSide() == 5 )
		SnapToFaceSide5();
	if( getActiveFaceSide() == 6 )
		SnapToFaceSide6();
	//SwipeToFaceSide1();

}

void ResetAutoSnapVariables()
{
	autosnap = false;
	autosnap_finishedX = false;
	autosnap_firstIterationFinishedX = false;
	autosnap_finishedY = false;		
	autosnap_firstIterationFinishedY = false;
}

void SnapToFaceSide1()
{
	// turn worldX from < -3584 to <-512 
	if( worldX < -3584 )
	{
		worldX += 4096;
	}

	// turn worldX from > 3584 to > 512
	if( worldX > 3584 )
	{
		worldX -= 4096;
	}

	if( reversedIndex == 1 )
	{
		if( worldX <= 512 && worldX >= -512 )
		{
			// autosnap Y-axis to faceside 1, left and right
			if( worldX == 0 ) // if finished autosnapping, turn off, do nothing
			{
				autosnap_finishedY = true;
				savedX = worldX / rotateSensitivityMultiplier;		
			}
			else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
			{
				if( worldX > 0 )
				{
					autosnap_subtractingY = true;
				}
				else
				{
					autosnap_subtractingY = false;
				}

				autosnap_firstIterationFinishedY = true;
			}
			else if( autosnap_subtractingY == true ) // subtracting from positive
			{
				if( worldX > 0 + 256 ) // creates deceleration 
				{
					worldX -= autosnap_firstSnapIncrement;
				}
				else if( worldX > 0 + 128 )
				{
					worldX -= autosnap_secondSnapIncrement;
				}
				else
				{
					worldX -= autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX <= 0 )
					worldX = 0;
			}
			else if( autosnap_subtractingY == false ) // adding to negative
			{		
				if( worldX < 0 - 256 ) // creates deceleration
				{
					worldX += autosnap_firstSnapIncrement;
				}
				else if( worldX < 0 - 128 )
				{
					worldX += autosnap_secondSnapIncrement;
				}
				else
				{
					worldX += autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX >= 0 )
					worldX = 0;
			}
		}
	}
	else if( reversedIndex == -1 )
	{
		// autosnap Y-axis to faceside 1, left and right
		if( worldX <= 2560 && worldX >= 1560 ) // if finished autosnapping, turn off, do nothing
		{
			if( worldX == 2048 )
			{
				autosnap_finishedY = true;
				savedX = worldX / rotateSensitivityMultiplier;		
			}
			else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
			{
				if( worldX > 2048 )
				{
					autosnap_subtractingY = true;
				}
				else
				{
					autosnap_subtractingY = false;
				}

				autosnap_firstIterationFinishedY = true;
			}
			else if( autosnap_subtractingY == true ) // subtracting from positive
			{
				if( worldX > 2048 + 256 ) // creates deceleration 
				{
					worldX -= autosnap_firstSnapIncrement;
				}
				else if( worldX > 2048 + 128 )
				{
					worldX -= autosnap_secondSnapIncrement;
				}
				else
				{
					worldX -= autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX <= 2048 )
					worldX = 2048;
			}
			else if( autosnap_subtractingY == false ) // adding to negative
			{		
				if( worldX < 2048 - 256 ) // creates deceleration
				{
					worldX += autosnap_firstSnapIncrement;
				}
				else if( worldX < 2048 - 128 )
				{
					worldX += autosnap_secondSnapIncrement;
				}
				else
				{
					worldX += autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX >= 2048 )
					worldX = 2048;
			}
		}		
		else if( worldX <= -1560 && worldX >= -2560 ) // if finished autosnapping, turn off, do nothing
		{
			if( worldX == -2048 )
			{
				autosnap_finishedY = true;
				savedX = worldX / rotateSensitivityMultiplier;		
			}
			else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
			{
				if( worldX > -2048 )
				{
					autosnap_subtractingY = true;
				}
				else
				{
					autosnap_subtractingY = false;
				}

				autosnap_firstIterationFinishedY = true;
			}
			else if( autosnap_subtractingY == true ) // subtracting from positive
			{
				if( worldX > -2048 + 256 ) // creates deceleration 
				{
					worldX -= autosnap_firstSnapIncrement;
				}
				else if( worldX > -2048 + 128 )
				{
					worldX -= autosnap_secondSnapIncrement;
				}
				else
				{
					worldX -= autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX <= -2048 )
					worldX = -2048;
			}
			else if( autosnap_subtractingY == false ) // adding to negative
			{		
				if( worldX < -2048 - 256 ) // creates deceleration
				{
					worldX += autosnap_firstSnapIncrement;
				}
				else if( worldX < -2048 - 128 )
				{
					worldX += autosnap_secondSnapIncrement;
				}
				else
				{
					worldX += autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX >= -2048 )
					worldX = 2048;
			}
		}
	}

	// turn worldY from < -3584 to <-512 
	if( worldY < -3584 )
	{
		worldY += 4096;
	}

	// turn worldY from > 3584 to > 512
	if( worldY > 3584 )
	{
		worldY -= 4096;
	}

	if( worldY <= 512 && worldY >= -512 )
	{
		// autosnap X-axis to faceside 1, up and down
		if( worldY == 0 ) // if finished autosnapping, turn off, do nothing
		{
			autosnap_finishedX = true;		
			savedY = worldY / rotateSensitivityMultiplier;		
		}
		else if( autosnap_firstIterationFinishedX == false ) // this is executed on first iteration
		{
			if( worldY > 0 )
			{
				autosnap_subtractingX = true;
			}
			else
			{
				autosnap_subtractingX = false;
			}

			autosnap_firstIterationFinishedX = true;
		}
		else if( autosnap_subtractingX == true ) // subtracting from positive
		{
			if( worldY > 0 + 256 ) // creates deceleration 
			{
				worldY -= autosnap_firstSnapIncrement;
			}
			else if( worldY > 0 + 128 )
			{
				worldY -= autosnap_secondSnapIncrement;
			}
			else
			{
				worldY -= autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY <= 0 )
				worldY = 0;
		}
		else if( autosnap_subtractingX == false ) // adding to negative
		{		
			if( worldY < 0 - 256 ) // creates deceleration
			{
				worldY += autosnap_firstSnapIncrement;
			}
			else if( worldY < 0 - 128 )
			{
				worldY += autosnap_secondSnapIncrement;
			}
			else
			{
				worldY += autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY >= 0 )
				worldY = 0;
		}
	}
	else if( worldY <= -1536 && worldY >= -2560 )
	{
		// autosnap X-axis to faceside 1, up and down
		if( worldY == -2048 ) // if finished autosnapping, turn off, do nothing
		{
			autosnap_finishedX = true;		
			savedY = worldY / rotateSensitivityMultiplier;		
		}
		else if( autosnap_firstIterationFinishedX == false ) // this is executed on first iteration
		{
			if( worldY > -2048 )
			{
				autosnap_subtractingX = true;
			}
			else
			{
				autosnap_subtractingX = false;
			}

			autosnap_firstIterationFinishedX = true;
		}
		else if( autosnap_subtractingX == true ) // subtracting from positive
		{
			if( worldY > -2048 + 256 ) // creates deceleration 
			{
				worldY -= autosnap_firstSnapIncrement;
			}
			else if( worldY > -2048 + 128 )
			{
				worldY -= autosnap_secondSnapIncrement;
			}
			else
			{
				worldY -= autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY <= -2048 )
				worldY = -2048;
		}
		else if( autosnap_subtractingX == false ) // adding to negative
		{		
			if( worldY < -2048 - 256 ) // creates deceleration
			{
				worldY += autosnap_firstSnapIncrement;
			}
			else if( worldY < -2048 - 128 )
			{
				worldY += autosnap_secondSnapIncrement;
			}
			else
			{
				worldY += autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY >= -2048 )
				worldY = -2048;
		}
	}
	else if( worldY <= 2560 && worldY >= 1536 )
	{
		// autosnap X-axis to faceside 1, up and down
		if( worldY == 2048 ) // if finished autosnapping, turn off, do nothing
		{
			autosnap_finishedX = true;		
			savedY = worldY / rotateSensitivityMultiplier;		
		}
		else if( autosnap_firstIterationFinishedX == false ) // this is executed on first iteration
		{
			if( worldY > 2048 )
			{
				autosnap_subtractingX = true;
			}
			else
			{
				autosnap_subtractingX = false;
			}

			autosnap_firstIterationFinishedX = true;
		}
		else if( autosnap_subtractingX == true ) // subtracting from positive
		{
			if( worldY > 2048 + 256 ) // creates deceleration 
			{
				worldY -= autosnap_firstSnapIncrement;
			}
			else if( worldY > 2048 + 128 )
			{
				worldY -= autosnap_secondSnapIncrement;
			}
			else
			{
				worldY -= autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY <= 2048 )
				worldY = 2048;
		}
		else if( autosnap_subtractingX == false ) // adding to negative
		{		
			if( worldY < 2048 - 256 ) // creates deceleration
			{
				worldY += autosnap_firstSnapIncrement;
			}
			else if( worldY < 2048 - 128 )
			{
				worldY += autosnap_secondSnapIncrement;
			}
			else
			{
				worldY += autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY >= 2048 )
				worldY = 2048;
		}
	}

	// Reversed Index Correction
	CorrectReversedIndex();

	// reset variables when both axis are finished aligning to stop looping
	if( autosnap_finishedX == true && autosnap_finishedY == true ) // only disable autosnap looping when both x and y axes finish
	{
		ResetAutoSnapVariables();
	}
}

void SnapToFaceSide2()
{
	// turn worldX from < -3584 to <-512 
	if( worldX < -3584 )
	{
		worldX += 4096;
	}

	// turn worldX from > 3584 to > 512
	if( worldX > 3584 )
	{
		worldX -= 4096;
	}

	if( reversedIndex == 1 )
	{
		if( worldX <= -512 && worldX >= -1536 )
		{
			// autosnap Y-axis to faceside 1, left and right
			if( worldX == -1024 ) // if finished autosnapping, turn off, do nothing
			{
				autosnap_finishedY = true;
				savedX = worldX / rotateSensitivityMultiplier;		
			}
			else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
			{
				if( worldX > -1024 )
				{
					autosnap_subtractingY = true;
				}
				else
				{
					autosnap_subtractingY = false;
				}

				autosnap_firstIterationFinishedY = true;
			}
			else if( autosnap_subtractingY == true ) // subtracting from positive
			{
				if( worldX > -1024 + 256 ) // creates deceleration 
				{
					worldX -= autosnap_firstSnapIncrement;
				}
				else if( worldX > -1024 + 128 )
				{
					worldX -= autosnap_secondSnapIncrement;
				}
				else
				{
					worldX -= autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX <= -1024 )
					worldX = -1024;
			}
			else if( autosnap_subtractingY == false ) // adding to negative
			{		
				if( worldX < -1024 - 256 ) // creates deceleration
				{
					worldX += autosnap_firstSnapIncrement;
				}
				else if( worldX < -1024 - 128 )
				{
					worldX += autosnap_secondSnapIncrement;
				}
				else
				{
					worldX += autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX >= -1024 )
					worldX = -1024;
			}
		}
		else if( worldX <= 3584 && worldX >= 2560 )
		{
			// autosnap Y-axis to faceside 1, left and right
			if( worldX == 3072 ) // if finished autosnapping, turn off, do nothing
			{
				autosnap_finishedY = true;
				savedX = worldX / rotateSensitivityMultiplier;		
			}
			else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
			{
				if( worldX > 3072 )
				{
					autosnap_subtractingY = true;
				}
				else
				{
					autosnap_subtractingY = false;
				}

				autosnap_firstIterationFinishedY = true;
			}
			else if( autosnap_subtractingY == true ) // subtracting from positive
			{
				if( worldX > 3072 + 256 ) // creates deceleration 
				{
					worldX -= autosnap_firstSnapIncrement;
				}
				else if( worldX > 3072 + 128 )
				{
					worldX -= autosnap_secondSnapIncrement;
				}
				else
				{
					worldX -= autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX <= 3072 )
					worldX = 3072;
			}
			else if( autosnap_subtractingY == false ) // adding to negative
			{		
				if( worldX < 3072 - 256 ) // creates deceleration
				{
					worldX += autosnap_firstSnapIncrement;
				}
				else if( worldX < 3072 - 128 )
				{
					worldX += autosnap_secondSnapIncrement;
				}
				else
				{
					worldX += autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX >= 3072 )
					worldX = 3072;
			}
		}
	}
	else if( reversedIndex == -1 )
	{
		if( worldX <= 1536 && worldX >= 512 )
		{
			// autosnap Y-axis to faceside 1, left and right
			if( worldX == 1024 ) // if finished autosnapping, turn off, do nothing
			{
				autosnap_finishedY = true;
				savedX = worldX / rotateSensitivityMultiplier;		
			}
			else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
			{
				if( worldX > 1024 )
				{
					autosnap_subtractingY = true;
				}
				else
				{
					autosnap_subtractingY = false;
				}

				autosnap_firstIterationFinishedY = true;
			}
			else if( autosnap_subtractingY == true ) // subtracting from positive
			{
				if( worldX > 1024 + 256 ) // creates deceleration 
				{
					worldX -= autosnap_firstSnapIncrement;
				}
				else if( worldX > 1024 + 128 )
				{
					worldX -= autosnap_secondSnapIncrement;
				}
				else
				{
					worldX -= autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX <= 1024 )
					worldX = 1024;
			}
			else if( autosnap_subtractingY == false ) // adding to negative
			{		
				if( worldX < 1024 - 256 ) // creates deceleration
				{
					worldX += autosnap_firstSnapIncrement;
				}
				else if( worldX < 1024 - 128 )
				{
					worldX += autosnap_secondSnapIncrement;
				}
				else
				{
					worldX += autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX >= 1024 )
					worldX = 1024;
			}
		}
		else if( worldX <= -2560 && worldX >= -3584 )
		{
			// autosnap Y-axis to faceside 1, left and right
			if( worldX == -3072 ) // if finished autosnapping, turn off, do nothing
			{
				autosnap_finishedY = true;
				savedX = worldX / rotateSensitivityMultiplier;		
			}
			else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
			{
				if( worldX > -3072 )
				{
					autosnap_subtractingY = true;
				}
				else
				{
					autosnap_subtractingY = false;
				}

				autosnap_firstIterationFinishedY = true;
			}
			else if( autosnap_subtractingY == true ) // subtracting from positive
			{
				if( worldX > -3072 + 256 ) // creates deceleration 
				{
					worldX -= autosnap_firstSnapIncrement;
				}
				else if( worldX > -3072 + 128 )
				{
					worldX -= autosnap_secondSnapIncrement;
				}
				else
				{
					worldX -= autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX <= -3072 )
					worldX = -3072;
			}
			else if( autosnap_subtractingY == false ) // adding to negative
			{		
				if( worldX < -3072 - 256 ) // creates deceleration
				{
					worldX += autosnap_firstSnapIncrement;
				}
				else if( worldX < -3072 - 128 )
				{
					worldX += autosnap_secondSnapIncrement;
				}
				else
				{
					worldX += autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX >= -3072 )
					worldX = -3072;
			}
		}
	}
	

	// turn worldY from < -3584 to <-512 
	if( worldY < -3584 )
	{
		worldY += 4096;
	}

	// turn worldY from > 3584 to > 512
	if( worldY > 3584 )
	{
		worldY -= 4096;
	}

	if( worldY <= 512 && worldY >= -512 )
	{
		// autosnap X-axis to faceside 1, up and down
		if( worldY == 0 ) // if finished autosnapping, turn off, do nothing
		{
			autosnap_finishedX = true;		
			savedY = worldY / rotateSensitivityMultiplier;		
		}
		else if( autosnap_firstIterationFinishedX == false ) // this is executed on first iteration
		{
			if( worldY > 0 )
			{
				autosnap_subtractingX = true;
			}
			else
			{
				autosnap_subtractingX = false;
			}

			autosnap_firstIterationFinishedX = true;
		}
		else if( autosnap_subtractingX == true ) // subtracting from positive
		{
			if( worldY > 0 + 256 ) // creates deceleration 
			{
				worldY -= autosnap_firstSnapIncrement;
			}
			else if( worldY > 0 + 128 )
			{
				worldY -= autosnap_secondSnapIncrement;
			}
			else
			{
				worldY -= autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY <= 0 )
				worldY = 0;
		}
		else if( autosnap_subtractingX == false ) // adding to negative
		{		
			if( worldY < 0 - 256 ) // creates deceleration
			{
				worldY += autosnap_firstSnapIncrement;
			}
			else if( worldY < 0 - 128 )
			{
				worldY += autosnap_secondSnapIncrement;
			}
			else
			{
				worldY += autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY >= 0 )
				worldY = 0;
		}
	}
	else if( worldY <= -1536 && worldY >= -2560 )
	{
		// autosnap X-axis to faceside 1, up and down
		if( worldY == -2048 ) // if finished autosnapping, turn off, do nothing
		{
			autosnap_finishedX = true;		
			savedY = worldY / rotateSensitivityMultiplier;		
		}
		else if( autosnap_firstIterationFinishedX == false ) // this is executed on first iteration
		{
			if( worldY > -2048 )
			{
				autosnap_subtractingX = true;
			}
			else
			{
				autosnap_subtractingX = false;
			}

			autosnap_firstIterationFinishedX = true;
		}
		else if( autosnap_subtractingX == true ) // subtracting from positive
		{
			if( worldY > -2048 + 256 ) // creates deceleration 
			{
				worldY -= autosnap_firstSnapIncrement;
			}
			else if( worldY > -2048 + 128 )
			{
				worldY -= autosnap_secondSnapIncrement;
			}
			else
			{
				worldY -= autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY <= -2048 )
				worldY = -2048;
		}
		else if( autosnap_subtractingX == false ) // adding to negative
		{		
			if( worldY < -2048 - 256 ) // creates deceleration
			{
				worldY += autosnap_firstSnapIncrement;
			}
			else if( worldY < -2048 - 128 )
			{
				worldY += autosnap_secondSnapIncrement;
			}
			else
			{
				worldY += autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY >= -2048 )
				worldY = -2048;
		}
	}
	else if( worldY <= 2560 && worldY >= 1536 )
	{
		// autosnap X-axis to faceside 1, up and down
		if( worldY == 2048 ) // if finished autosnapping, turn off, do nothing
		{
			autosnap_finishedX = true;		
			savedY = worldY / rotateSensitivityMultiplier;		
		}
		else if( autosnap_firstIterationFinishedX == false ) // this is executed on first iteration
		{
			if( worldY > 2048 )
			{
				autosnap_subtractingX = true;
			}
			else
			{
				autosnap_subtractingX = false;
			}

			autosnap_firstIterationFinishedX = true;
		}
		else if( autosnap_subtractingX == true ) // subtracting from positive
		{
			if( worldY > 2048 + 256 ) // creates deceleration 
			{
				worldY -= autosnap_firstSnapIncrement;
			}
			else if( worldY > 2048 + 128 )
			{
				worldY -= autosnap_secondSnapIncrement;
			}
			else
			{
				worldY -= autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY <= 2048 )
				worldY = 2048;
		}
		else if( autosnap_subtractingX == false ) // adding to negative
		{		
			if( worldY < 2048 - 256 ) // creates deceleration
			{
				worldY += autosnap_firstSnapIncrement;
			}
			else if( worldY < 2048 - 128 )
			{
				worldY += autosnap_secondSnapIncrement;
			}
			else
			{
				worldY += autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY >= 2048 )
				worldY = 2048;
		}
	}

	// reversed Index correction
	CorrectReversedIndex();

	// reset variables when both axis are finished aligning to stop looping
	if( autosnap_finishedX == true && autosnap_finishedY == true ) // only disable autosnap looping when both x and y axes finish
	{
		ResetAutoSnapVariables();
	}
}

void SnapToFaceSide3()
{
	// turn worldX from < -3584 to <-512 
	if( worldX < -3584 )
	{
		worldX += 4096;
	}

	// turn worldX from > 3584 to > 512
	if( worldX > 3584 )
	{
		worldX -= 4096;
	}

	if( reversedIndex == 1 )
	{
		if( worldX <= -1536 && worldX >= -2560 )
		{
			// autosnap Y-axis to faceside 1, left and right
			if( worldX == -2048 ) // if finished autosnapping, turn off, do nothing
			{
				autosnap_finishedY = true;
				savedX = worldX / rotateSensitivityMultiplier;		
			}
			else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
			{
				if( worldX > -2048 )
				{
					autosnap_subtractingY = true;
				}
				else
				{
					autosnap_subtractingY = false;
				}

				autosnap_firstIterationFinishedY = true;
			}
			else if( autosnap_subtractingY == true ) // subtracting from positive
			{
				if( worldX > -2048 + 256 ) // creates deceleration 
				{
					worldX -= autosnap_firstSnapIncrement;
				}
				else if( worldX > -2048 + 128 )
				{
					worldX -= autosnap_secondSnapIncrement;
				}
				else
				{
					worldX -= autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX <= -2048 )
					worldX = -2048;
			}
			else if( autosnap_subtractingY == false ) // adding to negative
			{		
				if( worldX < -2048 - 256 ) // creates deceleration
				{
					worldX += autosnap_firstSnapIncrement;
				}
				else if( worldX < -2048 - 128 )
				{
					worldX += autosnap_secondSnapIncrement;
				}
				else
				{
					worldX += autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX >= -2048 )
					worldX = -2048;
			}
		}
		else if( worldX <= 2560 && worldX >= 1536 )
		{
			// autosnap Y-axis to faceside 1, left and right
			if( worldX == 2048 ) // if finished autosnapping, turn off, do nothing
			{
				autosnap_finishedY = true;
				savedX = worldX / rotateSensitivityMultiplier;		
			}
			else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
			{
				if( worldX > 2048 )
				{
					autosnap_subtractingY = true;
				}
				else
				{
					autosnap_subtractingY = false;
				}

				autosnap_firstIterationFinishedY = true;
			}
			else if( autosnap_subtractingY == true ) // subtracting from positive
			{
				if( worldX > 2048 + 256 ) // creates deceleration 
				{
					worldX -= autosnap_firstSnapIncrement;
				}
				else if( worldX > 2048 + 128 )
				{
					worldX -= autosnap_secondSnapIncrement;
				}
				else
				{
					worldX -= autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX <= 2048 )
					worldX = 2048;
			}
			else if( autosnap_subtractingY == false ) // adding to negative
			{		
				if( worldX < 2048 - 256 ) // creates deceleration
				{
					worldX += autosnap_firstSnapIncrement;
				}
				else if( worldX < 2048 - 128 )
				{
					worldX += autosnap_secondSnapIncrement;
				}
				else
				{
					worldX += autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX >= 2048 )
					worldX = 2048;
			}
		}
	}
	else if( reversedIndex == -1 )
	{
		if( worldX <= 512 && worldX >= -512 )  // for upside down orientation
		{
			// autosnap Y-axis to faceside 1, left and right
			if( worldX == 0 ) // if finished autosnapping, turn off, do nothing
			{
				autosnap_finishedY = true;
				savedX = worldX / rotateSensitivityMultiplier;		
			}
			else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
			{
				if( worldX > 0 )
				{
					autosnap_subtractingY = true;
				}
				else
				{
					autosnap_subtractingY = false;
				}

				autosnap_firstIterationFinishedY = true;
			}
			else if( autosnap_subtractingY == true ) // subtracting from positive
			{
				if( worldX > 0 + 256 ) // creates deceleration 
				{
					worldX -= autosnap_firstSnapIncrement;
				}
				else if( worldX > 0 + 128 )
				{
					worldX -= autosnap_secondSnapIncrement;
				}
				else
				{
					worldX -= autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX <= 0 )
					worldX = 0;
			}
			else if( autosnap_subtractingY == false ) // adding to negative
			{		
				if( worldX < 0 - 256 ) // creates deceleration
				{
					worldX += autosnap_firstSnapIncrement;
				}
				else if( worldX < 0 - 128 )
				{
					worldX += autosnap_secondSnapIncrement;
				}
				else
				{
					worldX += autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX >= 0 )
					worldX = 0;
			}
		}
	}


	// turn worldY from < -3584 to <-512 
	if( worldY < -3584 )
	{
		worldY += 4096;
	}

	// turn worldY from > 3584 to > 512
	if( worldY > 3584 )
	{
		worldY -= 4096;
	}

	if( worldY <= 512 && worldY >= -512 )
	{
		// autosnap X-axis to faceside 1, up and down
		if( worldY == 0 ) // if finished autosnapping, turn off, do nothing
		{
			autosnap_finishedX = true;		
			savedY = worldY / rotateSensitivityMultiplier;		
		}
		else if( autosnap_firstIterationFinishedX == false ) // this is executed on first iteration
		{
			if( worldY > 0 )
			{
				autosnap_subtractingX = true;
			}
			else
			{
				autosnap_subtractingX = false;
			}

			autosnap_firstIterationFinishedX = true;
		}
		else if( autosnap_subtractingX == true ) // subtracting from positive
		{
			if( worldY > 0 + 256 ) // creates deceleration 
			{
				worldY -= autosnap_firstSnapIncrement;
			}
			else if( worldY > 0 + 128 )
			{
				worldY -= autosnap_secondSnapIncrement;
			}
			else
			{
				worldY -= autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY <= 0 )
				worldY = 0;
		}
		else if( autosnap_subtractingX == false ) // adding to negative
		{		
			if( worldY < 0 - 256 ) // creates deceleration
			{
				worldY += autosnap_firstSnapIncrement;
			}
			else if( worldY < 0 - 128 )
			{
				worldY += autosnap_secondSnapIncrement;
			}
			else
			{
				worldY += autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY >= 0 )
				worldY = 0;
		}
	}
	else if( worldY <= -1536 && worldY >= -2560 )
	{
		// autosnap X-axis to faceside 1, up and down
		if( worldY == -2048 ) // if finished autosnapping, turn off, do nothing
		{
			autosnap_finishedX = true;		
			savedY = worldY / rotateSensitivityMultiplier;		
		}
		else if( autosnap_firstIterationFinishedX == false ) // this is executed on first iteration
		{
			if( worldY > -2048 )
			{
				autosnap_subtractingX = true;
			}
			else
			{
				autosnap_subtractingX = false;
			}

			autosnap_firstIterationFinishedX = true;
		}
		else if( autosnap_subtractingX == true ) // subtracting from positive
		{
			if( worldY > -2048 + 256 ) // creates deceleration 
			{
				worldY -= autosnap_firstSnapIncrement;
			}
			else if( worldY > -2048 + 128 )
			{
				worldY -= autosnap_secondSnapIncrement;
			}
			else
			{
				worldY -= autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY <= -2048 )
				worldY = -2048;
		}
		else if( autosnap_subtractingX == false ) // adding to negative
		{		
			if( worldY < -2048 - 256 ) // creates deceleration
			{
				worldY += autosnap_firstSnapIncrement;
			}
			else if( worldY < -2048 - 128 )
			{
				worldY += autosnap_secondSnapIncrement;
			}
			else
			{
				worldY += autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY >= -2048 )
				worldY = -2048;
		}
	}
	else if( worldY <= 2560 && worldY >= 1536 )
	{
		// autosnap X-axis to faceside 1, up and down
		if( worldY == 2048 ) // if finished autosnapping, turn off, do nothing
		{
			autosnap_finishedX = true;		
			savedY = worldY / rotateSensitivityMultiplier;		
		}
		else if( autosnap_firstIterationFinishedX == false ) // this is executed on first iteration
		{
			if( worldY > 2048 )
			{
				autosnap_subtractingX = true;
			}
			else
			{
				autosnap_subtractingX = false;
			}

			autosnap_firstIterationFinishedX = true;
		}
		else if( autosnap_subtractingX == true ) // subtracting from positive
		{
			if( worldY > 2048 + 256 ) // creates deceleration 
			{
				worldY -= autosnap_firstSnapIncrement;
			}
			else if( worldY > 2048 + 128 )
			{
				worldY -= autosnap_secondSnapIncrement;
			}
			else
			{
				worldY -= autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY <= 2048 )
				worldY = 2048;
		}
		else if( autosnap_subtractingX == false ) // adding to negative
		{		
			if( worldY < 2048 - 256 ) // creates deceleration
			{
				worldY += autosnap_firstSnapIncrement;
			}
			else if( worldY < 2048 - 128 )
			{
				worldY += autosnap_secondSnapIncrement;
			}
			else
			{
				worldY += autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY >= 2048 )
				worldY = 2048;
		}
	}

	// reversed Index correction
	CorrectReversedIndex();

	// reset variables when both axis are finished aligning to stop looping
	if( autosnap_finishedX == true && autosnap_finishedY == true ) // only disable autosnap looping when both x and y axes finish
	{
		ResetAutoSnapVariables();
	}
}

void SnapToFaceSide4()
{
	// turn worldX from < -3584 to <-512 
	if( worldX < -3584 )
	{
		worldX += 4096;
	}

	// turn worldX from > 3584 to > 512
	if( worldX > 3584 )
	{
		worldX -= 4096;
	}

	if( reversedIndex == 1 )
	{
		if( worldX <= 1536 && worldX >= 512 )
		{
			// autosnap Y-axis to faceside 1, left and right
			if( worldX == 1024 ) // if finished autosnapping, turn off, do nothing
			{
				autosnap_finishedY = true;
				savedX = worldX / rotateSensitivityMultiplier;		
			}
			else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
			{
				if( worldX > 1024 )
				{
					autosnap_subtractingY = true;
				}
				else
				{
					autosnap_subtractingY = false;
				}

				autosnap_firstIterationFinishedY = true;
			}
			else if( autosnap_subtractingY == true ) // subtracting from positive
			{
				if( worldX > 1024 + 256 ) // creates deceleration 
				{
					worldX -= autosnap_firstSnapIncrement;
				}
				else if( worldX > 1024 + 128 )
				{
					worldX -= autosnap_secondSnapIncrement;
				}
				else
				{
					worldX -= autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX <= 1024 )
					worldX = 1024;
			}
			else if( autosnap_subtractingY == false ) // adding to negative
			{		
				if( worldX < 1024 - 256 ) // creates deceleration
				{
					worldX += autosnap_firstSnapIncrement;
				}
				else if( worldX < 1024 - 128 )
				{
					worldX += autosnap_secondSnapIncrement;
				}
				else
				{
					worldX += autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX >= 1024 )
					worldX = 1024;
			}
		}
		else if( worldX <= -2560 && worldX >= -3584 )
		{
			// autosnap Y-axis to faceside 1, left and right
			if( worldX == -3072 ) // if finished autosnapping, turn off, do nothing
			{
				autosnap_finishedY = true;
				savedX = worldX / rotateSensitivityMultiplier;		
			}
			else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
			{
				if( worldX > -3072 )
				{
					autosnap_subtractingY = true;
				}
				else
				{
					autosnap_subtractingY = false;
				}

				autosnap_firstIterationFinishedY = true;
			}
			else if( autosnap_subtractingY == true ) // subtracting from positive
			{
				if( worldX > -3072 + 256 ) // creates deceleration 
				{
					worldX -= autosnap_firstSnapIncrement;
				}
				else if( worldX > -3072 + 128 )
				{
					worldX -= autosnap_secondSnapIncrement;
				}
				else
				{
					worldX -= autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX <= -3072 )
					worldX = -3072;
			}
			else if( autosnap_subtractingY == false ) // adding to negative
			{		
				if( worldX < -3072 - 256 ) // creates deceleration
				{
					worldX += autosnap_firstSnapIncrement;
				}
				else if( worldX < -3072 - 128 )
				{
					worldX += autosnap_secondSnapIncrement;
				}
				else
				{
					worldX += autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX >= -3072 )
					worldX = -3072;
			}
		}
	}
	else if( reversedIndex == -1 )
	{
		if( worldX <= -512 && worldX >= -1536 )
		{
			// autosnap Y-axis to faceside 1, left and right
			if( worldX == -1024 ) // if finished autosnapping, turn off, do nothing
			{
				autosnap_finishedY = true;
				savedX = worldX / rotateSensitivityMultiplier;		
			}
			else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
			{
				if( worldX > -1024 )
				{
					autosnap_subtractingY = true;
				}
				else
				{
					autosnap_subtractingY = false;
				}

				autosnap_firstIterationFinishedY = true;
			}
			else if( autosnap_subtractingY == true ) // subtracting from positive
			{
				if( worldX > -1024 + 256 ) // creates deceleration 
				{
					worldX -= autosnap_firstSnapIncrement;
				}
				else if( worldX > -1024 + 128 )
				{
					worldX -= autosnap_secondSnapIncrement;
				}
				else
				{
					worldX -= autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX <= -1024 )
					worldX = -1024;
			}
			else if( autosnap_subtractingY == false ) // adding to negative
			{		
				if( worldX < -1024 - 256 ) // creates deceleration
				{
					worldX += autosnap_firstSnapIncrement;
				}
				else if( worldX < -1024 - 128 )
				{
					worldX += autosnap_secondSnapIncrement;
				}
				else
				{
					worldX += autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX >= -1024 )
					worldX = -1024;
			}
		}
		else if( worldX <= 3584 && worldX >= 2560 )
		{
			// autosnap Y-axis to faceside 1, left and right
			if( worldX == 3072 ) // if finished autosnapping, turn off, do nothing
			{
				autosnap_finishedY = true;
				savedX = worldX / rotateSensitivityMultiplier;		
			}
			else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
			{
				if( worldX > 3072 )
				{
					autosnap_subtractingY = true;
				}
				else
				{
					autosnap_subtractingY = false;
				}

				autosnap_firstIterationFinishedY = true;
			}
			else if( autosnap_subtractingY == true ) // subtracting from positive
			{
				if( worldX > 3072 + 256 ) // creates deceleration 
				{
					worldX -= autosnap_firstSnapIncrement;
				}
				else if( worldX > 3072 + 128 )
				{
					worldX -= autosnap_secondSnapIncrement;
				}
				else
				{
					worldX -= autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX <= 3072 )
					worldX = 3072;
			}
			else if( autosnap_subtractingY == false ) // adding to negative
			{		
				if( worldX < 3072 - 256 ) // creates deceleration
				{
					worldX += autosnap_firstSnapIncrement;
				}
				else if( worldX < 3072 - 128 )
				{
					worldX += autosnap_secondSnapIncrement;
				}
				else
				{
					worldX += autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX >= 3072 )
					worldX = 3072;
			}
		}
	}

	// turn worldY from < -3584 to <-512 
	if( worldY < -3584 )
	{
		worldY += 4096;
	}

	// turn worldY from > 3584 to > 512
	if( worldY > 3584 )
	{
		worldY -= 4096;
	}

	if( worldY <= 512 && worldY >= -512 )
	{
		// autosnap X-axis to faceside 1, up and down
		if( worldY == 0 ) // if finished autosnapping, turn off, do nothing
		{
			autosnap_finishedX = true;		
			savedY = worldY / rotateSensitivityMultiplier;		
		}
		else if( autosnap_firstIterationFinishedX == false ) // this is executed on first iteration
		{
			if( worldY > 0 )
			{
				autosnap_subtractingX = true;
			}
			else
			{
				autosnap_subtractingX = false;
			}

			autosnap_firstIterationFinishedX = true;
		}
		else if( autosnap_subtractingX == true ) // subtracting from positive
		{
			if( worldY > 0 + 256 ) // creates deceleration 
			{
				worldY -= autosnap_firstSnapIncrement;
			}
			else if( worldY > 0 + 128 )
			{
				worldY -= autosnap_secondSnapIncrement;
			}
			else
			{
				worldY -= autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY <= 0 )
				worldY = 0;
		}
		else if( autosnap_subtractingX == false ) // adding to negative
		{		
			if( worldY < 0 - 256 ) // creates deceleration
			{
				worldY += autosnap_firstSnapIncrement;
			}
			else if( worldY < 0 - 128 )
			{
				worldY += autosnap_secondSnapIncrement;
			}
			else
			{
				worldY += autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY >= 0 )
				worldY = 0;
		}
	}
	else if( worldY <= -1536 && worldY >= -2560 )
	{
		// autosnap X-axis to faceside 1, up and down
		if( worldY == -2048 ) // if finished autosnapping, turn off, do nothing
		{
			autosnap_finishedX = true;		
			savedY = worldY / rotateSensitivityMultiplier;		
		}
		else if( autosnap_firstIterationFinishedX == false ) // this is executed on first iteration
		{
			if( worldY > -2048 )
			{
				autosnap_subtractingX = true;
			}
			else
			{
				autosnap_subtractingX = false;
			}

			autosnap_firstIterationFinishedX = true;
		}
		else if( autosnap_subtractingX == true ) // subtracting from positive
		{
			if( worldY > -2048 + 256 ) // creates deceleration 
			{
				worldY -= autosnap_firstSnapIncrement;
			}
			else if( worldY > -2048 + 128 )
			{
				worldY -= autosnap_secondSnapIncrement;
			}
			else
			{
				worldY -= autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY <= -2048 )
				worldY = -2048;
		}
		else if( autosnap_subtractingX == false ) // adding to negative
		{		
			if( worldY < -2048 - 256 ) // creates deceleration
			{
				worldY += autosnap_firstSnapIncrement;
			}
			else if( worldY < -2048 - 128 )
			{
				worldY += autosnap_secondSnapIncrement;
			}
			else
			{
				worldY += autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY >= -2048 )
				worldY = -2048;
		}
	}
	else if( worldY <= 2560 && worldY >= 1536 )
	{
		// autosnap X-axis to faceside 1, up and down
		if( worldY == 2048 ) // if finished autosnapping, turn off, do nothing
		{
			autosnap_finishedX = true;		
			savedY = worldY / rotateSensitivityMultiplier;		
		}
		else if( autosnap_firstIterationFinishedX == false ) // this is executed on first iteration
		{
			if( worldY > 2048 )
			{
				autosnap_subtractingX = true;
			}
			else
			{
				autosnap_subtractingX = false;
			}

			autosnap_firstIterationFinishedX = true;
		}
		else if( autosnap_subtractingX == true ) // subtracting from positive
		{
			if( worldY > 2048 + 256 ) // creates deceleration 
			{
				worldY -= autosnap_firstSnapIncrement;
			}
			else if( worldY > 2048 + 128 )
			{
				worldY -= autosnap_secondSnapIncrement;
			}
			else
			{
				worldY -= autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY <= 2048 )
				worldY = 2048;
		}
		else if( autosnap_subtractingX == false ) // adding to negative
		{		
			if( worldY < 2048 - 256 ) // creates deceleration
			{
				worldY += autosnap_firstSnapIncrement;
			}
			else if( worldY < 2048 - 128 )
			{
				worldY += autosnap_secondSnapIncrement;
			}
			else
			{
				worldY += autosnap_thirdSnapIncrement;
			}

			savedY = worldY / rotateSensitivityMultiplier;
			if( worldY >= 2048 )
				worldY = 2048;
		}
	}

	// reversed Index correction
	CorrectReversedIndex();

	// reset variables when both axis are finished aligning to stop looping
	if( autosnap_finishedX == true && autosnap_finishedY == true ) // only disable autosnap looping when both x and y axes finish
	{
		ResetAutoSnapVariables();
	}
}

void SnapToFaceSide5()
{
	if( (worldX > -512 && worldX < 512) || 
		worldX > 3584 ||
		worldX < -3584 ) // orientation with faceside 1 facing bottom
	{
		// turn worldX from < -3584 to <-512 
		if( worldX < -3584 )
		{
			worldX += 4096;
		}

		// turn worldX from > 3584 to > 512
		if( worldX > 3584 )
		{
			worldX -= 4096;
		}

		
		if( worldX <= 512 && worldX >= -512 )
		{
			// autosnap Y-axis to faceside 1, left and right
			if( worldX == 0 ) // if finished autosnapping, turn off, do nothing
			{
				autosnap_finishedY = true;
				savedX = worldX / rotateSensitivityMultiplier;		
			}
			else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
			{
				if( worldX > 0 )
				{
					autosnap_subtractingY = true;
				}
				else
				{
					autosnap_subtractingY = false;
				}

				autosnap_firstIterationFinishedY = true;
			}
			else if( autosnap_subtractingY == true ) // subtracting from positive
			{
				if( worldX > 0 + 256 ) // creates deceleration 
				{
					worldX -= autosnap_firstSnapIncrement;
				}
				else if( worldX > 0 + 128 )
				{
					worldX -= autosnap_secondSnapIncrement;
				}
				else
				{
					worldX -= autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX <= 0 )
					worldX = 0;
			}
			else if( autosnap_subtractingY == false ) // adding to negative
			{		
				if( worldX < 0 - 256 ) // creates deceleration
				{
					worldX += autosnap_firstSnapIncrement;
				}
				else if( worldX < 0 - 128 )
				{
					worldX += autosnap_secondSnapIncrement;
				}
				else
				{
					worldX += autosnap_thirdSnapIncrement;
				}

				savedX = worldX / rotateSensitivityMultiplier;
				if( worldX >= 0 )
					worldX = 0;
			}
		}
	}
	else if( worldX < -512 && worldX >= -1536 ||
		worldX < 3584 && worldX > 2560 ) // orientation with faceside 2 facing bottom
	{		
		if( worldX < 3584 && worldX > 2560 ) // snaptofaceside 2 for y-axis algorithm
		{
			worldX -= 4096;
		}

		// autosnap Y-axis to faceside 1, left and right
		if( worldX == -1024 ) // if finished autosnapping, turn off, do nothing
		{
			autosnap_finishedY = true;
			savedX = worldX / rotateSensitivityMultiplier;		
		}
		else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
		{
			if( worldX > -1024 )
			{
				autosnap_subtractingY = true;
			}
			else
			{
				autosnap_subtractingY = false;
			}

			autosnap_firstIterationFinishedY = true;
		}
		else if( autosnap_subtractingY == true ) // subtracting from positive
		{
			if( worldX > -1024 + 256 ) // creates deceleration 
			{
				worldX -= autosnap_firstSnapIncrement;
			}
			else if( worldX > -1024 + 128 )
			{
				worldX -= autosnap_secondSnapIncrement;
			}
			else
			{
				worldX -= autosnap_thirdSnapIncrement;
			}

			savedX = worldX / rotateSensitivityMultiplier;
			if( worldX <= -1024 )
				worldX = -1024;
		}
		else if( autosnap_subtractingY == false ) // adding to negative
		{		
			if( worldX < -1024 - 256 ) // creates deceleration
			{
				worldX += autosnap_firstSnapIncrement;
			}
			else if( worldX < -1024 - 128 )
			{
				worldX += autosnap_secondSnapIncrement;
			}
			else
			{
				worldX += autosnap_thirdSnapIncrement;
			}

			savedX = worldX / rotateSensitivityMultiplier;
			if( worldX >= -1024 )
				worldX = -1024;
		}
	}
	else if( worldX <= 2560 && worldX >= 1536 ||
		worldX <= -1536 && worldX >= -2560 ) // orientation with faceside 3 facing bottom
	{
		if( worldX <= 2560 && worldX >= 1536 ) // snaptofaceside 3 for y-axis algorithm
		{
			worldX -= 4096;
		}

		// autosnap Y-axis to faceside 1, left and right
		if( worldX == 1024 ) // if finished autosnapping, turn off, do nothing
		{
			autosnap_finishedY = true;
			savedX = worldX / rotateSensitivityMultiplier;		
		}
		else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
		{
			if( worldX > -2048 )
			{
				autosnap_subtractingY = true;
			}
			else
			{
				autosnap_subtractingY = false;
			}

			autosnap_firstIterationFinishedY = true;
		}
		else if( autosnap_subtractingY == true ) // subtracting from positive
		{
			if( worldX > -2048 + 256 ) // creates deceleration 
			{
				worldX -= autosnap_firstSnapIncrement;
			}
			else if( worldX > -2048 + 128 )
			{
				worldX -= autosnap_secondSnapIncrement;
			}
			else
			{
				worldX -= autosnap_thirdSnapIncrement;
			}

			savedX = worldX / rotateSensitivityMultiplier;
			if( worldX <= -2048 )
				worldX = -2048;
		}
		else if( autosnap_subtractingY == false ) // adding to negative
		{		
			if( worldX < -2048 - 256 ) // creates deceleration
			{
				worldX += autosnap_firstSnapIncrement;
			}
			else if( worldX < -2048 - 128 )
			{
				worldX += autosnap_secondSnapIncrement;
			}
			else
			{
				worldX += autosnap_thirdSnapIncrement;
			}

			savedX = worldX / rotateSensitivityMultiplier;
			if( worldX >= -2048 )
				worldX = -2048;
		}
	}
	else if( worldX <= -2560 && worldX >= -3584 ||
		worldX <= 1536 && worldX >= 512 ) // orientation with faceside 4 facing bottom
	{
		if( worldX <= -2560 && worldX >= -3584 ) // snaptofaceside 4 for y-axis algorithm
		{
			worldX += 4096;
		}

		// autosnap Y-axis to faceside 1, left and right
		if( worldX == 1024 ) // if finished autosnapping, turn off, do nothing
		{
			autosnap_finishedY = true;
			savedX = worldX / rotateSensitivityMultiplier;		
		}
		else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
		{
			if( worldX > 1024 )
			{
				autosnap_subtractingY = true;
			}
			else
			{
				autosnap_subtractingY = false;
			}

			autosnap_firstIterationFinishedY = true;
		}
		else if( autosnap_subtractingY == true ) // subtracting from positive
		{
			if( worldX > 1024 + 256 ) // creates deceleration 
			{
				worldX -= autosnap_firstSnapIncrement;
			}
			else if( worldX > 1024 + 128 )
			{
				worldX -= autosnap_secondSnapIncrement;
			}
			else
			{
				worldX -= autosnap_thirdSnapIncrement;
			}

			savedX = worldX / rotateSensitivityMultiplier;
			if( worldX <= 1024 )
				worldX = 1024;
		}
		else if( autosnap_subtractingY == false ) // adding to negative
		{		
			if( worldX < 1024 - 256 ) // creates deceleration
			{
				worldX += autosnap_firstSnapIncrement;
			}
			else if( worldX < 1024 - 128 )
			{
				worldX += autosnap_secondSnapIncrement;
			}
			else
			{
				worldX += autosnap_thirdSnapIncrement;
			}

			savedX = worldX / rotateSensitivityMultiplier;
			if( worldX >= 1024 )
				worldX = 1024;
		}
	}	

	// correct worldY
	if( worldY >= 2560 && worldY <= 3584 )
	{
		worldY -= 4096;
	}

	// autosnap X-axis to faceside 1, up and down
	if( worldY == -1024 ) // if finished autosnapping, turn off, do nothing
	{
		autosnap_finishedX = true;		
		savedY = worldY / rotateSensitivityMultiplier;		
	}
	else if( autosnap_firstIterationFinishedX == false ) // this is executed on first iteration
	{
		if( worldY > -1024 )
		{
			autosnap_subtractingX = true;
		}
		else
		{
			autosnap_subtractingX = false;
		}

		autosnap_firstIterationFinishedX = true;
	}
	else if( autosnap_subtractingX == true ) // subtracting from positive
	{
		if( worldY > -1024 + 256 ) // creates deceleration 
		{
			worldY -= autosnap_firstSnapIncrement;
		}
		else if( worldY > -1024 + 128 )
		{
			worldY -= autosnap_secondSnapIncrement;
		}
		else
		{
			worldY -= autosnap_thirdSnapIncrement;
		}

		savedY = worldY / rotateSensitivityMultiplier;
		if( worldY <= -1024 )
			worldY = -1024;
	}
	else if( autosnap_subtractingX == false ) // adding to negative
	{		
		if( worldY < -1024 - 256 ) // creates deceleration
		{
			worldY += autosnap_firstSnapIncrement;
		}
		else if( worldY < -1024 - 128 )
		{
			worldY += autosnap_secondSnapIncrement;
		}
		else
		{
			worldY += autosnap_thirdSnapIncrement;
		}

		savedY = worldY / rotateSensitivityMultiplier;
		if( worldY >= -1024 )
			worldY = -1024;
	}

	// reversed Index correction for faceside 5
	if( getActiveFaceSide() == 5 )
	{
		if( y1 > IwGxGetScreenHeight() /2 )
			reversedIndex = 1;
		else
			reversedIndex = -1;
	}
	else if( getActiveFaceSide() == 6 )
	{
		if( y1 > IwGxGetScreenHeight() /2 )
			reversedIndex = -1;
		else
			reversedIndex = 1;
	}

	// reset variables when both axis are finished aligning to stop looping
	if( autosnap_finishedX == true && autosnap_finishedY == true ) // only disable autosnap looping when both x and y axes finish
	{
		ResetAutoSnapVariables();
	}
} // end of SnapToFaceSide5()

void SnapToFaceSide6()	
{	
	if( (worldX >= -512 && worldX <= 512) || 
		worldX >= 3584 ||
		worldX <= -3584 ) // orientation with faceside 1 facing bottom
	{
		// turn worldX from < -3584 to <-512  // snaptofaceside 1 for y-axis algorithm
		if( worldX < -3584 )
		{
			worldX += 4096;
		}

		// turn worldX from > 3584 to > 512
		if( worldX > 3584 )
		{
			worldX -= 4096;
		}

		// autosnap Y-axis to faceside 1, left and right
		if( worldX == 0 ) // if finished autosnapping, turn off, do nothing
		{
			autosnap_finishedY = true;
			savedX = worldX / rotateSensitivityMultiplier;		
		}
		else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
		{
			if( worldX > 0 )
			{
				autosnap_subtractingY = true;
			}
			else
			{
				autosnap_subtractingY = false;
			}

			autosnap_firstIterationFinishedY = true;
		}
		else if( autosnap_subtractingY == true ) // subtracting from positive
		{
			if( worldX > 0 + 256 ) // creates deceleration 
			{
				worldX -= autosnap_firstSnapIncrement;
			}
			else if( worldX > 0 + 128 )
			{
				worldX -= autosnap_secondSnapIncrement;
			}
			else
			{
				worldX -= autosnap_thirdSnapIncrement;
			}

			savedX = worldX / rotateSensitivityMultiplier;
			if( worldX <= 0 )
				worldX = 0;
		}
		else if( autosnap_subtractingY == false ) // adding to negative
		{		
			if( worldX < 0 - 256 ) // creates deceleration
			{
				worldX += autosnap_firstSnapIncrement;
			}
			else if( worldX < 0 - 128 )
			{
				worldX += autosnap_secondSnapIncrement;
			}
			else
			{
				worldX += autosnap_thirdSnapIncrement;
			}

			savedX = worldX / rotateSensitivityMultiplier;
			if( worldX >= 0 )
				worldX = 0;
		}
	}
	else if( worldX <= -512 && worldX >= -1536 ||
		worldX <= 3584 && worldX >= 2560 ) // orientation with faceside 2 facing bottom
	{		
		if( worldX < 3584 && worldX > 2560 ) // snaptofaceside 2 for y-axis algorithm
		{
			worldX -= 4096;
		}

		// autosnap Y-axis to faceside 1, left and right
		if( worldX == -1024 ) // if finished autosnapping, turn off, do nothing
		{
			autosnap_finishedY = true;
			savedX = worldX / rotateSensitivityMultiplier;		
		}
		else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
		{
			if( worldX > -1024 )
			{
				autosnap_subtractingY = true;
			}
			else
			{
				autosnap_subtractingY = false;
			}

			autosnap_firstIterationFinishedY = true;
		}
		else if( autosnap_subtractingY == true ) // subtracting from positive
		{
			if( worldX > -1024 + 256 ) // creates deceleration 
			{
				worldX -= autosnap_firstSnapIncrement;
			}
			else if( worldX > -1024 + 128 )
			{
				worldX -= autosnap_secondSnapIncrement;
			}
			else
			{
				worldX -= autosnap_thirdSnapIncrement;
			}

			savedX = worldX / rotateSensitivityMultiplier;
			if( worldX <= -1024 )
				worldX = -1024;
		}
		else if( autosnap_subtractingY == false ) // adding to negative
		{		
			if( worldX < -1024 - 256 ) // creates deceleration
			{
				worldX += autosnap_firstSnapIncrement;
			}
			else if( worldX < -1024 - 128 )
			{
				worldX += autosnap_secondSnapIncrement;
			}
			else
			{
				worldX += autosnap_thirdSnapIncrement;
			}

			savedX = worldX / rotateSensitivityMultiplier;
			if( worldX >= -1024 )
				worldX = -1024;
		}
	}
	else if( worldX <= 2560 && worldX >= 1536 ||
		worldX <= -1536 && worldX >= -2560 ) // orientation with faceside 3 facing bottom
	{
		if( worldX <= 2560 && worldX >= 1536 ) // snaptofaceside 3 for y-axis algorithm
		{
			worldX -= 4096;
		}

		// autosnap Y-axis to faceside 1, left and right
		if( worldX == 1024 ) // if finished autosnapping, turn off, do nothing
		{
			autosnap_finishedY = true;
			savedX = worldX / rotateSensitivityMultiplier;		
		}
		else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
		{
			if( worldX > -2048 )
			{
				autosnap_subtractingY = true;
			}
			else
			{
				autosnap_subtractingY = false;
			}

			autosnap_firstIterationFinishedY = true;
		}
		else if( autosnap_subtractingY == true ) // subtracting from positive
		{
			if( worldX > -2048 + 256 ) // creates deceleration 
			{
				worldX -= autosnap_firstSnapIncrement;
			}
			else if( worldX > -2048 + 128 )
			{
				worldX -= autosnap_secondSnapIncrement;
			}
			else
			{
				worldX -= autosnap_thirdSnapIncrement;
			}

			savedX = worldX / rotateSensitivityMultiplier;
			if( worldX <= -2048 )
				worldX = -2048;
		}
		else if( autosnap_subtractingY == false ) // adding to negative
		{		
			if( worldX < -2048 - 256 ) // creates deceleration
			{
				worldX += autosnap_firstSnapIncrement;
			}
			else if( worldX < -2048 - 128 )
			{
				worldX += autosnap_secondSnapIncrement;
			}
			else
			{
				worldX += autosnap_thirdSnapIncrement;
			}

			savedX = worldX / rotateSensitivityMultiplier;
			if( worldX >= -2048 )
				worldX = -2048;
		}
	}
	else if( worldX <= -2560 && worldX >= -3584 ||
		worldX <= 1536 && worldX >= 512 ) // orientation with faceside 4 facing bottom
	{
		if( worldX <= -2560 && worldX >= -3584 ) // snaptofaceside 4 for y-axis algorithm
		{
			worldX += 4096;
		}

		// autosnap Y-axis to faceside 1, left and right
		if( worldX == 1024 ) // if finished autosnapping, turn off, do nothing
		{
			autosnap_finishedY = true;
			savedX = worldX / rotateSensitivityMultiplier;		
		}
		else if( autosnap_firstIterationFinishedY == false ) // this is executed on first iteration
		{
			if( worldX > 1024 )
			{
				autosnap_subtractingY = true;
			}
			else
			{
				autosnap_subtractingY = false;
			}

			autosnap_firstIterationFinishedY = true;
		}
		else if( autosnap_subtractingY == true ) // subtracting from positive
		{
			if( worldX > 1024 + 256 ) // creates deceleration 
			{
				worldX -= autosnap_firstSnapIncrement;
			}
			else if( worldX > 1024 + 128 )
			{
				worldX -= autosnap_secondSnapIncrement;
			}
			else
			{
				worldX -= autosnap_thirdSnapIncrement;
			}

			savedX = worldX / rotateSensitivityMultiplier;
			if( worldX <= 1024 )
				worldX = 1024;
		}
		else if( autosnap_subtractingY == false ) // adding to negative
		{		
			if( worldX < 1024 - 256 ) // creates deceleration
			{
				worldX += autosnap_firstSnapIncrement;
			}
			else if( worldX < 1024 - 128 )
			{
				worldX += autosnap_secondSnapIncrement;
			}
			else
			{
				worldX += autosnap_thirdSnapIncrement;
			}

			savedX = worldX / rotateSensitivityMultiplier;
			if( worldX >= 1024 )
				worldX = 1024;
		}
	}	

	// correct worldY
	if( worldY <= -2560 && worldY >= -3584  )
	{
		worldY += 4096;
	}

	// autosnap X-axis to faceside 1, up and down
	if( worldY == 1024 ) // if finished autosnapping, turn off, do nothing
	{
		autosnap_finishedX = true;		
		savedY = worldY / rotateSensitivityMultiplier;		
	}
	else if( autosnap_firstIterationFinishedX == false ) // this is executed on first iteration
	{
		if( worldY > 1024 )
		{
			autosnap_subtractingX = true;
		}
		else
		{
			autosnap_subtractingX = false;
		}

		autosnap_firstIterationFinishedX = true;
	}
	else if( autosnap_subtractingX == true ) // subtracting from positive
	{
		if( worldY > 1024 + 256 ) // creates deceleration 
		{
			worldY -= autosnap_firstSnapIncrement;
		}
		else if( worldY > 1024 + 128 )
		{
			worldY -= autosnap_secondSnapIncrement;
		}
		else
		{
			worldY -= autosnap_thirdSnapIncrement;
		}

		savedY = worldY / rotateSensitivityMultiplier;
		if( worldY <= 1024 )
			worldY = 1024;
	}
	else if( autosnap_subtractingX == false ) // adding to negative
	{		
		if( worldY < 1024 - 256 ) // creates deceleration
		{
			worldY += autosnap_firstSnapIncrement;
		}
		else if( worldY < 1024 - 128 )
		{
			worldY += autosnap_secondSnapIncrement;
		}
		else
		{
			worldY += autosnap_thirdSnapIncrement;
		}

		savedY = worldY / rotateSensitivityMultiplier;
		if( worldY >= 1024 )
			worldY = 1024;
	}

	// reversed Index correction for faceside 5
	if( getActiveFaceSide() == 5 )
	{
		if( y1 > IwGxGetScreenHeight() /2 )
			reversedIndex = 1;
		else
			reversedIndex = -1;
	}
	else if( getActiveFaceSide() == 6 )
	{
		if( y1 > IwGxGetScreenHeight() /2 )
			reversedIndex = -1;
		else
			reversedIndex = 1;
	}

	// reset variables when both axis are finished aligning to stop looping
	if( autosnap_finishedX == true && autosnap_finishedY == true ) // only disable autosnap looping when both x and y axes finish
	{
		ResetAutoSnapVariables();
	}
}

void CorrectReversedIndex()
{
	// reversed Index correction
	int16 value = (worldY) + 1024; // this value is the X-drag value to control y-rotation
		
	// wrap a negative value
	while( value < 0 ) // if value is negative, keep adding until positive
	{
		value += 4096;
	}
	// wrap a positive value
	if( value > 0 )
		value = value % 4096; // if value is positive, mod it

	if( getActiveFaceSide() != 5 || getActiveFaceSide() != 6 ) // active faceside of 5 or 6 overrides the motion reverse index
	{
		// determine if y-axis rotation is reversed based on wrapped value
		if( value <= 2048 ) // not reversed
		{
			reversedIndex = 1;
		}
		else if( value > 2048 )
			reversedIndex = -1;
	}
}

// not used, I believe
void CorrectAutoSnap()
{
	// if faceside1 is at bottom
	if( (worldX > -512 && worldX < 512) || 
	worldX > 3584 ||
	worldX < -3584 ) // orientation with faceside 1 facing bottom
	{

		worldY += 1024;
		savedY = worldY / rotateSensitivityMultiplier;	

		RotateStaticCubesDownNoAnim();
		RotateMovingCubesDownNoAnim();

		// update the vertices for rendering

	}


	CorrectReversedIndex();
	/*
	enableCorrectAutoSnap = false;
	correctAutoSnap = false;
	autoSnapCounter = 0;
	*/
}

// not used, I believe
void RotateStaticCubesDownNoAnim()
{
	staticCubesAreRotating = true;

	// the initial rotation rotates several things instantly to final rotation before interpolation
	// must happen just once
	if( rotateStaticVerticesDown_firstIterationFinished == false )
	{
		// copy side vertices into interpolation arrays
		// Actually, use interpolation arrays as temp array to store copy of exact rotation
		rotateStaticVerticesDown_firstIterationFinished = true; // makes sure that this does not run again

		// when rotating the static cube, need to transform the cubes' positions as well as their display vertices
		srm.SetRotX( -1024 );

		side1TempMaterial->Copy( *side1Material ); // copy material b/c it's a pointer
		side2TempMaterial->Copy( *side2Material );
		side3TempMaterial->Copy( *side3Material );
		side4TempMaterial->Copy( *side4Material );
		side5TempMaterial->Copy( *side5Material );
		side6TempMaterial->Copy( *side6Material );

		PlaneSide planeTemp[6];
		// initialize temporary planes
		for( int i = 0; i < 6; i++ )
		{
			planeTemp[i] = PlaneSide();
			planeTemp[i] = plane[i];
		}

		// reassign planes
		for( int i = 0; i < 6; i++ )
		{
			if( plane[i].direction == 1 ) // 1 = 5
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 5 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes						
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 2 ) // 2 = 2
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 2 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 3 ) // 3 = 6
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 6 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 4 ) // 4 = 4
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 4 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 5 ) // 5 = 3
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 3 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
			else if( plane[i].direction == 6 ) // 6 = 1
			{
				for( int j = 0; j < 6; j++ )
				{
					if( planeTemp[j].direction == 1 )
					{
						plane[i].copyCountAndMat(planeTemp[j]); // reassign the planes
						break; // break out of planeTemp loop
					}
				}
			}
		}

		// ROTATE STATIC CUBES
		for( int i = 0; i < numStaticCubes; i++ )
		{
			cubeArray[i].position = srm.TransformVec( cubeArray[i].position ); // this only affects future collision
			switch( cubeArray[i].direction )
			{
			case 1:
				// 1 = 6
				cubeArray[i].direction = 6;
				break;
			case 2:
				// 2 = 2
				cubeArray[i].direction = 2;
				break;
			case 3:
				// 3 = 5
				cubeArray[i].direction = 5;
				break;
			case 4:
				// 4 = 4
				cubeArray[i].direction = 4;
				break;
			case 5:
				// 5 = 1
				cubeArray[i].direction = 1;
				break;
			case 6:
				// 6 = 3
				cubeArray[i].direction = 3;
				break;
			}
		}

		for( int i = 0; i < numStaticSides1Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide1VerticesTranslatedInterp[i*4 + j] = staticSide1VerticesTranslated[i*4+j]; // copy
				//staticSide1VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide1VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide1NormalsInterp[i*4+j] = staticSide1Normals[i*4+j]; // copy
				//staticSide1NormalsInterp[i*4+j] = srm.TransformVec( staticSide1NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides2Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide2VerticesTranslatedInterp[i*4 + j] = staticSide2VerticesTranslated[i*4+j]; // copy
				//staticSide2VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide2VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide2NormalsInterp[i*4+j] = staticSide2Normals[i*4+j]; // copy
				//staticSide2NormalsInterp[i*4+j] = srm.TransformVec( staticSide2NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides3Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide3VerticesTranslatedInterp[i*4 + j] = staticSide3VerticesTranslated[i*4+j]; // copy
				//staticSide3VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide3VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide3NormalsInterp[i*4+j] = staticSide3Normals[i*4+j]; // copy
				//staticSide3NormalsInterp[i*4+j] = srm.TransformVec( staticSide3NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides4Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide4VerticesTranslatedInterp[i*4 + j] = staticSide4VerticesTranslated[i*4+j]; // copy
				//staticSide4VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide4VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide4NormalsInterp[i*4+j] = staticSide4Normals[i*4+j]; // copy
				//staticSide4NormalsInterp[i*4+j] = srm.TransformVec( staticSide4NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides5Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide5VerticesTranslatedInterp[i*4 + j] = staticSide5VerticesTranslated[i*4+j]; // copy
				//staticSide5VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide5VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide5NormalsInterp[i*4+j] = staticSide5Normals[i*4+j]; // copy
				//staticSide5NormalsInterp[i*4+j] = srm.TransformVec( staticSide5NormalsInterp[i*4+j] ); // rotate
			}
		}
		for( int i = 0; i < numStaticSides6Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide6VerticesTranslatedInterp[i*4 + j] = staticSide6VerticesTranslated[i*4+j]; // copy
				//staticSide6VerticesTranslatedInterp[i*4 + j] = srm.TransformVec( staticSide6VerticesTranslatedInterp[i*4 + j] ); // rotate

				staticSide6NormalsInterp[i*4+j] = staticSide6Normals[i*4+j]; // copy
				//staticSide6NormalsInterp[i*4+j] = srm.TransformVec( staticSide6NormalsInterp[i*4+j] ); // rotate
			}
		}			
	}
		
	// set delta rotation for interpolation animation
	srm.SetRotX( -1*deltaYStaticRotation );


	// keeps track of how many degrees rotated
	cumulativeDeltaYRotation = 1024; // no interpolation, so finish right away

	// When rotation has stopped
	if( cumulativeDeltaYRotation == 1024 ) // stops rotation if limit of degrees-of-rotation is reached
	{
		rotateStaticVerticesDown = false;
		rotateStaticVerticesDown_firstIterationFinished = false;
		staticCubesAreRotating = false;
		cumulativeDeltaYRotation = 0; // reset the count			

		// resets the final rotation position b/c of slight rotation error with integer division
		// the Normals for the sides are rotated and kept because they are not refreshed based on original cube positions
		// If implemented that way, it would be very expensive to refresh through every static cube
		// side 1 = side 5
		for( int i = 0; i < numStaticSides1Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide1VerticesTranslated[i*4+j] = staticSide1VerticesTranslatedInterp[i*4 + j];
				staticSide1Normals[i*4+j] = staticSide1NormalsInterp[i*4+j];
			}
		}
		side1Material->Copy( *side5TempMaterial );

		// side 2 = side 2
		for( int i = 0; i < numStaticSides2Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide2VerticesTranslated[i*4+j] = staticSide2VerticesTranslatedInterp[i*4 + j];
				staticSide2Normals[i*4+j] = staticSide2NormalsInterp[i*4+j];
			}
		}
		side2Material->Copy( *side2TempMaterial );

		// side 3 = side 6
		for( int i = 0; i < numStaticSides3Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide3VerticesTranslated[i*4+j] = staticSide3VerticesTranslatedInterp[i*4 + j];
				staticSide3Normals[i*4+j] = staticSide3NormalsInterp[i*4+j];
			}
		}
		side3Material->Copy( *side6TempMaterial );

		// side 4 = side 4
		for( int i = 0; i < numStaticSides4Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide4VerticesTranslated[i*4+j] = staticSide4VerticesTranslatedInterp[i*4 + j];
				staticSide4Normals[i*4+j] = staticSide4NormalsInterp[i*4+j];
			}
		}
		side4Material->Copy( *side4TempMaterial );

		// side 5 = side 3
		for( int i = 0; i < numStaticSides5Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide5VerticesTranslated[i*4+j] = staticSide5VerticesTranslatedInterp[i*4 + j];
				staticSide5Normals[i*4+j] = staticSide5NormalsInterp[i*4+j];
			}
		}
		side5Material->Copy( *side3TempMaterial );

		// side 6 = side 1
		for( int i = 0; i < numStaticSides6Index; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				staticSide6VerticesTranslated[i*4+j] = staticSide6VerticesTranslatedInterp[i*4 + j];
				staticSide6Normals[i*4+j] = staticSide6NormalsInterp[i*4+j];
			}
		}
		side6Material->Copy( *side1TempMaterial );

		// STATIC CUBE VERTICES
		for( int i = 0; i < numStaticCubes; i++ )
		{
			for( int j = 0; j < 24; j++ )
			{
				// refresh the vertices based on cube positions
				cubeTranslated2[i*24 + j] = cubeVertices2[i*24+j] + cubeArray[i].position;

				// refresh the normals
				cubeNormals2[i*24 + j] = cubeNormals[j];
			}
		}
	} // end of reset, end of final destination of rotation
} // end of RotateStaticCubesDownNoAnim()

// not used, I believe
void RotateMovingCubesDownNoAnim()
{
	// prevents moving cubes from being updated and interrupting interpolation
	movingCubesAreRotating = true;

	// the initial rotation rotates several things instantly to final rotation before interpolation
	// must happen just once
	if( rotateMovingVerticesDown_firstIterationFinished == false )
	{
		// copy side vertices into interpolation arrays
		// Actually, use interpolation arrays as temp array to store copy of exact rotation
		rotateMovingVerticesDown_firstIterationFinished = true; // makes sure that this does not run again

		// when rotating the static cube, need to transform the cubes' positions as well as their display vertices
		srm.SetRotX( -1024 ); // set rotX for the up and down rotations

		// ROTATE MOVING CUBES
		for( int i = 0; i < numMovingCubesIndex; i++ )
		{
			// do NOT rotate faceside 2 and 4 cubes.
			if( cubeArrayMoving[i].direction != 2 && cubeArrayMoving[i].direction != 4 )
			{
				cubeArrayMoving[i].position = srm.TransformVec( cubeArrayMoving[i].position ); // this only affects future collision
				//cubeArrayMoving[i].initialPosition = srm.TransformVec( cubeArrayMoving[i].initialPosition );
			}

			// change their direction and also the shadow's directions
			switch( cubeArrayMoving[i].direction )
			{
			case 1:
				cubeArrayMoving[i].direction = 6;
				break;
			case 3:
				cubeArrayMoving[i].direction = 5;
				break;
			case 5:
				cubeArrayMoving[i].direction = 1;
				break;
			case 6:
				cubeArrayMoving[i].direction = 3;
				break;
			}
		}

		// ROTATE THE SHADOWS
		for( int i = 0; i < numShadowsIndex; i++ )
		{
			// do NOT rotate facesides 2 and 4. messes with boundaries
			if( shadowArray[i].direction != 2 && shadowArray[i].direction != 4 )
				shadowArray[i].position = srm.TransformVec( shadowArray[i].position );

			// set all their directions
			switch( shadowArray[i].direction )
			{
			case 1:
				shadowArray[i].setDirection( 6 ); // one BECOMES 2
				break;
			case 3:
				shadowArray[i].setDirection( 5 ); // setDirection also sets the vertices used for picking
				break;
			case 5:
				shadowArray[i].setDirection( 1 );
				break;
			case 6:
				shadowArray[i].setDirection( 3 );
				break;
			}

			// set their shadowVertices to correct one
			for( int j = 0; j < 24; j++ )
			{
				switch( shadowArray[i].direction )
				{
				case 1:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide1[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide1[j];
					break;
				case 3:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide3[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide3[j];
					break;
				case 5:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide5[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide5[j];
					break;
				case 6:
					shadowVertices[i*24 + j] = shadowVerticesFaceSide6[j];
					shadowVerticesTransparent[i*24 + j] = shadowVerticesTransparentFaceSide6[j];
					break;
				}
			} // end of shadow vertices correction
		} // end of looping through shadow array
			
		// UPDATE THE SHADOW GROUP BOUNDS
		UpdateShadowGroupBounds();
	} // end of if-statement for first iteration of Rotation

	// keeps track of how many degrees rotated
	cumulativeDeltaYRotation = 1024;

	// When rotation has stopped
	if( cumulativeDeltaYRotation == 1024 ) // stops rotation if limit of degrees-of-rotation is reached
	{
		rotateMovingVerticesDown = false;
		rotateMovingVerticesDown_firstIterationFinished = false;
		movingCubesAreRotating = false; // allows moving cubes to move again and shadows to be updated
		cumulativeDeltaYRotation = 0; // reset the count			
		
	} // end of reset, end of final destination of rotation
}// end of RotateMovingCubesDownNoAnim()

void ResetScoreAndLives()
{
	score = 0;
	numOfLives = 10;
	scoreLivesBonusBucket = 0;
	gameOver = false;
}

// resets to original state
void Reset()
{
	// QFI reset
	ResetAverageAPM();
	ResetCurrentAPM();
	ResetMultitasking();
	ResetMultitaskingCurrent();
	ResetEfficiency();
	ResetEfficiencyCurrent();

	worldX = 0;
	worldY = 0;
	savedX = 0;
	savedY = 0;
	
	skillIndex = 0;
	skillIndexCurrent = 0;
	performanceIndex = 0;
	performanceIndexCurrent = 0;

	percentComplete = 0.0;

	// reset perfect warp counter
	perfectWarpCount = 0;
	perfectWarped = false;
	checkPerfectWarped = false;

	playedGameOverVoiceOnce = false;
	playedDeathVoiceOnce = false;

	if( storyMode == true )
	{
		advanceToNextLevel = false;
		storyModeTotalDropsCurrent = 0;
	}

	showScore = false;
	showFuzziness = false;
	showSkillTitle = false;
	
	// remember to reset win count, plane counts, and other stuff
	// Actually, just easier to create a reset() function for planes

	// static cubes array, moving cubes array

	uniqueID = 1;

	// empty remaining arraysstar
	for( int i = 0; i < numMovingCubesIndex; i++ )
	{
		/* taken out on 12/07/11 to fix memory leak
		// this was added. a moving cube should have a fuzzy
		if( cubeArray[i].hasFuzzy == true )
		{
			delete cubeArrayMoving[i].fuzzyMaterial;	
			fuzzyCount--;
		}	
		else
		{
			delete cubeArrayMoving[i].fuzzyMaterial;
		}

		if( cubeArrayMoving[i].hasBomb == true )
		{
			cubeArrayMoving[i].bomb.Terminate();
		}
		*/

		removeMovingCubeAndTerminate( i );
		removeShadow( i );
		i--;
	}
	for( int i = numOriginalCubes; i < numStaticCubes; i++ )
	{
		removeStaticCube( i );
		i--;
	}

	// reset the fuzzy count
	fuzzyCount = 0;

	// reset all plane counts
	for( int i = 0; i < 6; i++ )
	{
		plane[i].reset();
	}
}

// rotates the cubes on the surface, as well as shadows. Basically rotate shadows
void RotateActiveShadows()
{
	Shadow *tempShadow = NULL;
	// set the selectedShadow
	int16 direction = getActiveFaceSide();
	for( int i = 0; i < numShadowsIndex; i++ )
	{
		if( shadowArray[i].direction == direction )
		{
			tempShadow = shadowArray + i;
			break;
		}
		else
		{
			tempShadow = NULL;
		}
	}
	
	if( tempShadow != NULL && tempShadow->shadowGroup->dropCubes != true )
	{
		// find the first cube and translate to center for each side		
		Shadow *baseShadow;

		// go through the shadow array and find the base shadow / first shadow of spawns
		for( int i = 0; i < numShadowsIndex; i++ )
		{
			if( shadowArray[i].direction == tempShadow->direction ) // finds first shadow that matches current shadow's direction
			{
				baseShadow = shadowArray + i;
				break; // stop searching once the shadow is found
			}
		}

		// record the base shadow's position to be used later
		CIwSVec3 currentPosition = baseShadow->position;
		CIwSVec3 deltaPosition;

		// translate the shadow back to center for each side
		switch( baseShadow->direction )
		{
		case 1: // faceside 1 is change in x, y
			if( numCubesWidth % 2 == 1 ) // if odd cubes
			{
				baseShadow->position.x = 0;
				baseShadow->position.y = 0;
			}
			else // if even cubes
			{
				baseShadow->position.x = s/2;
				baseShadow->position.y = s/2;
			}
			break;
		case 2:
			if( numCubesWidth % 2 == 1 ) // if odd cubes
			{
				baseShadow->position.z = 0;
				baseShadow->position.y = 0;
			}
			else // if even cubes
			{
				baseShadow->position.z = s/2;
				baseShadow->position.y = s/2;
			}
			break;
		case 3:
			if( numCubesWidth % 2 == 1 ) // if odd cubes
			{
				baseShadow->position.x = 0;
				baseShadow->position.y = 0;
			}
			else // if even cubes
			{
				baseShadow->position.x = s/2;
				baseShadow->position.y = s/2;
			}
			break;
		case 4:
			if( numCubesWidth % 2 == 1 ) // if odd cubes
			{
				baseShadow->position.z = 0;
				baseShadow->position.y = 0;
			}
			else // if even cubes
			{
				baseShadow->position.x = s/2;
				baseShadow->position.y = s/2;
			}
			break;
		case 5:
			if( numCubesWidth % 2 == 1 ) // if odd cubes
			{
				baseShadow->position.x = 0;
				baseShadow->position.z = 0;
			}
			else // if even cubes
			{
				baseShadow->position.x = s/2;
				baseShadow->position.z = s/2;
			}
			break;
		case 6:
			if( numCubesWidth % 2 == 1 ) // if odd cubes
			{
				baseShadow->position.x = 0;
				baseShadow->position.z = 0;
			}
			else // if even cubes
			{
				baseShadow->position.x = s/2;
				baseShadow->position.z = s/2;
			}
			break;
		}

		// find the deltadistance vector and apply to other shadows in same group / with same direction
		deltaPosition = currentPosition - baseShadow->position;
		bool foundBaseShadow = false;

		// Apply translation to other shadows moving back to original spawn position relative to face side
		for( int i = 0; i < numShadowsIndex; i++ )
		{
			// finds the shadows that AREN'T the base shadow. uses boolean to check
			if( shadowArray[i].direction == baseShadow->direction && foundBaseShadow == true )
			{
				// translate the other shadows
				shadowArray[i].position -= deltaPosition;
			}
			else if( shadowArray[i].direction == baseShadow->direction && foundBaseShadow == false )
			{
				// do nothing, and just keep searching again if found base shadow
				// base shadow is the FIRST shadow found
				foundBaseShadow = true;
			}
		}

		// rotate 90 degrees around the base shadow
		// This is done by multiplying the matrices...translate to origin, rotate, translate back
		CIwMat tOrigin, tBack, rotate; // translate to origin, translate back, rotate
		CIwMat rotationMatrix; // the final matrix
		rotationMatrix.SetIdentity();
		tOrigin.SetIdentity();
		tBack.SetIdentity();
		rotate.SetIdentity();

		tOrigin.t = CIwSVec3(0, 0, 0) - baseShadow->position;
		tBack.t = baseShadow->position;
		// the rotate axis is based on direction
		switch( baseShadow->direction )
		{
		case 1:
			rotate.SetRotZ( -1024 ); // set the rotation for 90 degrees
			break;
		case 2:
			rotate.SetRotX( 1024 );
			break;
		case 3:
			rotate.SetRotZ( 1024 ); 
			break;
		case 4:
			rotate.SetRotX( -1024 );
			break;
		case 5:
			rotate.SetRotY( -1024 );
			break;
		case 6:
			rotate.SetRotY( 1024 );
			break;
		}

		rotationMatrix = tOrigin * rotate * tBack;
		foundBaseShadow = false;
		// rotate the shadows that AREN'T the base shadow
		for( int i = 0; i < numShadowsIndex; i++ )
		{
			if( shadowArray[i].direction == baseShadow->direction && foundBaseShadow == true )
			{
				// rotate the shadow
				shadowArray[i].position = rotationMatrix.TransformVec( shadowArray[i].position );
				shadowArray[i].initialPosition = shadowArray[i].position;
			}
			else if( shadowArray[i].direction == baseShadow->direction && foundBaseShadow == false )
			{
				// do nothing to base shadow
				shadowArray[i].initialPosition = shadowArray[i].position;
				foundBaseShadow = true;
			}
		}

		// update the shadow group bounds
		UpdateShadowGroupBounds();
	}
}

void InitializeMenu()
{
	//cameraDepth = -s * ((-1.0 * width) / 272 + 268 / 17.0);
	
	cameraDepth = -s * 14;

	qfiMode = false;
	challengeMode = false;
	developerLevels = false;
	storyMode = false;
}

void InitializeLevel( int16 level, int16 phase )
{
	Reset();

	levelNumber = level;
	phaseNumber = phase;

	cameraDepth = -s * 7;// - s/2;
	worldX = 0;
	worldY = 0;
	savedX = 0;
	savedY = 0;

	// floating object initialization
	//testFO.Initialize( FloatingObject::EXTRA_LIFE );
	testFO.activated = false; // turn off test floating object

	// create UV Stream for plane sides
	for( int i = 0; i < numCubesWidth*numCubesHeight*numCubesLength; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			planesUVStream[i*4 + j] = sideUVStream[j];
		}
	}

	// Initialize side materials
	sideBlueMaterial->SetAlphaMode( CIwMaterial::NONE );
	sideBlueMaterial->SetColAmbient( 30, 60, 150, 255 ); // BLUE
	sideBlueMaterial->SetColDiffuse( 30, 60, 150, 255 );
	//sideBlueMaterial->SetColAmbient( 255, 255, 255, 255 );
	//sideBlueMaterial->SetColDiffuse( 255, 255, 255, 255 );
	sideBlueMaterial->SetColSpecular( 127,127,127 );
	sideBlueMaterial->SetSpecularPower( 15 );
	// set the texture
	//sideBlueMaterial->SetTexture( shadowTextureBlue );

	// draw the static side2
	sideRedMaterial->SetAlphaMode( CIwMaterial::NONE );
	sideRedMaterial->SetColAmbient( 100, 0, 0, 255 ); // RED
	sideRedMaterial->SetColDiffuse( 100, 0, 0, 255 );
	//sideRedMaterial->SetColAmbient( 255, 255, 255, 255 );
	//sideRedMaterial->SetColDiffuse( 255, 255, 255, 255 );
	sideRedMaterial->SetColSpecular( 127,127,127 );
	sideRedMaterial->SetSpecularPower( 15 );
	// set the texture
	//sideRedMaterial->SetTexture( shadowTextureRed );

	// draw the static side3
	sideGreenMaterial->SetAlphaMode( CIwMaterial::NONE );
	sideGreenMaterial->SetColAmbient( 0, 100, 0, 255 ); // GREEN
	sideGreenMaterial->SetColDiffuse( 0, 100, 0, 255 );
	//sideGreenMaterial->SetColAmbient( 255, 255, 255, 255 );
	//sideGreenMaterial->SetColDiffuse( 255, 255, 255, 255 );
	sideGreenMaterial->SetColSpecular( 127,127,127 );
	sideGreenMaterial->SetSpecularPower( 15 );
	// set the texture
	//sideGreenMaterial->SetTexture( shadowTextureGreen );
		
	// draw the static side4
	sideYellowMaterial->SetAlphaMode( CIwMaterial::NONE );
	sideYellowMaterial->SetColAmbient( 120, 120, 0, 255 ); // YELLOW
	sideYellowMaterial->SetColDiffuse( 120, 120, 0, 255 );
	//sideYellowMaterial->SetColAmbient( 255, 255, 255, 255 );
	//sideYellowMaterial->SetColDiffuse( 255, 255, 255, 255 );
	sideYellowMaterial->SetColSpecular( 127,127,127 );
	sideYellowMaterial->SetSpecularPower( 15 );
	// set the texture
	//sideYellowMaterial->SetTexture( shadowTextureYellow );

	// draw the static side5
	sidePurpleMaterial->SetAlphaMode( CIwMaterial::NONE );
	sidePurpleMaterial->SetColAmbient( 80, 0, 100, 255 ); // PURPLE
	sidePurpleMaterial->SetColDiffuse( 80, 0, 100, 255 );
	//sidePurpleMaterial->SetColAmbient( 255, 255, 255, 255 );
	//sidePurpleMaterial->SetColDiffuse( 255, 255, 255, 255 );
	sidePurpleMaterial->SetColSpecular( 127,127,127 );
	sidePurpleMaterial->SetSpecularPower( 15 );
	// set the texture
	//sidePurpleMaterial->SetTexture( shadowTexturePurple );

	// draw the static side6
	sideOrangeMaterial->SetAlphaMode( CIwMaterial::NONE );
	sideOrangeMaterial->SetColAmbient( 100, 60, 0, 255 ); // ORANGE
	sideOrangeMaterial->SetColDiffuse( 100, 60, 0, 255 );
	//sideOrangeMaterial->SetColDiffuse( 110, 70, 10, 255 );
	//sideOrangeMaterial->SetColAmbient( 255, 255, 255, 255 );
	//sideOrangeMaterial->SetColDiffuse( 255, 255, 255, 255 );
	sideOrangeMaterial->SetColSpecular( 127,127,127 );
	sideOrangeMaterial->SetSpecularPower( 15 );
	// set the texture
	//sideOrangeMaterial->SetTexture( shadowTextureOrange );

	// set the null material
	nullMaterial->SetAlphaMode( CIwMaterial::ALPHA_ADD );
	nullMaterial->SetAlphaMode( CIwMaterial::ALPHA_NONE );
	nullMaterial->SetColAmbient( 50, 50, 50, 50 );
	nullMaterial->SetColDiffuse( 50, 50, 50, 50 );
	//sideOrangeMaterial->SetColSpecular( 127,127,127 );
	//sideOrangeMaterial->SetSpecularPower( 15 );
	
	if( level == 1 )
	{	
		// order of colors are:
		// blue, red, purple, orange, green, yellow
		side1Material->Copy( *sideBlueMaterial );
		side2Material->Copy( *sideRedMaterial );
		side3Material->Copy( *sidePurpleMaterial );
		side4Material->Copy( *sideOrangeMaterial );
		side5Material->Copy( *sideGreenMaterial );
		side6Material->Copy( *sideYellowMaterial );
		
		// initialize plane sides
		for( int i = 0; i < 6; i++ )
		{
			if( i == 0 )
			{
				plane[i] = PlaneSide( 1, Cube::BLUE );
				plane[i].active = true; // used to help determine cubes spawned for corresp. color
			}
			if( i == 1 )
			{
				plane[i] = PlaneSide( 2, Cube::RED );
				plane[i].active = false; // used to help determine cubes spawned for corresp. color
			}
			if( i == 2 )
			{
				plane[i] = PlaneSide( 3,Cube:: PURPLE );
				plane[i].active = false;
			}
			if( i == 3 )
			{
				plane[i] = PlaneSide( 4, Cube::ORANGE );
				plane[i].active = false;
			}
			if( i == 4 )
			{
				plane[i] = PlaneSide( 5, Cube::GREEN );
				plane[i].active = false;
			}
			if( i == 5 )
			{
				plane[i] = PlaneSide( 6, Cube::YELLOW );
				plane[i].active = false;
			}
		}
	}// end of if level number == 1
	else if( level == 2 )
	{
		INITIAL_SPEED = 600;

		side1Material->Copy( *sideBlueMaterial );
		side2Material->Copy( *sideRedMaterial );
		side3Material->Copy( *sidePurpleMaterial );
		side4Material->Copy( *sideOrangeMaterial );
		side5Material->Copy( *sideGreenMaterial );
		side6Material->Copy( *sideYellowMaterial );

		// initialize plane sides
		for( int i = 0; i < 6; i++ )
		{
			if( i == 0 )
			{
				plane[i] = PlaneSide( 1, Cube::BLUE );
				plane[i].active = true; // used to help determine cubes spawned for corresp. color
			}
			if( i == 1 )
			{
				plane[i] = PlaneSide( 2, Cube::RED );
				plane[i].active = false; // used to help determine cubes spawned for corresp. color
			}
			if( i == 2 )
			{
				plane[i] = PlaneSide( 3,Cube:: PURPLE );
				plane[i].active = false;
			}
			if( i == 3 )
			{
				plane[i] = PlaneSide( 4, Cube::ORANGE );
				plane[i].active = false;
			}
			if( i == 4 )
			{
				plane[i] = PlaneSide( 5, Cube::GREEN );
				plane[i].active = true;
			}
			if( i == 5 )
			{
				plane[i] = PlaneSide( 6, Cube::YELLOW );
				plane[i].active = false;
			}
		}
	}// end of level number == 3
	else if( level == 3 )
	{
		INITIAL_SPEED = 600;

		side1Material->Copy( *sideBlueMaterial );
		side2Material->Copy( *sideRedMaterial );
		side3Material->Copy( *sidePurpleMaterial );
		side4Material->Copy( *sideOrangeMaterial );
		side5Material->Copy( *sideGreenMaterial );
		side6Material->Copy( *sideYellowMaterial );

		// initialize plane sides
		for( int i = 0; i < 6; i++ )
		{
			if( i == 0 )
			{
				plane[i] = PlaneSide( 1, Cube::BLUE );
				plane[i].active = true; // used to help determine cubes spawned for corresp. color
			}
			if( i == 1 )
			{
				plane[i] = PlaneSide( 2, Cube::RED );
				plane[i].active = true; // used to help determine cubes spawned for corresp. color
			}
			if( i == 2 )
			{
				plane[i] = PlaneSide( 3,Cube:: PURPLE );
				plane[i].active = false;
			}
			if( i == 3 )
			{
				plane[i] = PlaneSide( 4, Cube::ORANGE );
				plane[i].active = false;
			}
			if( i == 4 )
			{
				plane[i] = PlaneSide( 5, Cube::GREEN );
				plane[i].active = false;
			}
			if( i == 5 )
			{
				plane[i] = PlaneSide( 6, Cube::YELLOW );
				plane[i].active = false;
			}
		}
	}// end of level number == 4
	else if( level == 4 )
	{
		INITIAL_SPEED = 600;

		side1Material->Copy( *sideBlueMaterial );
		side2Material->Copy( *sideRedMaterial );
		side3Material->Copy( *sidePurpleMaterial );
		side4Material->Copy( *sideOrangeMaterial );
		side5Material->Copy( *sideGreenMaterial );
		side6Material->Copy( *sideYellowMaterial );

		// initialize plane sides
		for( int i = 0; i < 6; i++ )
		{
			if( i == 0 )
			{
				plane[i] = PlaneSide( 1, Cube::BLUE );
				plane[i].active = true; // used to help determine cubes spawned for corresp. color
			}
			if( i == 1 )
			{
				plane[i] = PlaneSide( 2, Cube::RED );
				plane[i].active = true; // used to help determine cubes spawned for corresp. color
			}
			if( i == 2 )
			{
				plane[i] = PlaneSide( 3,Cube:: PURPLE );
				plane[i].active = false;
			}
			if( i == 3 )
			{
				plane[i] = PlaneSide( 4, Cube::ORANGE );
				plane[i].active = false;
			}
			if( i == 4 )
			{
				plane[i] = PlaneSide( 5, Cube::GREEN );
				plane[i].active = false;
			}
			if( i == 5 )
			{
				plane[i] = PlaneSide( 6, Cube::YELLOW );
				plane[i].active = false;
			}
		}
	}// end of level number == 5
}

void InitializeTutorial( int16 tNumber )
{
	Reset();

	tutorialNumber = tNumber;
	tutorialSpawnNumber = 0; // resets the spawning pattern for SpawnMovingSets

	cameraDepth = -s * 7;// - s/2;
	worldX = 0;
	worldY = 0;
	savedX = 0;
	savedY = 0;

	INITIAL_SPEED = 400;

	// create UV Stream for plane sides
	for( int i = 0; i < numCubesWidth*numCubesHeight*numCubesLength; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			planesUVStream[i*4 + j] = sideUVStream[j];
		}
	}

	// Initialize side materials
	sideBlueMaterial->SetAlphaMode( CIwMaterial::NONE );
	sideBlueMaterial->SetColAmbient( 30, 60, 150, 255 ); // BLUE
	sideBlueMaterial->SetColDiffuse( 30, 60, 150, 255 );
	//sideBlueMaterial->SetColAmbient( 255, 255, 255, 255 );
	//sideBlueMaterial->SetColDiffuse( 255, 255, 255, 255 );
	sideBlueMaterial->SetColSpecular( 127,127,127 );
	sideBlueMaterial->SetSpecularPower( 15 );
	// set the texture
	//sideBlueMaterial->SetTexture( shadowTextureBlue );

	// draw the static side2
	sideRedMaterial->SetAlphaMode( CIwMaterial::NONE );
	sideRedMaterial->SetColAmbient( 100, 0, 0, 255 ); // RED
	sideRedMaterial->SetColDiffuse( 100, 0, 0, 255 );
	//sideRedMaterial->SetColAmbient( 255, 255, 255, 255 );
	//sideRedMaterial->SetColDiffuse( 255, 255, 255, 255 );
	sideRedMaterial->SetColSpecular( 127,127,127 );
	sideRedMaterial->SetSpecularPower( 15 );
	// set the texture
	//sideRedMaterial->SetTexture( shadowTextureRed );

	// draw the static side3
	sideGreenMaterial->SetAlphaMode( CIwMaterial::NONE );
	sideGreenMaterial->SetColAmbient( 0, 100, 0, 255 ); // GREEN
	sideGreenMaterial->SetColDiffuse( 0, 100, 0, 255 );
	//sideGreenMaterial->SetColAmbient( 255, 255, 255, 255 );
	//sideGreenMaterial->SetColDiffuse( 255, 255, 255, 255 );
	sideGreenMaterial->SetColSpecular( 127,127,127 );
	sideGreenMaterial->SetSpecularPower( 15 );
	// set the texture
	//sideGreenMaterial->SetTexture( shadowTextureGreen );
		
	// draw the static side4
	sideYellowMaterial->SetAlphaMode( CIwMaterial::NONE );
	sideYellowMaterial->SetColAmbient( 120, 120, 0, 255 ); // YELLOW
	sideYellowMaterial->SetColDiffuse( 120, 120, 0, 255 );
	//sideYellowMaterial->SetColAmbient( 255, 255, 255, 255 );
	//sideYellowMaterial->SetColDiffuse( 255, 255, 255, 255 );
	sideYellowMaterial->SetColSpecular( 127,127,127 );
	sideYellowMaterial->SetSpecularPower( 15 );
	// set the texture
	//sideYellowMaterial->SetTexture( shadowTextureYellow );

	// draw the static side5
	sidePurpleMaterial->SetAlphaMode( CIwMaterial::NONE );
	sidePurpleMaterial->SetColAmbient( 80, 0, 100, 255 ); // PURPLE
	sidePurpleMaterial->SetColDiffuse( 80, 0, 100, 255 );
	//sidePurpleMaterial->SetColAmbient( 255, 255, 255, 255 );
	//sidePurpleMaterial->SetColDiffuse( 255, 255, 255, 255 );
	sidePurpleMaterial->SetColSpecular( 127,127,127 );
	sidePurpleMaterial->SetSpecularPower( 15 );
	// set the texture
	//sidePurpleMaterial->SetTexture( shadowTexturePurple );

	// draw the static side6
	sideOrangeMaterial->SetAlphaMode( CIwMaterial::NONE );
	sideOrangeMaterial->SetColAmbient( 110, 70, 10, 255 ); // ORANGE
	sideOrangeMaterial->SetColDiffuse( 110, 70, 10, 255 );
	//sideOrangeMaterial->SetColAmbient( 255, 255, 255, 255 );
	//sideOrangeMaterial->SetColDiffuse( 255, 255, 255, 255 );
	sideOrangeMaterial->SetColSpecular( 127,127,127 );
	sideOrangeMaterial->SetSpecularPower( 15 );
	// set the texture
	//sideOrangeMaterial->SetTexture( shadowTextureOrange );

	// set the null material
	nullMaterial->SetAlphaMode( CIwMaterial::ALPHA_ADD );
	nullMaterial->SetColAmbient( 50, 50, 50, 50 );
	nullMaterial->SetColDiffuse( 50, 50, 50, 50 );
	//nullMaterial->SetColAmbient( 150, 150, 150, 150 );
	//nullMaterial->SetColDiffuse( 150, 150, 150, 150 );
	//sideOrangeMaterial->SetColSpecular( 127,127,127 );
	//sideOrangeMaterial->SetSpecularPower( 15 );
	
	if( tutorialNumber == 1 )
	{	
		// order of colors are:
		// blue, red, purple, orange, green, yellow
		side1Material->Copy( *sideBlueMaterial );
		side2Material->Copy( *sideRedMaterial );
		side3Material->Copy( *sidePurpleMaterial );
		side4Material->Copy( *sideOrangeMaterial );
		side5Material->Copy( *sideGreenMaterial );
		side6Material->Copy( *sideYellowMaterial );
		
		// initialize plane sides
		for( int i = 0; i < 6; i++ )
		{
			if( i == 0 )
			{
				plane[i] = PlaneSide( 1, Cube::BLUE );
				plane[i].active = true; // used to help determine cubes spawned for corresp. color
			}
			if( i == 1 )
			{
				plane[i] = PlaneSide( 2, Cube::RED );
				plane[i].active = false; // used to help determine cubes spawned for corresp. color
			}
			if( i == 2 )
			{
				plane[i] = PlaneSide( 3,Cube:: PURPLE );
				plane[i].active = false;
			}
			if( i == 3 )
			{
				plane[i] = PlaneSide( 4, Cube::ORANGE );
				plane[i].active = false;
			}
			if( i == 4 )
			{
				plane[i] = PlaneSide( 5, Cube::GREEN );
				plane[i].active = false;
			}
			if( i == 5 )
			{
				plane[i] = PlaneSide( 6, Cube::YELLOW );
				plane[i].active = false;
			}
		}
	}// end of if level number == 1
}

void InitializeDifficulty( int16 d )
{
	int32 heapUsed = s3eMemoryGetInt(S3E_MEMORY_USED); // Free memory minus heap size


	/* Chart
	difficulty  planeSpawn  cubeSpawn		NumOfSides NumOfCubes
	1			SINGLE_RAN	SINGLE_RAN		1			1
	2			DOUBLE_ADJ	SINGLE_RAN		2			1
	3			DOUBLE_ADJ	DOUBLE_INC - 3	2			2
	4			DOUBLE_RAN	DOUBLE_RAN		2			2
	5			TRIPLE_RAN	DOUBLE_RAN		3			2
	6			QUAD_RAN	DOUBLE_RAN		4			2
	7			TRIPLE_RAN	TRIPLE_INC - 7	3			3
	8			TRIPLE_RAN	TRIPLE_RAN		3			
	9			QUAD_RAN	TRIPLE_RAN		4
	10			QUIN_RAN	TRIPLE_RAN		5
	11			SEXTUP_RAN	TRIPLE_RAN		6
	12			QUAD_RAN	QUAD_INC - 12	4
	13			QUAD_RAN	QUAD_RAN		4	
	14			QUIN_RAN	QUAD_RAN		5
	15			SEXTUP_RAN	QUAD_RAN		6	
	16			QUIN_RAN	QUIN_INC - 16	5
	17			QUIN_RAN	QUIN_RAN		5
	18			SEXTUP		QUIN_RAN		6
	19			SEXTUP		SEXTUP_INC - 19	6
	20			SEXTUP		SEXTUP_RAN		6
	*/

	// show adwhirl
	if( hasAdWhirl )
	{
		// s3eAdWhirlShow();
	}

	difficulty = d;

	switch( difficulty )
	{
	case 1:
		break;
	}

	Reset();
	ResetQFIVariables();

	// difficulty cap for QFI
	qfiDifficultyCap = 20;

	// all
	spawnBombMode = false;
	spawnBomb = false;
	playingStory = true;
	savedAtScoreScreen = false;
	playedFirstInterimCinematic = false;
	playedSecondInterimCinematic = false;
	advanceToNextLevel = false;
	spawningSetCounter = 1; // this allows buttons to be immediately pressable. 
	
	//planeSpawning = QUINTUPLE_RANDOM;
	//cubeSpawning = QUINTUPLE_INCOLOR;
	if( storyMode == true )
	{
		episode = d;
		levelNumber = 1;
		bombFrequency = 1;

		if( episode == 1 )
		{
			if( startAtCheckpoint == false )
			{
				ResetScoreAndLives();
			}

			planeSpawning = SINGLE_RANDOM;
			cubeSpawning = SINGLE_RANDOM;
			targetDifficulty = difficulty;
			targetPlaneSpawning = planeSpawning;
			targetCubeSpawning = cubeSpawning;
			targetDifficultyReached = true;
			INITIAL_SPEED = 400;
			qfiDifficultyCap = 3;
			qfiMode = true;

			// tutorial elements
			for( int i = 0; i < NUM_OF_TUTORIAL_MESSAGES; i++ )
			{
				tutorialSprites[i].setStartingAlpha( 0 );
				tutorialSprites[i].setEndingAlpha( 0 );
				tutorialSprites[i].setAlphaInterpolationTime( tutorialInterpolationTime );

				showTutorialSprites[i] = false;
				setShowTutorialSprites[i] = false;
			}

			triggeredShowTutorialTouchDrag = false;
			triggeredHideTutorialTouchDrag = false;
			triggeredShowTutorialTapDrop = false;
			triggeredHideTutorialTapDrop = false;
			triggeredShowTutorialRotate = false;
			triggeredHideTutorialRotate = false;
			triggeredShowTutorialCompleteSide = false;
			triggeredHideTutorialCompleteSide = false;
			triggeredShowTutorialDragSpace = false;
			triggeredHideTutorialDragSpace = false;
			triggeredShowTutorialPerfectClear = false;
			triggeredHideTutorialPerfectClear = false;
			triggeredShowTutorialShift = false;
			triggeredHideTutorialShift = false;
			triggeredShowTutorialDefuseBomb1 = false;
			triggeredHideTutorialDefuseBomb1 = false;
			triggeredShowTutorialDefuseBomb2 = false;
			triggeredHideTutorialDefuseBomb2 = false;
			triggeredShowTutorialDoNotDie = false;
			triggeredHideTutorialDoNotDie = false;
			triggeredShowTutorialMatchColors = false;
			triggeredHideTutorialMatchColors = false;
			triggeredShowTutorialDoNotStack = false;
			triggeredHideTutorialDoNotStack = false;

			numOfTutorialDropsCurrent = 0;
			numOfTutorialRotates = 0;
			tutorialBombDefuseCount = 0;
			tutorialDragSpaceCount = 0;
			tutorialDragSpaceShown = false;
			tutorialPlaneShiftCount = 0;
			tutorialShiftEnable = true;
			enableFirstSpawning = false; // triggered true when hide tutorial match color callback executes
			enableTutorialPerfectClear = false;
			enableTutorialDoNotStack = false;

			if( startAtCheckpoint == true )
			{ 
				levelNumber = 4;
				planeSpawning = QUADRUPLE_RANDOM;
				cubeSpawning = DOUBLE_RANDOM;
				targetDifficulty = difficulty;
				targetPlaneSpawning = planeSpawning;
				targetCubeSpawning = cubeSpawning;
				targetDifficultyReached = true;
				INITIAL_SPEED = 600;
				qfiMode = false;

				spawnBombMode = true;
				spawnBomb = true;
				bombFrequency = 1;
			}
		}
		else if( episode == 2 )
		{
			
			planeSpawning = TRIPLE_RANDOM;
			cubeSpawning = DOUBLE_RANDOM;
			targetDifficulty = difficulty;
			targetPlaneSpawning = planeSpawning;
			targetCubeSpawning = cubeSpawning;
			targetDifficultyReached = true;
			INITIAL_SPEED = 400;
			qfiDifficultyCap = 3;
			qfiMode = false;

			
			if( startAtCheckpoint == true )
			{ 
				levelNumber = 4;
				planeSpawning = TRIPLE_RANDOM;
				cubeSpawning = TRIPLE_RANDOM;
				targetDifficulty = difficulty;
				targetPlaneSpawning = planeSpawning;
				targetCubeSpawning = cubeSpawning;
				targetDifficultyReached = true;
				INITIAL_SPEED = 600;
				qfiMode = false;

				spawnBombMode = true;
				spawnBomb = true;
				bombFrequency = 2;
			}
			
		}
		else if( episode == 3 )
		{
			// this should probably not be here
			/*
			if( sphereLoaded[2] == false )
			{
				windSystem.Initialize( s );
			}
			*/

			worldY = 1024;
			savedY = 1024;

			planeSpawning = QUADRUPLE_RANDOM;
			cubeSpawning = TRIPLE_RANDOM;
			targetDifficulty = difficulty;
			targetPlaneSpawning = planeSpawning;
			targetCubeSpawning = cubeSpawning;
			targetDifficultyReached = true;
			INITIAL_SPEED = 400;
			qfiDifficultyCap = 3;
			qfiMode = false;

			if( startAtCheckpoint == true )
			{ 
				levelNumber = 4;
				planeSpawning = QUADRUPLE_RANDOM;
				cubeSpawning = QUADRUPLE_RANDOM;
				targetDifficulty = difficulty;
				targetPlaneSpawning = planeSpawning;
				targetCubeSpawning = cubeSpawning;
				targetDifficultyReached = true;
				INITIAL_SPEED = 600;
				qfiMode = false;

				spawnBombMode = true;
				spawnBomb = true;
				bombFrequency = 2;
			}

			fallMatrix.SetIdentity();
			fallMatrix.SetTrans( CIwSVec3(0, 0, s*12) );

			ep3Frames = 0;
			ep3Seconds = 170;
			ep3TimerStart = false; // turn on when episode 7 loads, by next button

		}
		else if( episode == 4 )
		{
			planeSpawning = QUINTUPLE_RANDOM;
			cubeSpawning = QUADRUPLE_INCOLOR;
			targetDifficulty = difficulty;
			targetPlaneSpawning = planeSpawning;
			targetCubeSpawning = cubeSpawning;
			targetDifficultyReached = true;
			INITIAL_SPEED = 600;
			qfiDifficultyCap = 3;
			qfiMode = false;

			spawnBombMode = true;
			spawnBomb = true;
			bombType = WTFBOMB;
			bombFrequency = 1;
		}
		else if( episode == 5 )
		{
			planeSpawning = QUINTUPLE_RANDOM;
			cubeSpawning = QUINTUPLE_INCOLOR;
			targetDifficulty = difficulty;
			targetPlaneSpawning = planeSpawning;
			targetCubeSpawning = cubeSpawning;
			targetDifficultyReached = true;
			INITIAL_SPEED = 600;
			qfiDifficultyCap = 3;
			qfiMode = false;

			spawnBombMode = true;
			spawnBomb = true;
			bombType = WTFBOMB;
			bombFrequency = 1;
		}
		else if( episode == 6 )
		{
			planeSpawning = SEXTUPLE;
			cubeSpawning = SEXTUPLE_RANDOM;
			targetDifficulty = difficulty;
			targetPlaneSpawning = planeSpawning;
			targetCubeSpawning = cubeSpawning;
			targetDifficultyReached = true;
			INITIAL_SPEED = 800;
			qfiDifficultyCap = 3;
			qfiMode = false;

			spawnBombMode = true;
			spawnBomb = true;
			bombType = WTFBOMB;
			bombFrequency = 1;
			
		}


		// set the drop limits for each level
		for( int i = 0; i < MAX_LEVELS; i++ )
		{
			if( episode == 1 )
			{
				storyModeRequiredDrops[i] = 18 + i*9; // 64 drops is about 1 minutes per level
			}
			else if( episode == 2 )
			{
				storyModeRequiredDrops[i] = 27 + i*9; // 64 drops is about 1 minutes per level
			}
			else if( episode == 3 )
			{
				storyModeRequiredDrops[i] = 36 + i*9; // 64 drops is about 1 minutes per level
			}
			else if( episode == 4 )
			{
				storyModeRequiredDrops[i] = 45 + i*9; // 64 drops is about 1 minutes per level
			}
			else if( episode == 5 )
			{
				storyModeRequiredDrops[i] = 54 + i*9; // 64 drops is about 1 minutes per level
			}
			else if( episode == 6 )
			{
				storyModeRequiredDrops[i] = 63 + i*9; // 64 drops is about 1 minutes per level
			}
		} // end of for loop going through each storyModeReqDrops

		// testing - remove after done with testing
		/*
		if( targetEpisode >= 1 )
		{
			for( int i = 0; i < 10; i++ )
			{
				storyModeRequiredDrops[i] = 1;
			}
		}
		*/

	} // end of if storyMode == true
	else if( qfiMode == true )
	{
		planeSpawning = SINGLE_RANDOM;
		cubeSpawning = SINGLE_RANDOM;
		targetDifficulty = difficulty;
		targetPlaneSpawning = planeSpawning;
		targetCubeSpawning = cubeSpawning;
		targetDifficultyReached = true;
		INITIAL_SPEED = 400;		
		numOfLives = 10;
		spawnBombMode = false;
	}
	else if( developerLevels == true )
	{
		numOfLives = 15;
	}
	else if( challengeMode == true )
	{
		// difficulty and target variables. are ignored

		// set speed
		INITIAL_SPEED = 200;
		cmSpeedLevel = 1;
		numOfLives = 3;

		// set the required num of drops
		for( int i = 0; i < 20; i++ )
		{
			// make the number of required drops quadratic
			cmNumOfRequiredDrops[i] = 10 + (int16)(.25*i*i);
			/*
			switch( i )
			{
				
			case 0:
				cmNumOfRequiredDrops[i] = 10;
				break;
			case 1:
				cmNumOfRequiredDrops[i] = 
				break;
			case 2:
				cmNumOfRequiredDrops[i] =
				break;
			case 3:
				cmNumOfRequiredDrops[i] =
				break;
			case 4:
				cmNumOfRequiredDrops[i] = 50;
				break;
			case 5:
				cmNumOfRequiredDrops[i] =
				break;
			case 6:
				cmNumOfRequiredDrops[i] =
				break;
			case 7:
				cmNumOfRequiredDrops[i] =
				break;
			case 8:
				cmNumOfRequiredDrops[i] =
				break;
			case 9:
				cmNumOfRequiredDrops[i] = 100;
				break;
			case 10:
				cmNumOfRequiredDrops[i] =
				break;
			case 11:
				cmNumOfRequiredDrops[i] =
				break;
			case 12:
				cmNumOfRequiredDrops[i] =
				break;
			case 13:
				cmNumOfRequiredDrops[i] =
				break;
			case 14:
				cmNumOfRequiredDrops[i] =
				break;
			case 15:
				cmNumOfRequiredDrops[i] =
				break;
			case 16:
				cmNumOfRequiredDrops[i] =
				break;
			case 17:
				cmNumOfRequiredDrops[i] =
				break;
			case 18:
				cmNumOfRequiredDrops[i] =
				break;
			case 19:
				cmNumOfRequiredDrops[i] = 200;
				break;
				
			}*/ // end of switch statement
		} // end of for loop
	} // end of if-challenge mode
		
	// this is formula for zoom depth when depth = s*7 at height = 320, and depth = s*5 at height = 768
	// set camera depth
	//cameraDepth = -s * (-1.0 * height / 300 + 59 / 7.0);
	
	cameraDepth = -s * 7;
	

	// floating object initialization
	//testFO.Initialize( FloatingObject::EXTRA_LIFE );
	testFO.activated = false; // turn off test floating object

	// create UV Stream for plane sides
	for( int i = 0; i < numCubesWidth*numCubesHeight*numCubesLength; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			planesUVStream[i*4 + j] = sideUVStream[j];
		}
	}

	// Initialize side materials
	sideBlueMaterial->SetAlphaMode( CIwMaterial::NONE );
	sideBlueMaterial->SetColAmbient( 30, 60, 150, 255 ); // BLUE
	sideBlueMaterial->SetColDiffuse( 30, 60, 150, 255 );
	//sideBlueMaterial->SetColAmbient( 255, 255, 255, 255 );
	//sideBlueMaterial->SetColDiffuse( 255, 255, 255, 255 );
	sideBlueMaterial->SetColSpecular( 127,127,127 );
	sideBlueMaterial->SetSpecularPower( 15 );
	// set the texture
	//sideBlueMaterial->SetTexture( shadowTextureBlue );

	// draw the static side2
	sideRedMaterial->SetAlphaMode( CIwMaterial::NONE );
	sideRedMaterial->SetColAmbient( 100, 0, 0, 255 ); // RED
	sideRedMaterial->SetColDiffuse( 100, 0, 0, 255 );
	//sideRedMaterial->SetColAmbient( 255, 255, 255, 255 );
	//sideRedMaterial->SetColDiffuse( 255, 255, 255, 255 );
	sideRedMaterial->SetColSpecular( 127,127,127 );
	sideRedMaterial->SetSpecularPower( 15 );
	// set the texture
	//sideRedMaterial->SetTexture( shadowTextureRed );

	// draw the static side3
	sideGreenMaterial->SetAlphaMode( CIwMaterial::NONE );
	sideGreenMaterial->SetColAmbient( 0, 100, 0, 255 ); // GREEN
	sideGreenMaterial->SetColDiffuse( 0, 100, 0, 255 );
	//sideGreenMaterial->SetColAmbient( 255, 255, 255, 255 );
	//sideGreenMaterial->SetColDiffuse( 255, 255, 255, 255 );
	sideGreenMaterial->SetColSpecular( 127,127,127 );
	sideGreenMaterial->SetSpecularPower( 15 );
	// set the texture
	//sideGreenMaterial->SetTexture( shadowTextureGreen );
		
	// draw the static side4
	sideYellowMaterial->SetAlphaMode( CIwMaterial::NONE );
	sideYellowMaterial->SetColAmbient( 120, 120, 0, 255 ); // YELLOW
	sideYellowMaterial->SetColDiffuse( 120, 120, 0, 255 );
	//sideYellowMaterial->SetColAmbient( 255, 255, 255, 255 );
	//sideYellowMaterial->SetColDiffuse( 255, 255, 255, 255 );
	sideYellowMaterial->SetColSpecular( 127,127,127 );
	sideYellowMaterial->SetSpecularPower( 15 );
	// set the texture
	//sideYellowMaterial->SetTexture( shadowTextureYellow );

	// draw the static side5
	sidePurpleMaterial->SetAlphaMode( CIwMaterial::NONE );
	sidePurpleMaterial->SetColAmbient( 80, 0, 100, 255 ); // PURPLE
	sidePurpleMaterial->SetColDiffuse( 80, 0, 100, 255 );
	//sidePurpleMaterial->SetColAmbient( 255, 255, 255, 255 );
	//sidePurpleMaterial->SetColDiffuse( 255, 255, 255, 255 );
	sidePurpleMaterial->SetColSpecular( 127,127,127 );
	sidePurpleMaterial->SetSpecularPower( 15 );
	// set the texture
	//sidePurpleMaterial->SetTexture( shadowTexturePurple );

	// draw the static side6
	sideOrangeMaterial->SetAlphaMode( CIwMaterial::NONE );
	sideOrangeMaterial->SetColAmbient( 100, 60, 0, 255 ); // ORANGE
	sideOrangeMaterial->SetColDiffuse( 100, 60, 0, 255 );
	//sideOrangeMaterial->SetColDiffuse( 110, 70, 10, 255 );
	//sideOrangeMaterial->SetColAmbient( 255, 255, 255, 255 );
	//sideOrangeMaterial->SetColDiffuse( 255, 255, 255, 255 );
	sideOrangeMaterial->SetColSpecular( 127,127,127 );
	sideOrangeMaterial->SetSpecularPower( 15 );
	// set the texture
	//sideOrangeMaterial->SetTexture( shadowTextureOrange );

	// set the null material
	nullMaterial->SetAlphaMode( CIwMaterial::ALPHA_ADD );
	nullMaterial->SetAlphaMode( CIwMaterial::ALPHA_NONE );
	nullMaterial->SetColAmbient( 50, 50, 50, 255 );
	nullMaterial->SetColDiffuse( 50, 50, 50, 255 );
	//sideOrangeMaterial->SetColSpecular( 127,127,127 );
	//sideOrangeMaterial->SetSpecularPower( 15 );

	// order of colors are:
	// blue, red, purple, orange, green, yellow

	side1Material->Copy( *sideBlueMaterial );
	side2Material->Copy( *sideRedMaterial );
	side3Material->Copy( *sidePurpleMaterial );
	side4Material->Copy( *sideOrangeMaterial );
	side5Material->Copy( *sideGreenMaterial );
	side6Material->Copy( *sideYellowMaterial );

	// deactivate all plane sides and set color
	for( int i = 0; i < 6; i++ )
	{
		if( i == 0 )
		{
			plane[i] = PlaneSide( 1, Cube::BLUE );
			plane[i].active = false; // used to help determine cubes spawned for corresp. color
		}
		if( i == 1 )
		{
			plane[i] = PlaneSide( 2, Cube::RED );
			plane[i].active = false; // used to help determine cubes spawned for corresp. color
		}
		if( i == 2 )
		{
			plane[i] = PlaneSide( 3,Cube:: PURPLE );
			plane[i].active = false;
		}
		if( i == 3 )
		{
			plane[i] = PlaneSide( 4, Cube::ORANGE );
			plane[i].active = false;
		}
		if( i == 4 )
		{
			plane[i] = PlaneSide( 5, Cube::GREEN );
			plane[i].active = false;
		}
		if( i == 5 )
		{
			plane[i] = PlaneSide( 6, Cube::YELLOW );
			plane[i].active = false;
		}
	}

	// Set random seed for planeside activation
	IwRandSeed( (int32)s3eTimerGetMs() );
	int16 color = IwRandMinMax( 0, 5+1 );
	
	// Initialize plane sides
	if( planeSpawning == SINGLE_RANDOM ) // SINGLE FRONT
	{	
		for( int i = 0; i < 6; i++ )
		{
			if( plane[i].color == PlaneSide::BLUE )
			{
				plane[i].active = true;
			}
		}
	}// end of SINGLE FRONT
	else if( planeSpawning == DOUBLE_ADJACENT ) // DOUBLE ADJACENT
	{
		for( int i = 0; i < 6; i++ )
		{
			if( plane[i].color == color ) // activate first random color
			{
				plane[i].active = true;

				int b = 0;
				b = i; // set adjacent plane-source index

				// activate 1 other adjacent side
				int16 dir;
				int a;  // the indexes for planes datastructure

				do
				{
					dir = getAdjacentDirection( plane[b].direction );

					// find a, index of plane with the adjacent direction
					for( int j = 0; j < 6; j++ )
					{
						if( plane[j].direction == dir )
						{
							a = j;
							break;
						}
					}
				}
				while( a == i || plane[a].active == true );

				// activate the new plane
				plane[a].active = true;

				break;
			}
		}
	} // end of Double Adjacent
	else if( planeSpawning == DOUBLE_RANDOM ) // DOUBLE RANDOM
	{
		for( int i = 0; i < 6; i++ )
		{
			if( plane[i].color == color ) // activate first random color
			{
				plane[i].active = true;

				// activate 1 other random side
				int16 a = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
				while( plane[a].active == true )
				{
					a = IwRandMinMax( 0, 5+1 );
				}

				// activate the new plane
				plane[a].active = true;

				break;
			}
		}
	} // end of double Random
	else if( planeSpawning == TRIPLE_RANDOM ) // TRIPLE RANDOM
	{
		for( int i = 0; i < 6; i++ )
		{
			if( plane[i].color == color )
			{
				plane[i].active = true; // activate first random side

				// activate 1 other random side
				int16 a = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
				while( plane[a].active == true )
				{
					a = IwRandMinMax( 0, 5+1 );
				}

				// activate the new plane
				plane[a].active = true;

				// activate 1 other random side
				int16 b = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
				while( plane[b].active == true )
				{
					b = IwRandMinMax( 0, 5+1 );
				}

				// activate the new plane
				plane[b].active = true;
			}
		}
	} // end of triple Random
	else if( planeSpawning == QUADRUPLE_RANDOM ) // QUADRUPLE RANDOM
	{
		for( int i = 0; i < 6; i++ )
		{
			if( plane[i].color == color )
			{
				plane[i].active = true; // activate first random side

				// activate 1 other random side
				int16 a = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
				while( plane[a].active == true )
				{
					a = IwRandMinMax( 0, 5+1 );
				}

				// activate the new plane
				plane[a].active = true;

				// activate 1 other random side
				int16 b = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
				while( plane[b].active == true )
				{
					b = IwRandMinMax( 0, 5+1 );
				}

				// activate the new plane
				plane[b].active = true;

				// activate 1 other random side
				int16 c = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
				while( plane[c].active == true )
				{
					c = IwRandMinMax( 0, 5+1 );
				}

				// activate the new plane
				plane[c].active = true;
			}
		}
	} // end of Quadruple Random
	else if( planeSpawning == QUINTUPLE_RANDOM ) // QUINTUPLE RANDOM
	{
		for( int i = 0; i < 6; i++ )
		{
			if( plane[i].color == color )
			{
				plane[i].active = true; // activate first random side

				// activate 1 other random side
				int16 a = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
				while( plane[a].active == true )
				{
					a = IwRandMinMax( 0, 5+1 );
				}

				// activate the new plane
				plane[a].active = true;

				// activate 1 other random side
				int16 b = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
				while( plane[b].active == true )
				{
					b = IwRandMinMax( 0, 5+1 );
				}

				// activate the new plane
				plane[b].active = true;

				// activate 1 other random side
				int16 c = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
				while( plane[c].active == true )
				{
					c = IwRandMinMax( 0, 5+1 );
				}

				// activate the new plane
				plane[c].active = true;

				// activate 1 other random side
				int16 d = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
				while( plane[d].active == true )
				{
					d = IwRandMinMax( 0, 5+1 );
				}

				// activate the new plane
				plane[d].active = true;
			}
		}
	} // end of Quintuple Random
	else if( planeSpawning == SEXTUPLE ) // SEXTUPLE
	{
		for( int i = 0; i < 6; i++ )
		{
			plane[i].active = true;
		}
	} // end of Sextuple Random
	

	
	int32 heapUsed2 = s3eMemoryGetInt(S3E_MEMORY_USED); // Free memory minus heap size
	printf("Finished Initializing Difficulty. Memory Allocated was %d \n", heapUsed2 - heapUsed );

} // end of initialize diff
void TerminateEpisode( int16 e )
{
	switch( e )
	{
	case 1:
		//delete sphere;
		IwGetResManager()->DestroyGroup("backgroundSphere");
		break;
	case 2:
		//delete sphere2;
		IwGetResManager()->DestroyGroup("backgroundSphere2");
		
		break;
	case 3:
		//delete sphere3;
		IwGetResManager()->DestroyGroup("backgroundSphere3");
		windSystem.Terminate();
		break;
	case 4:
		//delete sphere4;
		IwGetResManager()->DestroyGroup("backgroundSphere4");
		break;
	case 5:
		//delete sphere5;
		IwGetResManager()->DestroyGroup("backgroundSphere5");		
		break;
	case 6:
		//delete sphere6;
		IwGetResManager()->DestroyGroup("backgroundSphere6");		
		break;
	}
}

void setYellowFadeIn( uint64 t )
{
	yellowOverlaySprite.setStartingAlpha( 255 );
	yellowOverlaySprite.setEndingAlpha( 0 );
	yellowOverlaySprite.setAlphaInterpolationTime( t );
}

void setYellowFadeOut( uint64 t )
{
	yellowOverlaySprite.setStartingAlpha( 0 );
	yellowOverlaySprite.setEndingAlpha( 255 );
	yellowOverlaySprite.setAlphaInterpolationTime( t );
}

void setWhiteFadeIn( uint64 t )
{
	whiteOverlaySprite.setStartingAlpha( 255 );
	whiteOverlaySprite.setEndingAlpha( 0 );
	whiteOverlaySprite.setAlphaInterpolationTime( t );
}

void setWhiteFadeOut( uint64 t )
{
	whiteOverlaySprite.setStartingAlpha( 0 );
	whiteOverlaySprite.setEndingAlpha( 255 );
	whiteOverlaySprite.setAlphaInterpolationTime( t );
}

void LoadSoundData()
{
	// initialize sounds
	// Sounds were 12,000 hz, mono, through gold wave, pcm-16
	for( int i = 0; i <= numOfSoundElements; i++ )
	{
		// create a file handle to handle the file
		s3eFile *soundFileHandle;

		switch( i )
		{
		case 0: // load LAND sound
			soundFileHandle = s3eFileOpen("sound_land.snd", "rb"); // the second parameter is mode, r = read, b = read binary						
			break;
		case 1: // load CLEAR sound
			soundFileHandle = s3eFileOpen("sound_clear7_mon.snd", "rb");						
			break;
		case 2: // load POINT PERK sound
			soundFileHandle = s3eFileOpen("sound_pointperk2.snd", "rb");
			break;
		case 3: // load NOT SO GOOD CLEAR sound
			soundFileHandle = s3eFileOpen( "sound_notsogoodclear.snd", "rb");
			break;
		case 4:
			soundFileHandle = s3eFileOpen( "sound_boom.snd", "rb" );
			break;
		case 5:
			soundFileHandle = s3eFileOpen( "sound_levelup.snd", "rb" ); // this is the test file
			break;
		case 6:
			soundFileHandle = s3eFileOpen( "sound_levelup.snd", "rb" ); // ok
			break;
		case 7:
			soundFileHandle = s3eFileOpen( "sound_rotatebutton.snd", "rb" ); // ok
			break;
		case 8:
			soundFileHandle = s3eFileOpen( "sound_redbutton.snd", "rb" );
			break;
		case 9:
			soundFileHandle = s3eFileOpen( "sound_bombvoice1.snd", "rb" );  // ok
			break;
		case 10:
			soundFileHandle = s3eFileOpen( "sound_bombvoice2.snd", "rb" ); // ok
			break;
		case 11:
			soundFileHandle = s3eFileOpen( "sound_bombvoice3.snd", "rb" ); // ok
			break;
		case 12:
			soundFileHandle = s3eFileOpen( "sound_bombvoice4.snd", "rb" ); // ok
			break;
		case 13:
			soundFileHandle = s3eFileOpen( "sound_ohno1.snd", "rb" ); // death voice
			break;
		case 14:
			soundFileHandle = s3eFileOpen( "sound_ohno2.snd", "rb" ); // layer level 3 warning voice
			break;
		case 15:
			soundFileHandle = s3eFileOpen( "sound_deathvoice3.snd", "rb" ); // game over voice
			break;
		case 16:
			soundFileHandle = s3eFileOpen( "sound_levelcomplete.snd", "rb" );
			break;
		case 17:
			soundFileHandle = s3eFileOpen( "sound_fuzzycelebration1.snd", "rb" ); // not used
			break;
		case 18:
			soundFileHandle = s3eFileOpen( "sound_fuzzycelebration2.snd", "rb" );
			break;
		case 19:
			soundFileHandle = s3eFileOpen( "sound_thankyou.snd", "rb" );
			break;
		case 20:
			soundFileHandle = s3eFileOpen( "sound_gameover.snd", "rb" );
			break;
		case 21:
			soundFileHandle = s3eFileOpen( "sound_click.snd", "rb" );
			break;
		case 22:
			soundFileHandle = s3eFileOpen( "sound_ping.snd", "rb" );
			break;
		}

		// get the size of sound file
		soundFileSize[i] = s3eFileGetSize( soundFileHandle );

		// create the sound buffer that starts sound playback in memory
		soundBuffer[i] = (int16*)s3eMallocBase(soundFileSize[i]); // allocate enough memory for sound file
		memset( soundBuffer[i], 0, soundFileSize[i] ); // sets pointer to value of zero, using the soundFileSize-number of bytes
		s3eFileRead( soundBuffer[i], soundFileSize[i], 1, soundFileHandle ); // read data into the buffer, starting at soundBuffer, with size fileSize, with 1 num of elements, fileHandle pointer to be read from
		s3eFileClose( soundFileHandle );

		// set sounds to be not playing
		soundIsPlaying[i] = false;
	}

	// Setting default frequency at which all channels will play at, in Hz.
	s3eSoundSetInt(S3E_SOUND_DEFAULT_FREQ, 24000);
}

void TerminateSoundData()
{
	for( int i = 0; i <= numOfSoundElements; i++ )
	{
		if( soundBuffer[i] )
		{
			delete soundBuffer[i];
			soundBuffer[i] = NULL;
		}
	}
}

void playLandSound() // LAND SOUND
{
	// Find free channel to play sound file
	soundChannel[0] = s3eSoundGetFreeChannel();

	// channel, pointer to start of memory to play from, numOfSamples is fileSize/num of bytes div. by 2, repeat, loopfrom. not sure what loopfrom is.
	if( s3eSoundChannelPlay(soundChannel[0], soundBuffer[0], soundFileSize[0]/2, 1, 0) == S3E_RESULT_ERROR )
	{
		// print string on error
		printf("ERROR in s3eSoundChannelPlay \n");
	}
	else
	{
		// if no error, sound will play. Can set boolean here if necessary
		soundIsPlaying[0] = true;
	}

	/*
	// register a sound-ending callback to set boolean to be playing = false
	if( s3eSoundChannelRegister( soundChannel[0], S3E_CHANNEL_END_SAMPLE, resetLandSound, 0) == S3E_RESULT_ERROR )
	{
		printf("Error in landSound reset callback \n");		
	}
	*/
}

int32 resetLandSound(void *systemData, void *userData)// reset land sound callback fn
{
	soundIsPlaying[0] = false;

	// unregister the callback for channel, since channel is dependent on what is free
	//s3eSoundChannelUnRegister( soundChannel[0], S3E_CHANNEL_END_SAMPLE );

	return 0;
}

void playWarpSound() // WARP SOUND
{
	soundChannel[1] = s3eSoundGetFreeChannel();

	// channel, pointer to start of memory to play from, numOfSamples is fileSize/num of bytes div. by 2, repeat, loopfrom. not sure what loopfrom is.
	if( s3eSoundChannelPlay(soundChannel[1], soundBuffer[1], soundFileSize[1]/2, 1, 0) == S3E_RESULT_ERROR && soundIsPlaying[1] == false )
	{
		// print string on error
		printf("ERROR in s3eSoundChannelPlay \n");
	}
	else
	{
		// if no error, sound will play. Can set boolean here if necessary
		soundIsPlaying[1] = true;
	}

	/*
	// register a sound-ending callback to set boolean to be playing = false
	if( s3eSoundChannelRegister( soundChannel[1], S3E_CHANNEL_END_SAMPLE, resetWarpSound, 0) == S3E_RESULT_ERROR )
	{
		printf("Error in warpSound reset callback \n");		
	}
	*/
}

void playNotSoGoodWarpSound() // WARP SOUND incomplete
{
	soundChannel[3] = s3eSoundGetFreeChannel();
	
	// channel, pointer to start of memory to play from, numOfSamples is fileSize/num of bytes div. by 2, repeat, loopfrom. not sure what loopfrom is.
	if( s3eSoundChannelPlay(soundChannel[3], soundBuffer[3], soundFileSize[3]/2, 1, 0) == S3E_RESULT_ERROR )
	{
		// print string on error
		printf("ERROR in s3eSoundChannelPlay \n");
	}
}

int32 resetWarpSound(void *systemData, void *userData) // reset land sound callback fn
{
	soundIsPlaying[1] = false;

	// unregister the callback for channel, since channel is dependent on what is free
	//s3eSoundChannelUnRegister( soundChannel[1], S3E_CHANNEL_END_SAMPLE );

	return 0;
}

void playPointPerkSound()
{
	//if( soundIsPlaying[2] == false )
	{
		// unregister
		//s3eSoundChannelUnRegister( soundChannel[2], S3E_CHANNEL_END_SAMPLE );

		soundChannel[2] = s3eSoundGetFreeChannel();
	
		// channel, pointer to start of memory to play from, numOfSamples is fileSize/num of bytes div. by 2, repeat, loopfrom. not sure what loopfrom is.
		if( s3eSoundChannelPlay(soundChannel[2], soundBuffer[2], soundFileSize[2]/2, 1, 0) == S3E_RESULT_ERROR )
		{
			// print string on error
			printf("ERROR in s3eSoundChannelPlay \n");
		}
		else
		{
			soundIsPlaying[2] = true;
		}
	}
}

void playBoomSound()
{
	soundChannel[4] = s3eSoundGetFreeChannel();
	
	// channel, pointer to start of memory to play from, numOfSamples is fileSize/num of bytes div. by 2, repeat, loopfrom. not sure what loopfrom is.
	if( s3eSoundChannelPlay(soundChannel[4], soundBuffer[4], soundFileSize[4]/2, 1, 0) == S3E_RESULT_ERROR )
	{
		// print string on error
		printf("ERROR in s3eSoundChannelPlay \n");
	}
}

void playTestSound()
{
	soundChannel[5] = s3eSoundGetFreeChannel();

	// channel, pointer to start of memory to play from, numOfSamples is fileSize/num of bytes div. by 2, repeat, loopfrom. not sure what loopfrom is.
	if( s3eSoundChannelPlay(soundChannel[5], soundBuffer[5], soundFileSize[5]/2, 1, 0) == S3E_RESULT_ERROR )
	{
		// print string on error
		printf("ERROR in s3eSoundChannelPlay \n");
	}
}

void playLevelUpSound()
{
	soundChannel[6] = s3eSoundGetFreeChannel();

	// channel, pointer to start of memory to play from, numOfSamples is fileSize/num of bytes div. by 2, repeat, loopfrom. not sure what loopfrom is.
	if( s3eSoundChannelPlay(soundChannel[6], soundBuffer[6], soundFileSize[6]/2, 1, 0) == S3E_RESULT_ERROR )
	{
		// print string on error
		printf("ERROR in s3eSoundChannelPlay \n");
	}
}

void playLevelCompleteSound()
{
	soundChannel[16] = s3eSoundGetFreeChannel();

	// channel, pointer to start of memory to play from, numOfSamples is fileSize/num of bytes div. by 2, repeat, loopfrom. not sure what loopfrom is.
	if( s3eSoundChannelPlay(soundChannel[16], soundBuffer[16], soundFileSize[16]/2, 1, 0) == S3E_RESULT_ERROR )
	{
		// print string on error
		printf("ERROR in s3eSoundChannelPlay \n");
	}
}

void playRotateSound()
{
	soundChannel[7] = s3eSoundGetFreeChannel();

	// channel, pointer to start of memory to play from, numOfSamples is fileSize/num of bytes div. by 2, repeat, loopfrom. not sure what loopfrom is.
	if( s3eSoundChannelPlay(soundChannel[7], soundBuffer[7], soundFileSize[7]/2, 1, 0) == S3E_RESULT_ERROR )
	{
		// print string on error
		printf("ERROR in s3eSoundChannelPlay \n");
	}
}

void playRedButtonSound()
{
	soundChannel[8] = s3eSoundGetFreeChannel();

	// channel, pointer to start of memory to play from, numOfSamples is fileSize/num of bytes div. by 2, repeat, loopfrom. not sure what loopfrom is.
	if( s3eSoundChannelPlay(soundChannel[8], soundBuffer[8], soundFileSize[8]/2, 1, 0) == S3E_RESULT_ERROR )
	{
		// print string on error
		printf("ERROR in s3eSoundChannelPlay \n");
	}
}

void playBombVoice()
{
	// randomly generate a number 1-4 to play the bomb voice
	int16 bombVoiceNumber = IwRandMinMax( 0, 3+1 );

	soundChannel[9 + bombVoiceNumber] = s3eSoundGetFreeChannel();

	// channel, pointer to start of memory to play from, numOfSamples is fileSize/num of bytes div. by 2, repeat, loopfrom. not sure what loopfrom is.
	if( s3eSoundChannelPlay(soundChannel[9 + bombVoiceNumber], soundBuffer[9 + bombVoiceNumber], soundFileSize[9 + bombVoiceNumber]/2, 1, 0) == S3E_RESULT_ERROR )
	{
		// print string on error
		printf("ERROR in s3eSoundChannelPlay \n");
	}
}

void playDeathVoice()
{
	soundChannel[13] = s3eSoundGetFreeChannel();

	// channel, pointer to start of memory to play from, numOfSamples is fileSize/num of bytes div. by 2, repeat, loopfrom. not sure what loopfrom is.
	if( s3eSoundChannelPlay(soundChannel[13], soundBuffer[13], soundFileSize[13]/2, 1, 0) == S3E_RESULT_ERROR )
	{
		// print string on error
		printf("ERROR in s3eSoundChannelPlay \n");
	}
}

void playLayerLevel3Warning()
{
	soundChannel[14] = s3eSoundGetFreeChannel();

	// channel, pointer to start of memory to play from, numOfSamples is fileSize/num of bytes div. by 2, repeat, loopfrom. not sure what loopfrom is.
	if( s3eSoundChannelPlay(soundChannel[14], soundBuffer[14], soundFileSize[14]/2, 1, 0) == S3E_RESULT_ERROR )
	{
		// print string on error
		printf("ERROR in s3eSoundChannelPlay \n");
	}
}

void playGameOverVoice()
{
	soundChannel[15] = s3eSoundGetFreeChannel();

	// channel, pointer to start of memory to play from, numOfSamples is fileSize/num of bytes div. by 2, repeat, loopfrom. not sure what loopfrom is.
	if( s3eSoundChannelPlay(soundChannel[15], soundBuffer[15], soundFileSize[15]/2, 1, 0) == S3E_RESULT_ERROR )
	{
		// print string on error
		printf("ERROR in s3eSoundChannelPlay \n");
	}
}

void playCelebration1()
{
	soundChannel[17] = s3eSoundGetFreeChannel();

	// channel, pointer to start of memory to play from, numOfSamples is fileSize/num of bytes div. by 2, repeat, loopfrom. not sure what loopfrom is.
	if( s3eSoundChannelPlay(soundChannel[17], soundBuffer[17], soundFileSize[17]/2, 1, 0) == S3E_RESULT_ERROR )
	{
		// print string on error
		printf("ERROR in s3eSoundChannelPlay \n");
	}
}

void playCelebration2()
{
	soundChannel[18] = s3eSoundGetFreeChannel();

	// channel, pointer to start of memory to play from, numOfSamples is fileSize/num of bytes div. by 2, repeat, loopfrom. not sure what loopfrom is.
	if( s3eSoundChannelPlay(soundChannel[18], soundBuffer[18], soundFileSize[18]/2, 1, 0) == S3E_RESULT_ERROR )
	{
		// print string on error
		printf("ERROR in s3eSoundChannelPlay \n");
	}
}

void playDefusedVoice()
{
	soundChannel[19] = s3eSoundGetFreeChannel();

	// channel, pointer to start of memory to play from, numOfSamples is fileSize/num of bytes div. by 2, repeat, loopfrom. not sure what loopfrom is.
	if( s3eSoundChannelPlay(soundChannel[19], soundBuffer[19], soundFileSize[19]/2, 1, 0) == S3E_RESULT_ERROR )
	{
		// print string on error
		printf("ERROR in s3eSoundChannelPlay \n");
	}
}

void playGameOverSound()
{
	// Find free channel to play sound file
	soundChannel[20] = s3eSoundGetFreeChannel();

	// channel, pointer to start of memory to play from, numOfSamples is fileSize/num of bytes div. by 2, repeat, loopfrom. not sure what loopfrom is.
	if( s3eSoundChannelPlay(soundChannel[20], soundBuffer[20], soundFileSize[20]/2, 1, 0) == S3E_RESULT_ERROR )
	{
		// print string on error
		printf("ERROR in s3eSoundChannelPlay \n");
	}
	else
	{
		// if no error, sound will play. Can set boolean here if necessary
		soundIsPlaying[20] = true;
	}
}

void playClickSound()
{
	/*
	// Find free channel to play sound file
	soundChannel[21] = s3eSoundGetFreeChannel();

	// channel, pointer to start of memory to play from, numOfSamples is fileSize/num of bytes div. by 2, repeat, loopfrom. not sure what loopfrom is.
	if( s3eSoundChannelPlay(soundChannel[21], soundBuffer[21], soundFileSize[21]/2, 1, 0) == S3E_RESULT_ERROR )
	{
		// print string on error
		printf("ERROR in s3eSoundChannelPlay \n");
	}
	else
	{
		// if no error, sound will play. Can set boolean here if necessary
		soundIsPlaying[21] = true;
	}
	*/
}

void playPingSound()
{
	// Find free channel to play sound file
	soundChannel[22] = s3eSoundGetFreeChannel();

	// channel, pointer to start of memory to play from, numOfSamples is fileSize/num of bytes div. by 2, repeat, loopfrom. not sure what loopfrom is.
	if( s3eSoundChannelPlay(soundChannel[22], soundBuffer[22], soundFileSize[22]/2, 1, 0) == S3E_RESULT_ERROR )
	{
		// print string on error
		printf("ERROR in s3eSoundChannelPlay \n");
	}
	else
	{
		// if no error, sound will play. Can set boolean here if necessary
		soundIsPlaying[22] = true;
	}
}

int32 checkOutOfLivesGameOver(void *systemData, void *userData)
{
	if( numOfLives <= -1 )
	{
		if( TargetState != AT_SCORE_SCREEN )
		{
			transition = true;
			transitionIsSet = false;
			TargetState = AT_SCORE_SCREEN;

			gameOver = true;

			if( playedGameOverVoiceOnce == false )
			{
				playGameOverVoice();
				playedGameOverVoiceOnce = true;
			}

			// this ensures video clip gets played for game over on ep3
			if( episode == 3 && (levelNumber >= 7 && levelNumber <= 9 ) )
			{
				transition = true;
				transitionIsSet = false;
				TargetState = PLAY_CINEMATIC;

				gameOver = true;
			}

			/* do not use
			// flurry log death
			if( hasFlurry )
			{
				char cstring[50] = "Died on episode ";
				strcat( cstring, levelToCstring( episode, levelNumber ) );
				s3eFlurryLogEvent( cstring, false );

				char cstring2[50] = "Died on episode ";
				strcat( cstring2, levelToCstring( episode, levelNumber ) );
				strcat( cstring2, " by: out-of-lives" );
				s3eFlurryLogEvent( cstring2, false );

				s3eFlurryEndTimedEvent( timedEvent );
			}
			*/
		}
	}
	return 0;
}


void lowerVolume()
{
	// lowers current volume by a factor
	int volume = s3eAudioGetInt( S3E_AUDIO_VOLUME );
	s3eAudioSetInt( S3E_AUDIO_VOLUME, volume/32 );
}

void raiseVolume()
{
	// raises current volume by a factor
	int volume = s3eAudioGetInt( S3E_AUDIO_VOLUME );
	s3eAudioSetInt( S3E_AUDIO_VOLUME, volume * 32 );
}

int32 resetPointPerkSound(void *systemData, void *userData) // reset land sound callback fn
{
	soundIsPlaying[2] = false;

	return 0;
}

int32 ShowIAD(void *systemData, void *userData) 
{
	s3eIOSIAdSetInt( S3E_IOSIAD_BANNER_SHOW, 1 );

	return 0;
}

int32 HideIAD(void *systemData, void *userData) 
{
	s3eIOSIAdSetInt( S3E_IOSIAD_BANNER_SHOW, 0 );
	return 0;
}

// QFI reset current multitasking variables
void ResetMultitaskingCurrent()
{
	totalDTLCurrent = 0;
	averageDTLCurrent = 0;
	totalDroppedCubeSetsCurrent = 0;
}

void ResetMultitasking()
{
	totalDTL = 0;
	averageDTL = 0;
	totalDroppedCubeSets = 0;
}

void AddOneAPM()
{
	if( numMovingCubesIndex != 0 ) // if there are cubes in play, add 1 to APM
	{
		totalActionsCurrent++;
		totalActions++;

		idleCounter = 0;

		apmIntervalTime0 = apmIntervalTime1;
		apmIntervalTime1 = s3eTimerGetMs();

		apmInterval = apmIntervalTime1 - apmIntervalTime0;
	}
}

void ResetCurrentAPM()
{
	totalActionsCurrent = 0;
	apmTotalTimeSavedCurrent = 0;
	apmTotalTimeCurrent = 0;
	apmTime1Current = 0;
	apmTime0Current = 0;
}

void ResetAverageAPM()
{
	totalActions = 0;
	apmTotalTimeSaved = 0;
	apmTotalTime = 0;
	apmTime1 = 0;
	apmTime0 = 0;
}

void ResetEfficiency()
{
	scoredDrops = 0;
	totalDrops = 0;
}

void ResetEfficiencyCurrent()
{
	scoredDropsCurrent = 0;
	totalDropsCurrent = 0;
}

void ResetQFIVariablesCurrent()
{
	ResetCurrentAPM();
	ResetEfficiencyCurrent();
	ResetMultitaskingCurrent();

	skillIndexCurrent = 0;
	performanceIndexCurrent = 0;
	totalDropsInFlowState = 0;
}

void ResetQFIVariables()
{
	ResetAverageAPM();
	ResetEfficiency();
	ResetMultitasking();

	skillIndex = 0;
	performanceIndex = 0;
}

void SetTargetPlaneSpawning()
{
	/*
	difficulty  planeSpawn  cubeSpawn
	1			SINGLE_RAN	SINGLE_RAN
	2			DOUBLE_ADJ	SINGLE_RAN
	3			DOUBLE_ADJ	DOUBLE_INC - 3
	4			DOUBLE_RAN	DOUBLE_RAN
	5			TRIPLE_RAN	DOUBLE_RAN
	6			QUAD_RAN	DOUBLE_RAN
	7			TRIPLE_RAN	TRIPLE_INC - 7
	8			TRIPLE_RAN	TRIPLE_RAN
	9			QUAD_RAN	TRIPLE_RAN
	10			QUIN_RAN	TRIPLE_RAN
	11			SEXTUP_RAN	TRIPLE_RAN
	12			QUAD_RAN	QUAD_INC - 12
	13			QUAD_RAN	QUAD_RAN
	14			QUIN_RAN	QUAD_RAN
	15			SEXTUP_RAN	QUAD_RAN
	16			QUIN_RAN	QUIN_INC - 16
	17			QUIN_RAN	QUIN_RAN
	18			SEXTUP		QUIN_RAN
	19			SEXTUP		SEXTUP_INC - 19
	20			SEXTUP		SEXTUP_RAN
	*/

	switch( targetDifficulty )
	{
	case 1:
		targetPlaneSpawning = SINGLE_RANDOM;
		break;
	case 2:
	case 3:
		targetPlaneSpawning = DOUBLE_ADJACENT;
		break;
	case 4:
		targetPlaneSpawning = DOUBLE_RANDOM;
		break;
	case 5:		
	case 7:
	case 8:
		targetPlaneSpawning = TRIPLE_RANDOM;
		break;
	case 6:
	case 9:
	case 12:
	case 13:
		targetPlaneSpawning = QUADRUPLE_RANDOM;
		break;
	case 10:
	case 14:
	case 16:
	case 17:
		targetPlaneSpawning = QUINTUPLE_RANDOM;
		break;
	case 11:
	case 18:
	case 19:
	case 20:
		targetPlaneSpawning = SEXTUPLE;
		break;
	}
}

void SetTargetCubeSpawning()
{
	/*
	difficulty  planeSpawn  cubeSpawn
	1			SINGLE_RAN	SINGLE_RAN
	2			DOUBLE_ADJ	SINGLE_RAN
	3			DOUBLE_ADJ	DOUBLE_INC - 3
	4			DOUBLE_RAN	DOUBLE_RAN
	5			TRIPLE_RAN	DOUBLE_RAN
	6			QUAD_RAN	DOUBLE_RAN
	7			TRIPLE_RAN	TRIPLE_INC - 7
	8			TRIPLE_RAN	TRIPLE_RAN
	9			QUAD_RAN	TRIPLE_RAN
	10			QUIN_RAN	TRIPLE_RAN
	11			SEXTUP_RAN	TRIPLE_RAN
	12			QUAD_RAN	QUAD_INC - 12
	13			QUAD_RAN	QUAD_RAN
	14			QUIN_RAN	QUAD_RAN
	15			SEXTUP_RAN	QUAD_RAN
	16			QUIN_RAN	QUIN_INC - 16
	17			QUIN_RAN	QUIN_RAN
	18			SEXTUP		QUIN_RAN
	19			SEXTUP		SEXTUP_INC - 19
	20			SEXTUP		SEXTUP_RAN
	*/

	switch( targetDifficulty )
	{
	case 1:
	case 2:
		targetCubeSpawning = SINGLE_RANDOM;
		break;
	case 3:
		targetCubeSpawning = DOUBLE_INCOLOR;
		break;
	case 4:
	case 5:
	case 6:
		targetCubeSpawning = DOUBLE_RANDOM;
		break;
	case 7:
		targetCubeSpawning = TRIPLE_INCOLOR;
		break;
	case 8:
	case 9:
	case 10:
	case 11:
		targetCubeSpawning = TRIPLE_RANDOM;
		break;
	case 12:
		targetCubeSpawning = QUADRUPLE_INCOLOR;
		break;
	case 13:
	case 14:
	case 15:
		targetCubeSpawning = QUADRUPLE_RANDOM;
		break;
	case 16:
		targetCubeSpawning = QUINTUPLE_INCOLOR;
		break;
	case 17:
	case 18:
		targetCubeSpawning = QUINTUPLE_RANDOM;
		break;
	case 19:
		targetCubeSpawning = SEXTUPLE_INCOLOR;
		break;
	case 20:
		targetCubeSpawning = SEXTUPLE_RANDOM;
		break;
	}
}

void DisplayLoading()
{
	loadingScreen.Render();
	loadingIconSprite.Render();
	Iw2DSurfaceShow();

	// Prevents screen from going dim
	s3eDeviceBacklightOn();
}

void DisplayLoadingWithoutRefresh()
{
	loadingScreen.Render();
	loadingIconSprite.Render();

	// Prevents screen from going dim
	s3eDeviceBacklightOn();
}

/*
int32 DisplayLoading( void* systemData, void* userData )
{
	loadingScreen.Render();
	loadingIconSprite.Render();
	Iw2DSurfaceShow();
	return 0;
}
*/

CIwTexture* DisplayLoading( int16 a )
{
	CIwTexture* b;
	return b;
}

void LoadSaveFile()
{
	/* this works

	s3eResult result = s3eSecureStorageGet( &currentData, sizeof(savedData));

	if( result != S3E_RESULT_SUCCESS  )
	{
		printf("Loading save file...failed.\n\n");
	}
	else
	{
		printf("Loading save file...success! Loaded file: " );
		printf( currentData.c_str() );
		printf("\n\n");
	}
	*/

	// retrieve the save file into 'saveFile'
	s3eResult result = s3eSecureStorageGet( &saveFile, sizeof(saveFile));

	// set the default values if did not load successfully. Should be only on first load ever.
	if( result != S3E_RESULT_SUCCESS  )
	{
		versionNumber = 1;
		printf("Loading save file...no file found. Initializing with default values\n\n");
		playingStory = false;
		score = 0;
		highScore = 0;
		numOfLives = 10;
		scoreLivesBonusBucket = 0;
		targetEpisode = 1;
		timeSeconds = 0;
		timeMinutes = 0;
		timeHours = 0;
		for( int i = 0; i < NUM_OF_TROPHIES; i++ )
		{
			trophies[i] = false;
		}

		playedHowToTutorialOnce = false;
		playedBombTutorialOnce = false;
		playedWarningTutorialOnce = false;
		startAtCheckpoint = false;

		Save();
	}
	else
	{
		printf("Loading save file...success!  " );
		saveFile.print();

		// load the data from the save file
		//playingStory = saveFile.playingStory;

		versionNumber = saveFile.versionNumber;

		if( versionNumber == 1 )
		{
			printf("Loading version 1 ...\n" );
			// load the integers
			numOfLives = saveFile.integers[ SaveFile::numOfLives ];
			targetEpisode = saveFile.integers[ SaveFile::targetEpisode ];
			timeSeconds = saveFile.integers[ SaveFile::timeSeconds ];
			timeMinutes = saveFile.integers[ SaveFile::timeMinutes ];
			timeHours = saveFile.integers[ SaveFile::timeHours ];

			// load the longs
			score = saveFile.longs[ SaveFile::score ];
			highScore = saveFile.longs[ SaveFile::highScore ];
			scoreLivesBonusBucket = saveFile.longs[ SaveFile::scoreLivesBonusBucket ];

			// load the booleans
			playingStory = false; // do not load this
			for( int i = 0; i < NUM_OF_TROPHIES; i++ )
			{
				trophies[i] = saveFile.booleans[i];
			}	

			playedHowToTutorialOnce = saveFile.booleans[ SaveFile::playedHowToTutorialOnce ];
			playedBombTutorialOnce = saveFile.booleans[ SaveFile::playedBombTutorialOnce ];
			playedWarningTutorialOnce = saveFile.booleans[ SaveFile::playedWarningTutorialOnce ];

			// set tutorial watch
			playedHowToTutorialOnce = false;
			playedBombTutorialOnce = false;
			playedWarningTutorialOnce = false;

			// load the floats
		} // end of if version number is 1.0
		else if( versionNumber == 2 )
		{
			printf("Loading version 2 ...\n" );
			// load the integers
			numOfLives = saveFile.integers[ SaveFile::numOfLives ];
			targetEpisode = saveFile.integers[ SaveFile::targetEpisode ];
			timeSeconds = saveFile.integers[ SaveFile::timeSeconds ];
			timeMinutes = saveFile.integers[ SaveFile::timeMinutes ];
			timeHours = saveFile.integers[ SaveFile::timeHours ];

			// load the longs
			score = saveFile.longs[ SaveFile::score ];
			highScore = saveFile.longs[ SaveFile::highScore ];
			scoreLivesBonusBucket = saveFile.longs[ SaveFile::scoreLivesBonusBucket ];

			// load the booleans
			playingStory = false; // do not load this
			for( int i = 0; i < NUM_OF_TROPHIES; i++ )
			{
				trophies[i] = saveFile.booleans[i];
			}

			playedHowToTutorialOnce = saveFile.booleans[ SaveFile::playedHowToTutorialOnce ];
			playedBombTutorialOnce = saveFile.booleans[ SaveFile::playedBombTutorialOnce ];
			playedWarningTutorialOnce = saveFile.booleans[ SaveFile::playedWarningTutorialOnce ];

			// set tutorial watch
			//playedHowToTutorialOnce = false;
			//playedBombTutorialOnce = false;
			//playedWarningTutorialOnce = false;

			startAtCheckpoint = saveFile.booleans[ SaveFile::startAtCheckpoint ]; // this is new in 1.1

		} // end of version 2
		else if( versionNumber == 3 )
		{
		}
	} // end of if-successful loading of file
}

void Save()
{
	// Save version number
	versionNumber = 2;
	/* versionNumber = 1; 1.0; 1.0.0;

	*/
	saveFile.versionNumber = versionNumber;

	if( versionNumber == 1 ) // 1.0
	{
		// Save the integers
		saveFile.integers[ SaveFile::numOfLives ] = numOfLives;
		saveFile.integers[ SaveFile::targetEpisode ] = targetEpisode;
		saveFile.integers[ SaveFile::timeSeconds ] = timeSeconds;
		saveFile.integers[ SaveFile::timeMinutes ] = timeMinutes;
		saveFile.integers[ SaveFile::timeHours ] = timeHours;

		// save the longs
		saveFile.longs[ SaveFile::score ] = score;
		saveFile.longs[ SaveFile::highScore ] = highScore;
		saveFile.longs[ SaveFile::scoreLivesBonusBucket ] = scoreLivesBonusBucket;
	
		// save the booleans
		saveFile.booleans[ SaveFile::playingStory ] = playingStory;
		for( int i = 0; i < NUM_OF_TROPHIES; i++ )
		{
			saveFile.booleans[i] = trophies[i];
		}

		saveFile.booleans[ SaveFile::playedHowToTutorialOnce ] = playedHowToTutorialOnce;
		saveFile.booleans[ SaveFile::playedBombTutorialOnce ] = playedBombTutorialOnce;
		saveFile.booleans[ SaveFile::playedWarningTutorialOnce ] = playedWarningTutorialOnce;
	}
	else if( versionNumber == 2 ) // 1.1
	{
		// Save the integers
		saveFile.integers[ SaveFile::numOfLives ] = numOfLives;
		saveFile.integers[ SaveFile::targetEpisode ] = targetEpisode;
		saveFile.integers[ SaveFile::timeSeconds ] = timeSeconds;
		saveFile.integers[ SaveFile::timeMinutes ] = timeMinutes;
		saveFile.integers[ SaveFile::timeHours ] = timeHours;

		// save the longs
		saveFile.longs[ SaveFile::score ] = score;
		saveFile.longs[ SaveFile::highScore ] = highScore;
		saveFile.longs[ SaveFile::scoreLivesBonusBucket ] = scoreLivesBonusBucket;
	
		// save the booleans
		saveFile.booleans[ SaveFile::playingStory ] = playingStory;
		for( int i = 0; i < NUM_OF_TROPHIES; i++ )
		{
			saveFile.booleans[i] = trophies[i];
		}

		saveFile.booleans[ SaveFile::playedHowToTutorialOnce ] = playedHowToTutorialOnce;
		saveFile.booleans[ SaveFile::playedBombTutorialOnce ] = playedBombTutorialOnce;
		saveFile.booleans[ SaveFile::playedWarningTutorialOnce ] = playedWarningTutorialOnce;
		saveFile.booleans[ SaveFile::startAtCheckpoint ] = startAtCheckpoint; // this is new in 1.1
	}
	else if( versionNumber == 3 )
	{
	}

	printf("Executed save file. Target episode is %d \n", saveFile.integers[ SaveFile::targetEpisode ] );
	
	if( s3eSecureStoragePut( &saveFile, sizeof(saveFile) ) == S3E_RESULT_SUCCESS )
	{
		printf("Saving Entire Game State...success! \n");
	}
	else
	{
		printf("Saving Entire Game State...failed!!\n");
	}
	
}

void SaveHighStats()
{
	if( versionNumber == 1 ) // save only the high score and trophies
	{
		// save the integers
		saveFile.integers[ SaveFile::timeSeconds ] = timeSeconds;
		saveFile.integers[ SaveFile::timeMinutes ] = timeMinutes;
		saveFile.integers[ SaveFile::timeHours ] = timeHours;

		// save the longs
		saveFile.longs[ SaveFile::score ] = score;
		saveFile.longs[ SaveFile::highScore ] = highScore;
		saveFile.longs[ SaveFile::scoreLivesBonusBucket ] = scoreLivesBonusBucket;
	
		// save the booleans		
		for( int i = 0; i < NUM_OF_TROPHIES; i++ )
		{
			saveFile.booleans[i] = trophies[i];
		}

		// save the floats
	}
	else if( versionNumber == 2 )
	{
		// save the integers
		saveFile.integers[ SaveFile::timeSeconds ] = timeSeconds;
		saveFile.integers[ SaveFile::timeMinutes ] = timeMinutes;
		saveFile.integers[ SaveFile::timeHours ] = timeHours;

		// save the longs
		//saveFile.longs[ SaveFile::score ] = score;
		saveFile.longs[ SaveFile::highScore ] = highScore;
		//saveFile.longs[ SaveFile::scoreLivesBonusBucket ] = scoreLivesBonusBucket;
	
		// save the booleans		
		for( int i = 0; i < NUM_OF_TROPHIES; i++ )
		{
			saveFile.booleans[i] = trophies[i];
		}
	}
	else if( versionNumber == 3 )
	{
	}

	if( s3eSecureStoragePut( &saveFile, sizeof(saveFile) ) == S3E_RESULT_SUCCESS )
	{
		printf("Saving high stats...success! \n");
	}
	else
	{
		printf("Saving high stats...failed!!\n");
	}
}

void SaveTutorialPlayed()
{
	// also save whether or not they watched the video
	saveFile.booleans[ SaveFile::playedHowToTutorialOnce ] = playedHowToTutorialOnce;
	saveFile.booleans[ SaveFile::playedBombTutorialOnce ] = playedBombTutorialOnce;
	saveFile.booleans[ SaveFile::playedWarningTutorialOnce ] = playedWarningTutorialOnce;

	if( s3eSecureStoragePut( &saveFile, sizeof(saveFile) ) == S3E_RESULT_SUCCESS )
	{
		printf("Saving bools Tutorial Played...success! \n");
	}
	else
	{
		printf("Saving bools Tutorial Played...failed!!\n");
	}
}

void SaveTargetEpisode()
{
	saveFile.integers[ SaveFile::targetEpisode ] = targetEpisode;
	
	if( s3eSecureStoragePut( &saveFile, sizeof(saveFile) ) == S3E_RESULT_SUCCESS )
	{
		printf("Saving target episode...success! \n");
	}
	else
	{
		printf("Saving target episode...failed!!\n");
	}
}

void LoadBackgroundAndOtherInit()
{

	transitionObject.Initialize();
	for( int i = 0; i < transitionObject.numOfOverlays; i++ )
	{
		transitionObject.transitionSprite[i].setSize( width, height );
	}

	LoadSoundData();

	//splashImage = Iw2DCreateImage("splash.png");
	//splashSprite.setUWidth( 480 );
	//splashSprite.setUHeight( 320 );
	//splashSprite.setSize( 480, 320 );
	splashImage = Iw2DCreateImage("splash(HD).png");
	splashSprite.setUWidth( 1024 );
	splashSprite.setUHeight( 768 );
	splashSprite.setSize( width, height );
	splashSprite.setImage( splashImage );
	splashSprite.setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );

	//titleImage = Iw2DCreateImage("title.png");
	//titleSprite.setUWidth( 480 );
	//titleSprite.setUHeight( 320 );
	//titleSprite.setSize( 480, 320 );
	titleImage = Iw2DCreateImage("Title(HD).png");
	titleSprite.setUWidth( 1024 );
	titleSprite.setUHeight( 768 );
	titleSprite.setSize( width, height );
	titleSprite.setImage( titleImage );
	titleSprite.setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );

	// here
	// load fuzzy facts 
	
	// load loading screen for new game
	//loadingScreen.setUWidth( 480 );
	//loadingScreen.setUHeight( 320 );
	//loadingScreen.setSize( 480, 320 );
	loadingScreen.setUWidth( 1024 );
	loadingScreen.setUHeight( 768 );
	loadingScreen.setSize( width, height );
	//loadingImage = Iw2DCreateImage("loading2.png");
	loadingImage = Iw2DCreateImage("Loadingscreen1(HD).png");
	loadingScreen.setImage( loadingImage );
	loadingScreen.setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );

	// loading clock animation
	//loadingIconSprite.setUWidth( 128 );
	//loadingIconSprite.setUHeight( 128 );
	//loadingIconSprite.setSize( 128, 128 );
	loadingIconSprite.setUWidth( 256 );
	loadingIconSprite.setUHeight( 256 );
	loadingIconSprite.setSize( width * .27, width * .27 );
	//loadingIconImage = Iw2DCreateImage( "loadingIcon.png" );
	loadingIconImage = Iw2DCreateImage( "LoadingIcon(HD).png" );
	loadingIconSprite.setImage( loadingIconImage );
	loadingIconSprite.setDelayTime( 2 );
	loadingIconSprite.setTotalFrames( 15 );
	//loadingIconSprite.setPosition( IwGxGetScreenWidth() - 75 , IwGxGetScreenHeight() - 75 );
	loadingIconSprite.setPosition( width * .84, height * .77 );
	
	// LOAD BACKGROUND AND STARS
	
	// create background Stars
	for( int i = 0; i < NUM_STAR_TEXTURES; i++ )
	{
		starTexture[i] = new CIwTexture();
		//starTexture->LoadFromFile("blueStar_small.png");
		switch( i )
		{
		case 0:
			//starTexture[i]->LoadFromFile("yellowStar_small.png");
			starTexture[i]->LoadFromFile("Yellowstar(HD).png");
			break;
		case 1:
			//starTexture[i]->LoadFromFile("blueStar_small.png");
			starTexture[i]->LoadFromFile("BlueStar (HD).png");
			break;
		case 2:
			//starTexture[i]->LoadFromFile("stardust_red2.png");
			starTexture[i]->LoadFromFile("stardustRED(HD1).png");
			break;
		case 3:
			//starTexture[i]->LoadFromFile("stardust_green2.png");
			starTexture[i]->LoadFromFile("stardustGREEN(HD).png");
			break;
		case 4:
			//starTexture[i]->LoadFromFile("stardust_blue2.png");
			starTexture[i]->LoadFromFile("stardustBLUE(HD).png");
			break;
		case 5:
			//starTexture[i]->LoadFromFile("stardust_yellow2.png");
			starTexture[i]->LoadFromFile("stardustYELLOW(HD).png");
			break;
		case 6:
			//starTexture[i]->LoadFromFile("stardust_white.png");
			starTexture[i]->LoadFromFile("stardustWHITE(HD).png");
			break;
		}
		starTexture[i]->Upload();

		starMaterial[i] = new CIwMaterial();
		starMaterial[i]->SetTexture( starTexture[i] );
		if( i <= 1 )
			starMaterial[i]->SetAlphaMode( CIwMaterial::ALPHA_ADD );
		else
			starMaterial[i]->SetAlphaMode( CIwMaterial::ALPHA_ADD );
		starMaterial[i]->SetColAmbient( 255, 255, 255, 255 );
		starMaterial[i]->SetColDiffuse( 255, 255, 255, 255 );
	}
	
	IwRandSeed( (int32)s3eTimerGetMs() );
	for( int i = 0; i < numStars; i++ )
	{
		// position coordinates
		int16 x = 0;
		int16 y = 0;
		int16 z = 0;

		//IwRandSeed( (int32)s3eTimerGetMs() );

		// using s*14 as maximum radius b/c radius of background is s*15
		x = IwRandMinMax( -1*s*14, s*14 + 1);
		y = IwRandMinMax( -1*s*14, s*14 + 1);
		z = IwRandMinMax( -1*s*14, s*14 + 1);

		BackgroundObject* tempStar = new BackgroundObject(s);
		
		tempStar->setPosition( CIwSVec3( x, y, z ) );
		tempStar->initialize( BackgroundObject::BLUESTAR_SMALL, starTexture[0]); // it doesn't matter what texture the star is initialized with. Rendering uses external star material
		// set the random rotation speed
		// calculate distance to determine rotation speed
		// stars further away will have slower speeds
		double distanceFromCenter = sqrt( pow(x, 2) + pow(y, 2) + pow(z, 2) );
		if( distanceFromCenter > s*10 )
		{
			tempStar->rotationSpeed = IwRandMinMax(0, 1 + 1 );
		}
		else if( distanceFromCenter > s*7 )
		{
			tempStar->rotationSpeed = IwRandMinMax(0, 1 + 1 );
		}
		else if( distanceFromCenter > s*4 )
		{
			tempStar->rotationSpeed = IwRandMinMax(2, 10 + 1 );
		}
		else
		{
			//tempStar->rotationSpeed = IwRandMinMax(5, 10 + 1 );
		}
		
		//tempStar->rotationSpeed *= 2;
		stars.push_back( *tempStar );

		for( int j = 0; j < 4; j++ )
		{
			starsVertexStream[i*4 + j] =  tempStar->vertexstream[j] + tempStar->position;
			starsNormalStream[i*4 + j] = fuzzyNormals[j];
			starsUVStream[i*4 + j] = tempStar->uvstream[j];
		}
	}

	// Create Materials
	sideBlueMaterial = new CIwMaterial;
	sideRedMaterial = new CIwMaterial;
	sideGreenMaterial = new CIwMaterial;
	sideYellowMaterial = new CIwMaterial;
	sidePurpleMaterial = new CIwMaterial;
	sideOrangeMaterial = new CIwMaterial;

	side1TempMaterial = new CIwMaterial;
	side2TempMaterial = new CIwMaterial;
	side3TempMaterial = new CIwMaterial;
	side4TempMaterial = new CIwMaterial;
	side5TempMaterial = new CIwMaterial;
	side6TempMaterial = new CIwMaterial;

	side1Material = new CIwMaterial;
	side2Material = new CIwMaterial;
	side3Material = new CIwMaterial;
	side4Material = new CIwMaterial;
	side5Material = new CIwMaterial;
	side6Material = new CIwMaterial;

	nullMaterial = new CIwMaterial;

	blueSolidMaterial = new CIwMaterial;
	greenSolidMaterial = new CIwMaterial;
	redSolidMaterial = new CIwMaterial;
	orangeSolidMaterial = new CIwMaterial;
	yellowSolidMaterial = new CIwMaterial;
	purpleSolidMaterial = new CIwMaterial;

	blueTransMaterial = new CIwMaterial;
	greenTransMaterial = new CIwMaterial;
	redTransMaterial = new CIwMaterial;
	orangeTransMaterial = new CIwMaterial;
	yellowTransMaterial = new CIwMaterial;
	purpleTransMaterial = new CIwMaterial;

	blueSolidShadowMaterial = new CIwMaterial;
	redSolidShadowMaterial = new CIwMaterial;
	greenSolidShadowMaterial = new CIwMaterial;
	yellowSolidShadowMaterial = new CIwMaterial;
	purpleSolidShadowMaterial = new CIwMaterial;
	orangeSolidShadowMaterial = new CIwMaterial;

	blueTransShadowMaterial = new CIwMaterial;
	redTransShadowMaterial = new CIwMaterial;
	greenTransShadowMaterial = new CIwMaterial;
	yellowTransShadowMaterial = new CIwMaterial;
	purpleTransShadowMaterial = new CIwMaterial;
	orangeTransShadowMaterial = new CIwMaterial;
}

void LoadMenuData()
{
	// hide adwhirl
	// s3eAdWhirlHide();

	/*
	// stop iad
	if( hasIAd == true )
	{
		if( s3eIOSIAdGetInt( S3E_IOSIAD_RUNNING ) == 1 )
		{
			s3eIOSIAdStop();
		}		
	}
	*/

	LoadSaveFile();

	menuDataTerminated = false;	

	int32 heapUsed = s3eMemoryGetInt(S3E_MEMORY_USED); // Free memory minus heap size

	// initialize menuscreens
	for( int i = 0; i < NUM_OF_MENU_SCREENS; i++ )
	{
		switch( i )
		{
		case 0:
			menuScreen[i].Initialize( MenuScreen::CHALLENGE );
			break;
		case 1:
			menuScreen[i].Initialize( MenuScreen::HIGH_SCORE );
			break;
		case 2:
			menuScreen[i].Initialize( MenuScreen::CREDITS );
			break;
		case 3:
			menuScreen[i].Initialize( MenuScreen::TUTORIAL );
			break;
		}
	}

	// initialize new story confirmation screen
	newStoryConfirmationScreen.Initialize( MenuScreen::NEW_STORY_CONFIRMATION );

	questionMarkScreen.Initialize( MenuScreen::QUESTION_MARK );
	
	// if only a new game is possible, no continue cube
	if( targetEpisode == 1 && startAtCheckpoint == false )
	{
		numOfActiveMenuCubes = 5;
	}
	else // if target episode is anything but one, make a continue cube
	{
		numOfActiveMenuCubes = 6;
	}

	
	// initialize menuCube
	for( int i = 0; i < numOfActiveMenuCubes; i++ )
	{
		switch( i )
		{
		case 0:
			menuCubes[i].Initialize( MenuCube::NEW, numOfActiveMenuCubes );DisplayLoading();
			break;
		case 1:
			menuCubes[i].Initialize( MenuCube::TUTORIAL, numOfActiveMenuCubes );DisplayLoading();
			break;
		case 2:
			menuCubes[i].Initialize( MenuCube::CREDITS, numOfActiveMenuCubes );DisplayLoading();
			break;
		case 3:
			menuCubes[i].Initialize( MenuCube::HIGH_SCORE, numOfActiveMenuCubes );DisplayLoading();
			break;
		case 4:
			if( trophies[4] == true ) // if the game was beat, enable rap icon in cube
			{
				menuCubes[i].Initialize( MenuCube::RAP_RECORD, numOfActiveMenuCubes );DisplayLoading();
			}
			else // If game was not beat, enable question mark icon in cube
			{
				menuCubes[i].Initialize( MenuCube::QUESTION_MARK, numOfActiveMenuCubes );DisplayLoading();
			}			
			break;
		case 5:
			menuCubes[i].Initialize( MenuCube::CONTINUE, numOfActiveMenuCubes );DisplayLoading();
			break;
		}
	}

	// swap position ID's if there is a continue
	if( targetEpisode == 1 && startAtCheckpoint == false )
	{
		// do nothing
	}
	else // if target episode is anything but one, make a continue cube
	{
		menuCubes[0].positionID = 5;
		menuCubes[5].positionID = 0;
		for( int i = 0; i < numOfActiveMenuCubes; i++ )
		{
			// this fixes the position of the menu cubes after they swap places, for some reason
			menuCubes[i].grabAndSetSwipe( 0 );
			menuCubes[i].releaseSwipe();
		}
		
	}

	Bubbly.Initialize( Fuzzy3D::BUBBLY );DisplayLoading();

	// initialize Trophy Screen background for displaying message
	//trophyMessageBackgroundImage = Iw2DCreateImage("trophyMessageBackground.png");DisplayLoading();
	trophyMessageBackgroundImage = Iw2DCreateImage("trophyMessageBackground(HD).png");DisplayLoading();
	trophyMessageBackgroundSprite.setImage( trophyMessageBackgroundImage );
	//trophyMessageBackgroundSprite.setSize( 480, 320 );
	trophyMessageBackgroundSprite.setSize( width, height );
	//trophyMessageBackgroundSprite.setUWidth( 480 );
	//trophyMessageBackgroundSprite.setUHeight( 320 );
	trophyMessageBackgroundSprite.setUWidth( 1024 );
	trophyMessageBackgroundSprite.setUHeight( 768 );
	trophyMessageBackgroundSprite.setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );

	// initialize trophy messages
	for( int i = 0; i < NUM_OF_TROPHY_MESSAGE_IMAGES; i++ )
	{
		switch( i )
		{
		case 0:
			trophyMessageImage[i] = Iw2DCreateImage("TrophyMessage100k(HD).png");DisplayLoading();			
			break;
		case 1:
			trophyMessageImage[i] = Iw2DCreateImage("TrophyMessage500k(HD).png");DisplayLoading();
			break;
		case 2:
			trophyMessageImage[i] = Iw2DCreateImage("TrophyMessagesRATE(HD).png");DisplayLoading();
			break;
		case 3:
			trophyMessageImage[i] = Iw2DCreateImage("TrophyMessage1m(HD).png");DisplayLoading();
			break;
		case 4:
			trophyMessageImage[i] = Iw2DCreateImage("TrophyMessageHERO(HD).png");DisplayLoading();
			break;
		case 5:
			trophyMessageImage[i] = Iw2DCreateImage("TrophyMessage100k-Earned(HD).png");DisplayLoading();
			break;
		case 6:
			trophyMessageImage[i] = Iw2DCreateImage("TrophyMessage500k-earned(HD).png");DisplayLoading();
			break;
		case 7:
			trophyMessageImage[i] = Iw2DCreateImage("TrophyMessagesRATE-earned(HD).png");DisplayLoading();
			break;
		case 8:
			trophyMessageImage[i] = Iw2DCreateImage("TrophyMessage1m-earned(HD).png");DisplayLoading();
			break;
		case 9:
			trophyMessageImage[i] = Iw2DCreateImage("TrophyMessageHERO-earned(HD).png");DisplayLoading();
			break;
		case 10:
			trophyMessageImage[i] = Iw2DCreateImage("TrophyMessagesNOCONNECTION(HD).png");DisplayLoading();
			break;
		}
	}

	//trophyMessageSprite.setSize( 480, 320 );
	trophyMessageSprite.setSize( width, height );
	//trophyMessageSprite.setUWidth( 480 );
	//trophyMessageSprite.setUHeight( 320 );
	trophyMessageSprite.setUWidth( 1024 );
	trophyMessageSprite.setUHeight( 768 );
	trophyMessageSprite.setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );

	// MENU TITLE IMAGES
	//IwGetResManager()->LoadGroup("menuData.group");
	//menuDataGroup = IwGetResManager()->GetGroupNamed("menuData");	

	swipeGlowImage = Iw2DCreateImage("Swipetoselect3TOUCHD(HD).png");DisplayLoading();
	swipeArrowsImage = Iw2DCreateImage("Swipetoselect3(HD).png");DisplayLoading();
	//menuTitleImage = Iw2DCreateImageResource("menuTitle");
	swipeArrowsSprite.setImage( swipeArrowsImage );
	//swipeArrowsSprite.setSize( 240, 70 );
	swipeArrowsSprite.setSize( width * .5, height * 0.31875 );
	//swipeArrowsSprite.setUWidth( 300 );
	//swipeArrowsSprite.setUHeight( 96 );
	swipeArrowsSprite.setUWidth( 700 );
	swipeArrowsSprite.setUHeight( 292 );
	//swipeArrowsSprite.setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight() - 32 );
	swipeArrowsSprite.setPosition( width/2, height * .9 );

	/*
	for( int i = 0; i < 4; i++ )
	{
		switch( i )
		{
		case 0:
			swipeArrowsImages[i] = Iw2DCreateImage("swipeArrows3.png");DisplayLoading();
			break;
		case 1:
			swipeArrowsImages[i] = Iw2DCreateImage("swipeArrows2.png");DisplayLoading();
			break;
		case 2:
			swipeArrowsImages[i] = Iw2DCreateImage("swipeArrows1.png");DisplayLoading();			
			break;
		case 3:
			swipeArrowsImages[i] = Iw2DCreateImage("swipeArrows4.png");DisplayLoading();			
			break;
		}
		
		swipeArrowsSprites[i].setImage( swipeArrowsImages[i] );
		swipeArrowsSprites[i].setDelayTime( 1 );
		swipeArrowsSprites[i].setSize( 512/2, 128/2 );
		swipeArrowsSprites[i].setUWidth( 512 );
		swipeArrowsSprites[i].setUHeight( 128 );
		swipeArrowsSprites[i].setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight() - 32 );
		swipeArrowsSprites[i].setTotalFrames( 16 );
		if( i == 3 )
		{
			swipeArrowsSprites[i].setTotalFrames( 11 );
		}
		swipeArrowsSprites[i].setRepeatCount( 1 );
	}
	*/
	
	menuTitleImage4 = Iw2DCreateImage("menuTitleShiny4.png");DisplayLoading();
	//menuTitleImage = Iw2DCreateImageResource("menuTitle");
	menuTitleSprite4.setImage( menuTitleImage4 );
	menuTitleSprite4.setDelayTime( 1 ); // wait half a second
	//menuTitleSprite4.setSize( 512 - 512/16, 128 - 128/16 );
	menuTitleSprite4.setSize( width, height * .375 );
	menuTitleSprite4.setUWidth( 512 );
	menuTitleSprite4.setUHeight( 128 );
	menuTitleSprite4.setTotalFrames( 11 );
	menuTitleSprite4.setRepeatCount( 1 );
	
	menuTitleImage3 = Iw2DCreateImage("menuTitleShiny3.png");DisplayLoading();
	//menuTitleImage = Iw2DCreateImageResource("menuTitle");
	menuTitleSprite3.setImage( menuTitleImage3 );
	menuTitleSprite3.setDelayTime( 1 ); // wait half a second
	//menuTitleSprite3.setSize( 512 - 512/16, 128 - 128/16 );
	menuTitleSprite3.setSize( width, height * .375 );
	menuTitleSprite3.setUWidth( 512 );
	menuTitleSprite3.setUHeight( 128 );
	menuTitleSprite3.setTotalFrames( 16 );
	menuTitleSprite3.setRepeatCount( 1 );

	menuTitleImage = Iw2DCreateImage("menuTitleShiny.png");DisplayLoading();
	//menuTitleImage = Iw2DCreateImageResource("menuTitle");
	menuTitleSprite.setImage( menuTitleImage );
	menuTitleSprite.setDelayTime( 2 ); // wait half a second
	//menuTitleSprite.setSize( 512 - 512/16, 128 - 128/16 );
	menuTitleSprite.setSize( width, height * .375 );
	menuTitleSprite.setUWidth( 512 );
	menuTitleSprite.setUHeight( 128 );
	menuTitleSprite.setTotalFrames( 16 );
	menuTitleSprite.setRepeatCount( 1 );

	menuTitleImage2 = Iw2DCreateImage("menuTitleShiny2.png");DisplayLoading();
	//menuTitleImage2 = Iw2DCreateImageResource("menuTitle2");
	menuTitleSprite2.setImage( menuTitleImage2 );
	menuTitleSprite2.setDelayTime( 2 ); // wait half a second
	//menuTitleSprite2.setSize( 512 - 512/16, 128 - 128/16 );
	menuTitleSprite2.setSize( width, height * .375 );
	menuTitleSprite2.setUWidth( 512 );
	menuTitleSprite2.setUHeight( 128 );
	menuTitleSprite2.setTotalFrames( 16 );
	menuTitleSprite2.setRepeatCount( 1 );

	int32 heapUsed2 = s3eMemoryGetInt(S3E_MEMORY_USED); // Free memory minus heap size
	printf("Finished Loading Menu data. Memory loaded was %d \n", heapUsed2 - heapUsed );
	
	
	/*
	menuTitleImage = Iw2DCreateImage("test.png");DisplayLoading();
	menuTitleSprite.setImage( menuTitleImage );
	menuTitleSprite.setDelayTime( 2 ); // wait half a second
	menuTitleSprite.setSize( 480, 128 );
	menuTitleSprite.setUWidth( 128 );
	menuTitleSprite.setUHeight( 128 );
	//menuTitleSprite.setTotalFrames( 15 );
	menuTitleSprite.setRepeatCount( 1 );

	menuTitleImage2 = Iw2DCreateImage("test.png");DisplayLoading();
	menuTitleSprite2.setImage( menuTitleImage2 );
	menuTitleSprite2.setDelayTime( 2 ); // wait half a second
	menuTitleSprite2.setSize( 480, 128 );
	menuTitleSprite2.setUWidth( 128 );
	menuTitleSprite2.setUHeight( 128 );
	//menuTitleSprite2.setTotalFrames( 14 );
	menuTitleSprite2.setRepeatCount( 1 );
	*/


	//menuTitleSprite.playAnimation = false ;
	//menuTitleSprite2.playAnimation = false;
	
} // end of loadmenudata()

void TerminateMenuData()
{	
	// terminate iad
	if( hasIAd == true )
	{
		if( s3eIOSIAdGetInt( S3E_IOSIAD_RUNNING ) == 1 )
		{
			s3eIOSIAdStop();
		}
	}
	
	int32 heapUsed = s3eMemoryGetInt(S3E_MEMORY_USED); // Free memory minus heap size
			
	for( int i = 0; i < NUM_OF_MENU_SCREENS; i++ )
	{
		menuScreen[i].Terminate();
	}

	newStoryConfirmationScreen.Terminate();

	questionMarkScreen.Terminate();
	
	for( int i = 0; i < numOfActiveMenuCubes; i++ )
	{
		menuCubes[i].Terminate();
	}
	Bubbly.Terminate();
	delete trophyMessageBackgroundImage;
	for( int i = 0; i < NUM_OF_TROPHY_MESSAGE_IMAGES; i++ )
	{
		delete trophyMessageImage[i];
	}

	delete swipeGlowImage;
	delete swipeArrowsImage;

	//IwGetResManager()->DestroyGroup("menuData");

	delete menuTitleImage;
	delete menuTitleImage2;
	delete menuTitleImage3;
	delete menuTitleImage4;

	for( int i = 0; i < 4; i++ )
	{
		//delete swipeArrowsImages[i];
	}
	
	int32 heapUsed2 = s3eMemoryGetInt(S3E_MEMORY_USED); // Free memory minus heap size
	printf("Finished Terminating Menu data. Memory Freed was %d \n", heapUsed2 - heapUsed );
}

void LoadLevelData()
{
	int32 heapUsed = s3eMemoryGetInt(S3E_MEMORY_USED); // Free memory minus heap size

	// start iAd
	s3eInetAddress addr;
	if( s3eInetLookup( "www.apple.com", &addr, NULL, NULL) == S3E_RESULT_ERROR )
	{
		printf("\n\n Lookup failed!! \n");
	}
	else
	{
		if( hasIAd == true )
		{
			s3eIOSIAdStart();
			printf("Started iAd.\n");
		}
	}

	if( targetEpisode == 1 )
	{
		// initialize tutorial message bubble sprites
		for( int i = 0; i < NUM_OF_TUTORIAL_MESSAGES; i++ )
		{
			switch( i )
			{
			case 0:
				tutorialImages[i] = Iw2DCreateImage("Tutorialmessage00(HD).png");DisplayLoading();
				break;
			case 1:
				tutorialImages[i] = Iw2DCreateImage("Tutorialmessage01(HD).png");DisplayLoading();
				break;
			case 2:
				tutorialImages[i] = Iw2DCreateImage("Tutorialmessage02(HD).png");DisplayLoading();
				break;
			case 3:
				tutorialImages[i] = Iw2DCreateImage("Tutorialmessage03(HD).png");DisplayLoading();
				break;
			case 4:
				tutorialImages[i] = Iw2DCreateImage("Tutorialmessage04(HD).png");DisplayLoading();
				break;
			case 5:
				tutorialImages[i] = Iw2DCreateImage("Tutorialmessage05(HD).png");DisplayLoading();
				break;
			case 6:
				tutorialImages[i] = Iw2DCreateImage("Tutorialmessage06(HD).png");DisplayLoading();
				break;
			case 7:
				tutorialImages[i] = Iw2DCreateImage("Tutorialmessage07(HD).png");DisplayLoading();
				break;
			case 8:
				tutorialImages[i] = Iw2DCreateImage("Tutorialmessage08(HD).png");DisplayLoading();
				break;
			case 9:
				tutorialImages[i] = Iw2DCreateImage("Tutorialmessage09(HD).png");DisplayLoading();
				break;
			case 10:
				tutorialImages[i] = Iw2DCreateImage("Tutorialmessage10(HD).png");DisplayLoading();
				break;
			case 11:
				tutorialImages[i] = Iw2DCreateImage("Tutorialmessage11(HD).png");DisplayLoading();
				break;
			}

			tutorialSprites[i].setUWidth( 512 );
			tutorialSprites[i].setUHeight( 512 );
			//tutorialSprites[i].setSize( 100, 100 );
			tutorialSprites[i].setSize( width * .208, width * .208 );
			tutorialSprites[i].setImage( tutorialImages[i] );
			
			// this is exception for plane shift image
			if( i == 3 || i == 4 || i == 10 )
			{
				tutorialSprites[i].setUWidth( 1024 );
				tutorialSprites[i].setUHeight( 768 );
				//tutorialSprites[i].setSize( 480, 320 );
				tutorialSprites[i].setSize( width, height );
				tutorialSprites[i].setImage( tutorialImages[i] );
			}
			else if( i == 9 ) // this is the donotdie image
			{
				tutorialSprites[i].setUWidth( 512 );
				tutorialSprites[i].setUHeight( 512 );
				//tutorialSprites[i].setSize( 256, 256 );
				tutorialSprites[i].setSize( width * .533, width * .533 );
				tutorialSprites[i].setImage( tutorialImages[i] );
			}
			else if( i == 11 ) // this is do not stack cubes image
			{
				tutorialSprites[i].setUWidth( 512 );
				tutorialSprites[i].setUHeight( 512 );
				//tutorialSprites[i].setSize( 200, 200 );
				tutorialSprites[i].setSize( width * .416, width * .416 );
				tutorialSprites[i].setImage( tutorialImages[i] );
			}
		}
	}
	

	// initialize quit confirmation screen
	quitConfirmationScreen.Initialize( MenuScreen::QUIT_CONFIRMATION );
	
	// bomb defused
	bombDefusedImage = Iw2DCreateImage( "bomb_defused.png" );DisplayLoading();
	bombDefusedSprite.setImage( bombDefusedImage );
	bombDefusedSprite.setUWidth( 128 );
	bombDefusedSprite.setUHeight( 128 );
	//bombDefusedSprite.setSize( 250, 250 );
	bombDefusedSprite.setSize( width * .521, width * .521 );
	bombDefusedSprite.setDelayTime( 1 );
	bombDefusedSprite.setTotalFrames( 60 );
	bombDefusedSprite.setRepeatCount( 1 );
	bombDefusedSprite.setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );

	// bomb alert
	bombAlertSprite.setUWidth( 128 );
	bombAlertSprite.setUHeight( 128 );
	//bombAlertSprite.setUWidth( 64 );
	//bombAlertSprite.setUHeight( 64 );
	//bombAlertSprite.setSize( 64, 64 );
	bombAlertSprite.setSize( width * .133, width * .133 );
	//bombAlertImage = Iw2DCreateImage( "bomb_alert.png" );DisplayLoading();
	bombAlertImage = Iw2DCreateImage( "Bombalert-Fbomb (HD).png" );DisplayLoading();
	bombAlertSprite.setImage( bombAlertImage );
	bombAlertSprite.setDelayTime( 1 );
	bombAlertSprite.setTotalFrames( 30 );
	bombAlertSprite.setPosition( IwGxGetScreenWidth() * 2/3 - width*.042, 0+height*.156 );

	//bombAlertImage_wtf = Iw2DCreateImage( "bomb_alert_wtf2.png" );DisplayLoading();
	bombAlertImage_wtf = Iw2DCreateImage( "Bombalert-WTF (HD).png" );DisplayLoading();


	// level bar	
	progressBarSprite.setUWidth( 110 );
	progressBarSprite.setUHeight( 20 );
	//progressBarSprite.setSize( 110, 20 );
	progressBarSprite.setSize( width * .229, height * 0.063 );
	progressBarImage = Iw2DCreateImage( "hud_levelbar.png" );DisplayLoading();
	progressBarSprite.setImage( progressBarImage );
	progressBarSprite.setDelayTime( 1 );
	
	
	progressBarFrameSprite.setUWidth( 110 );
	progressBarFrameSprite.setUHeight( 20 );
	//progressBarFrameSprite.setSize( 110, 20 );
	progressBarFrameSprite.setSize( width * .229, height * 0.063 );
	progressBarFrameImage = Iw2DCreateImage( "hud_levelbarframe.png" );DisplayLoading();
	progressBarFrameSprite.setImage( progressBarFrameImage );

	// pixie dust images
	pixieImage = Iw2DCreateImage("pixiedust.png");DisplayLoading();
	for( int i = 0; i < 3; i++ )
	{
		pixieSprite[i].setUWidth( 128 );
		pixieSprite[i].setUHeight( 128 );
		//pixieSprite[i].setSize( 175, 175 );
		pixieSprite[i].setSize( width * .365, width * .365 );
		pixieSprite[i].setImage( pixieImage );
		pixieSprite[i].setDelayTime( 1 );
		pixieSprite[i].setRepeatCount( 1 );
		pixieSprite[i].setTotalFrames( 25 );
		pixieSprite[i].setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );

		showPixieDust[i] = false;
	}

	DisplayLoading();

	// load game over sprite
	//gameOverSprite.setUWidth( 480 );
	//gameOverSprite.setUHeight( 240 );
	//gameOverSprite.setSize( 480, 240 );
	gameOverSprite.setUWidth( 1024 );
	gameOverSprite.setUHeight( 512 );
	gameOverSprite.setSize( width, height * .75 );
	gameOverImage = Iw2DCreateImage( "gameover(HD).png" );DisplayLoading();
	gameOverSprite.setImage( gameOverImage );
	gameOverSprite.setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2);

	// load trophy sprite
	trophySprite.setUWidth( 128 );
	trophySprite.setUHeight( 128 );
	//trophySprite.setSize( 96, 96 );
	trophySprite.setSize( width * .2, width * .2 );
	trophySpriteImage = Iw2DCreateImage( "trophySprite.png" );DisplayLoading();
	trophySprite.setImage( trophySpriteImage );
	trophySprite.setDelayTime( 1 );
	trophySprite.setRepeatCount( 1 );
	trophySprite.setTotalFrames( 32 );
	//trophySprite.setPosition( IwGxGetScreenWidth() - 40, 0 + 100 );
	trophySprite.setPosition( IwGxGetScreenWidth() - width*.083, 0 + height*.312 );

	// load plus one fuzzy
	plusOneFuzzySprite.setUWidth( 128 );
	plusOneFuzzySprite.setUHeight( 128 );
	//plusOneFuzzySprite.setSize( 128, 128 );
	plusOneFuzzySprite.setSize( width * .267, width * .267 );
	plusOneFuzzyImage = Iw2DCreateImage( "plusonefuzzy.png" );DisplayLoading();
	plusOneFuzzySprite.setImage( plusOneFuzzyImage );
	plusOneFuzzySprite.setDelayTime( 1 );
	plusOneFuzzySprite.setRepeatCount( 1 );
	plusOneFuzzySprite.setTotalFrames( 24 );
	//plusOneFuzzySprite.setPosition( IwGxGetScreenWidth() - 20, 0 + 50 );
	plusOneFuzzySprite.setPosition( IwGxGetScreenWidth() - width*.042, 0 + height*.156 );

	// Congrats Images	
	congratsSpriteLevelUp.setUWidth( 128 );
	congratsSpriteLevelUp.setUHeight( 128 );
	//congratsSpriteLevelUp.setSize( 250, 250 );
	congratsSpriteLevelUp.setSize( width * .521, width * .521 );
	congratsImageLevelUp = Iw2DCreateImage( "congratsLevelUp.png" );DisplayLoading();
	congratsSpriteLevelUp.setImage( congratsImageLevelUp );
	congratsSpriteLevelUp.setDelayTime( 1 );
	congratsSpriteLevelUp.setRepeatCount( 1 );
	congratsSpriteLevelUp.setTotalFrames( 38 );
	congratsSpriteLevelUp.setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );

	// Congrats Images
	congratsSpriteNice.setUWidth( 128 );
	congratsSpriteNice.setUHeight( 128 );
	//congratsSpriteNice.setSize( 128, 128 );
	congratsSpriteNice.setSize( width * .267, width * .267 );
	congratsImageNice = Iw2DCreateImage( "congratsNice.png" );DisplayLoading();
	congratsSpriteNice.setImage( congratsImageNice );
	congratsSpriteNice.setDelayTime( 1 );
	congratsSpriteNice.setRepeatCount( 1 );
	congratsSpriteNice.setTotalFrames( 28 );

	congratsSpriteComplete.setUWidth( 128 );
	congratsSpriteComplete.setUHeight( 128 );
	//congratsSpriteComplete.setSize( 384, 384 );
	congratsSpriteComplete.setSize( width * .8, width * .8 );
	congratsImageComplete = Iw2DCreateImage( "congratsComplete.png" );DisplayLoading();
	congratsSpriteComplete.setImage( congratsImageComplete );
	congratsSpriteComplete.setDelayTime( 1 );
	congratsSpriteComplete.setRepeatCount( 1 );
	congratsSpriteComplete.setTotalFrames( 30 );

	congratsSpriteSuper.setUWidth( 128 );
	congratsSpriteSuper.setUHeight( 128 );
	//congratsSpriteSuper.setSize( 250, 250 );
	congratsSpriteSuper.setSize( width * .521, width * .521 );
	congratsImageSuper = Iw2DCreateImage( "congratsSuper.png" );DisplayLoading();
	congratsSpriteSuper.setImage( congratsImageSuper );
	congratsSpriteSuper.setDelayTime( 1 );
	congratsSpriteSuper.setRepeatCount( 1 );
	congratsSpriteSuper.setTotalFrames( 30 );
	
	congratsSpriteGreat.setUWidth( 128 );
	congratsSpriteGreat.setUHeight( 128 );
	//congratsSpriteGreat.setSize( 250, 250 );
	congratsSpriteGreat.setSize( width * .521, width * .521 );
	congratsImageGreat = Iw2DCreateImage( "congratsGreat.png" );DisplayLoading();
	congratsSpriteGreat.setImage( congratsImageGreat );
	congratsSpriteGreat.setDelayTime( 1 );
	congratsSpriteGreat.setRepeatCount( 1 );
	congratsSpriteGreat.setTotalFrames( 30 );

	// initialize minus one fuzzy
	minusOneFuzzyImage = Iw2DCreateImage( "MinusoneFuzzy(HD).png" );DisplayLoading();
	for( int i = 0; i < 6; i++ )
	{
		for( int j = 0; j < 9; j++ )
		{
			//minusOneFuzzySprite[i][j].setUWidth( 64 );
			//minusOneFuzzySprite[i][j].setUHeight( 64 );
			//minusOneFuzzySprite[i][j].setSize( 64, 64 );
			minusOneFuzzySprite[i][j].setUWidth( 128 );
			minusOneFuzzySprite[i][j].setUHeight( 128 );
			minusOneFuzzySprite[i][j].setSize( width * .133, width * .133 );

			minusOneFuzzySprite[i][j].setImage( minusOneFuzzyImage );

			minusOneFuzzySprite[i][j].setTotalFrames( 30 );
			minusOneFuzzySprite[i][j].setDelayTime( 1 );
			minusOneFuzzySprite[i][j].setRepeatCount( 1 );

			minusOneFuzzy[i][j] = false;
		}
	}

		// SCORE images
	/*
	pointImage50 = Iw2DCreateImage("50.png");DisplayLoading();
	pointImage500 = Iw2DCreateImage("500.png");DisplayLoading();
	pointImage5000 = Iw2DCreateImage("5000.png");DisplayLoading();
	pointImage100 = Iw2DCreateImage("100.png");DisplayLoading();
	pointImage1000 = Iw2DCreateImage("1000.png");DisplayLoading();
	pointImage10000 = Iw2DCreateImage("10000.png");DisplayLoading();
	*/

	pointImage50 = Iw2DCreateImage("50 (HD).png");DisplayLoading();
	pointImage500 = Iw2DCreateImage("500 (HD2).png");DisplayLoading();
	pointImage5000 = Iw2DCreateImage("5000 (HD2).png");DisplayLoading();
	pointImage100 = Iw2DCreateImage("100 (HD2).png");DisplayLoading();
	pointImage1000 = Iw2DCreateImage("1000 (HD).png");DisplayLoading();
	pointImage10000 = Iw2DCreateImage("10000 (HD).png");DisplayLoading();
	
	// initialize all the plus points sprites
	for( int i = 0; i < 7; i++ )
	{
		for( int j = 0; j < 4; j++ )
		{
			pointSprites[i][j].setUWidth( 128 );
			pointSprites[i][j].setUHeight( 128 );
			//pointSprites[i][j].setSize( 64, 64 ); // not affected. hardcoded sizes for specific points
			//pointSprites[i][j].setSize( width * .133, width * .133 ); // not affected. hardcoded sizes for specific points
			pointSprites[i][j].setSize( 128, 128 ); // not affected. hardcoded sizes for specific points

			pointSprites[i][j].set100PointsImage( pointImage100 );
			pointSprites[i][j].set1000PointsImage( pointImage1000 );
			pointSprites[i][j].set10000PointsImage( pointImage10000 );

			pointSprites[i][j].set50PointsImage( pointImage50 );

			pointSprites[i][j].set500PointsImage( pointImage500 );
			pointSprites[i][j].set5000PointsImage( pointImage5000 );

			// additional optional settings
			pointSprites[i][j].setTotalFrames( 28 );
			pointSprites[i][j].setDelayTime( 1 );
			pointSprites[i][j].setRepeatCount( 1 );
		}
	}
	
	// here. make these resolution independent
	// load active square indicators
	blueSquare.Initialize( ActiveSquare::BLUE );DisplayLoading();
	redSquare.Initialize( ActiveSquare::RED );DisplayLoading();
	purpleSquare.Initialize( ActiveSquare::PURPLE );DisplayLoading();
	orangeSquare.Initialize( ActiveSquare::ORANGE );DisplayLoading();
	greenSquare.Initialize( ActiveSquare::GREEN );DisplayLoading();
	yellowSquare.Initialize(ActiveSquare::YELLOW );DisplayLoading();


	// FUZZY material and textures
	for( int i = 0; i < numFuzzyMaterials; i++ )
	{
		fuzzyMaterial[i] = new CIwMaterial;
		fuzzyTexture[i] = new CIwTexture;

		// load fuzzy image and
		// set the textures
		switch( i )
		{
		case 0:
			//fuzzyTexture[i]->LoadFromFile("fuzzy01_leftRight.png");
			//fuzzyTexture[i]->LoadFromFile("fuzzy_chromakey.png");
			//fuzzyTexture[i]->LoadFromFile("fuzzy_Sparky.png");
			fuzzyTexture[i]->LoadFromFile("fuzzy_Sparky_small.png");
			//fuzzyTexture[i]->LoadFromFile("fuzzy_Sparky.png");
			break;
		case 1:
			//fuzzyTexture[i]->LoadFromFile("fuzzy02_scared_chromakey.png");
			fuzzyTexture[i]->LoadFromFile("fuzzy_Bubbly_small.png");
			//fuzzyTexture[i]->LoadFromFile("fuzzy_Bubbly.png");
			break;
		case 2:
			//fuzzyTexture[i]->LoadFromFile("fuzzy02_scared_chromakey.png");
			fuzzyTexture[i]->LoadFromFile("fuzzy_Flakey_small.png");
			//fuzzyTexture[i]->LoadFromFile("fuzzy_Flakey.png");
		break;
		}

		fuzzyTexture[i]->Upload();
		fuzzyMaterial[i]->SetTexture( fuzzyTexture[i] );
		
		/*
		fuzzyMaterial[i]->CreateAnim();
		fuzzyMaterial[i]->SetAnimCelW( 128 );
		fuzzyMaterial[i]->SetAnimCelH( 128 );
		fuzzyMaterial[i]->SetAnimCelPeriod( 4 );
		fuzzyMaterial[i]->SetAnimCelNum( 16 );
		*/
		
		fuzzyMaterial[i]->SetColAmbient( 255, 255, 255, 255 );
		fuzzyMaterial[i]->SetColDiffuse( 255, 255, 255, 255 );	
		fuzzyMaterial[i]->SetAlphaMode( alphaValue_fuzzyMaterial );
	}

	DisplayLoading();

	// FUZZY EXPLODE materials and textures
	for( int i = 0; i < numFuzzyExplodeMaterials; i++ )
	{
		fuzzyExplodeMaterial[i] = new CIwMaterial;		
		fuzzyExplodeTexture[i] = new CIwTexture;

		// load fuzzy explode image and
		// set the textures
		switch( i )
		{
		case 0:
			fuzzyExplodeTexture[i]->LoadFromFile("fuzzy_boom2.png");
			//fuzzyExplodeTexture[i]->LoadFromFile("fuzzy_boom.png");
			//fuzzyExplodeTexture[i]->LoadFromFile("fuzzy_death_explode.png");
			break;
		case 1:
			break;
		}

		fuzzyExplodeTexture[i]->Upload();
		fuzzyExplodeMaterial[i]->SetTexture( fuzzyExplodeTexture[i] );

		/*
		fuzzyExplodeMaterial[i]->CreateAnim();
		fuzzyExplodeMaterial[i]->SetAnimCelW( 128 );
		fuzzyExplodeMaterial[i]->SetAnimCelH( 128 );
		fuzzyExplodeMaterial[i]->SetAnimCelPeriod( 2 );
		fuzzyExplodeMaterial[i]->SetAnimCelNum( 16 );
		*/
		
		fuzzyExplodeMaterial[i]->SetColAmbient( 255, 255, 255, 255 );
		fuzzyExplodeMaterial[i]->SetColDiffuse( 255, 255, 255, 255 );	
		fuzzyExplodeMaterial[i]->SetAlphaMode( alphaValue_fuzzyMaterial );
	}

	DisplayLoading();

	// load Bombs
	for( int i = 0; i < NUM_OF_BOMB_MATERIALS; i++ )
	{
		bombMaterial[i] = new CIwMaterial;		
		bombTexture[i] = new CIwTexture;

		// load fuzzy explode image and
		// set the textures
		switch( i )
		{
		case 0:
			bombTexture[i]->LoadFromFile("bomb1.png");DisplayLoading();
			//fuzzyExplodeTexture[i]->LoadFromFile("fuzzy_death_explode.png");
			break;
		case 1:
			bombTexture[i]->LoadFromFile("bomb2.png");DisplayLoading();
			break;
		case 2:
			bombTexture[i]->LoadFromFile("bomb3.png");DisplayLoading();
			break;		
		case 3:
			bombTexture[i]->LoadFromFile("bomb1_wtf2.png");DisplayLoading();
			break;
		case 4:
			bombTexture[i]->LoadFromFile("bomb2_wtf2.png");DisplayLoading();
			break;
		case 5:
			bombTexture[i]->LoadFromFile("bomb3_wtf2.png");DisplayLoading();
			break;
		}

		bombTexture[i]->Upload();
		bombMaterial[i]->SetTexture( bombTexture[i] );
		
		bombMaterial[i]->SetColAmbient( 255, 255, 255, 255 );
		bombMaterial[i]->SetColDiffuse( 255, 255, 255, 255 );	
		bombMaterial[i]->SetAlphaMode( alphaValue_fuzzyMaterial );
	}


	bombDefuseMaterial = new CIwMaterial;
	bombDefuseTexture = new CIwTexture;
	bombDefuseTexture->LoadFromFile( "fuzzy_implosion2.png" );
	//bombDefuseTexture->LoadFromFile( "fuzzy_implosion.png" );
	bombDefuseTexture->Upload();
	bombDefuseMaterial->SetTexture( bombDefuseTexture );
	bombDefuseMaterial->SetColAmbient( 255, 255, 255, 255 );
	bombDefuseMaterial->SetColDiffuse( 255, 255, 255, 255 );	

	bombExplodeMaterial = new CIwMaterial;
	bombExplodeTexture = new CIwTexture;
	bombExplodeTexture->LoadFromFile( "fuzzy_boom2.png" );
	//bombExplodeTexture->LoadFromFile( "fuzzy_boom.png" );
	bombExplodeTexture->Upload();
	bombExplodeMaterial->SetTexture( bombExplodeTexture );
	bombExplodeMaterial->SetColAmbient( 255, 255, 255, 255 );
	bombExplodeMaterial->SetColDiffuse( 255, 255, 255, 255 );	

	warpingTextureGolden = new CIwTexture;
	warpingTextureGolden->LoadFromFile("warpingTextureGolden.png");DisplayLoading();
	warpingTextureGolden->Upload();

	explodingTextureRed = new CIwTexture;
	explodingTextureRed->LoadFromFile("explodingTextureRed.png");DisplayLoading();
	explodingTextureRed->Upload();

	

	// Material Textures
	// these are HD graphics. 128 pixels
	cubeTextureBlue = new CIwTexture;
	cubeTextureBlue->LoadFromFile("cubetexture-blue.png");DisplayLoading();
	cubeTextureBlue->Upload();
	cubeTextureRed = new CIwTexture;
	cubeTextureRed->LoadFromFile("cubetexture-red.png");DisplayLoading();
	cubeTextureRed->Upload();
	cubeTextureGreen = new CIwTexture;
	cubeTextureGreen->LoadFromFile("cubetexture-green.png");DisplayLoading();
	cubeTextureGreen->Upload();
	cubeTextureYellow = new CIwTexture;
	cubeTextureYellow->LoadFromFile("cubetexture-yellow.png");DisplayLoading();
	cubeTextureYellow->Upload();
	cubeTextureOrange = new CIwTexture;
	cubeTextureOrange->LoadFromFile("cubetexture-orange.png");DisplayLoading();
	cubeTextureOrange->Upload();
	cubeTexturePurple = new CIwTexture;
	cubeTexturePurple->LoadFromFile("cubetexture-purple.png");DisplayLoading();
	cubeTexturePurple->Upload();

	DisplayLoading();

	/*
	planeTextureBlue = new CIwTexture;
	planeTextureBlue->LoadFromFile("shadowTextureBlue.png");
	planeTextureBlue->Upload();
	planeTextureRed = new CIwTexture;
	planeTextureRed->LoadFromFile("shadowTextureRed.png");
	planeTextureRed->Upload();
	planeTextureGreen = new CIwTexture;
	planeTextureGreen->LoadFromFile("shadowTextureGreen.png");
	planeTextureGreen->Upload();
	planeTextureYellow = new CIwTexture;
	planeTextureYellow->LoadFromFile("shadowTextureYellow.png");
	planeTextureYellow->Upload();
	planeTextureOrange = new CIwTexture;
	planeTextureOrange->LoadFromFile("shadowTextureOrange.png");
	planeTextureOrange->Upload();
	planeTexturePurple = new CIwTexture;
	planeTexturePurple->LoadFromFile("shadowTexturePurple.png");
	planeTexturePurple->Upload();
	*/

	shadowTextureBlue = new CIwTexture;
	shadowTextureBlue->LoadFromFile("shadowTextureBlue.png");DisplayLoading();
	shadowTextureBlue->Upload();
	shadowTextureRed = new CIwTexture;
	shadowTextureRed->LoadFromFile("shadowTextureRed.png");DisplayLoading();
	shadowTextureRed->Upload();
	shadowTextureGreen = new CIwTexture;
	shadowTextureGreen->LoadFromFile("shadowTextureGreen.png");DisplayLoading();
	shadowTextureGreen->Upload();
	shadowTextureYellow = new CIwTexture;
	shadowTextureYellow->LoadFromFile("shadowTextureYellow.png");DisplayLoading();
	shadowTextureYellow->Upload();
	shadowTextureOrange = new CIwTexture;
	shadowTextureOrange->LoadFromFile("shadowTextureOrange.png");DisplayLoading();
	shadowTextureOrange->Upload();
	shadowTexturePurple = new CIwTexture;
	shadowTexturePurple->LoadFromFile("shadowTexturePurple.png");DisplayLoading();
	shadowTexturePurple->Upload();

	DisplayLoading();

	
	
	// SPRITES	
	livesSprite.setUWidth( 64 );
	livesSprite.setUHeight( 64 );
	//livesSprite.setSize( 32, 32 );
	livesSprite.setSize( width * .067, width * .067 );
	livesImage = Iw2DCreateImage("fuzzy_FireFuzz_small.png");DisplayLoading();
	livesSprite.setImage( livesImage );
	livesSprite.setDelayTime( 2 );

	//progressBarFuzzySprite.setUWidth( 64 );
	//progressBarFuzzySprite.setUHeight( 64 );
	progressBarFuzzySprite.setUWidth( 128 );
	progressBarFuzzySprite.setUHeight( 128 );
	//progressBarFuzzySprite.setSize( 40, 40 );
	progressBarFuzzySprite.setSize( width * .083, width * .083 );
	//spacebusImage = Iw2DCreateImage("spacebus.png");DisplayLoading()
	spacebusImage = Iw2DCreateImage("Spacebus(HD).png");DisplayLoading();
	progressBarFuzzySprite.setImage( spacebusImage );
	progressBarFuzzySprite.setDelayTime( 1 );
	progressBarFuzzySprite.setTotalFrames( 13 );

	progressBarGlowImage = Iw2DCreateImage("progressBarGlow.png");DisplayLoading();
	progressBarGlowSprite.setUWidth( 64 );
	progressBarGlowSprite.setUHeight( 64 );
	//progressBarGlowSprite.setSize( 75, 75 );
	progressBarGlowSprite.setSize( width * .156, width * .156 );
	progressBarGlowSprite.setImage( progressBarGlowImage );
	progressBarGlowSprite.setDelayTime( 1 );
	progressBarGlowSprite.setTotalFrames( 25 );

	// Difficulty buttons
	/*
	difficultyStartImage = Iw2DCreateImage("rotate.png");DisplayLoading();
	difficultyStartSprite.setUWidth( 64 );
	difficultyStartSprite.setUHeight( 64 );
	difficultyStartSprite.setSize( 64, 64 );
	difficultyStartSprite.setImage( difficultyStartImage );
	difficultyStartImage_pressed = Iw2DCreateImage("rotate_pressed.png");DisplayLoading();
	difficultyStartSprite_pressed.setUWidth( 64 );
	difficultyStartSprite_pressed.setUHeight( 64 );
	difficultyStartSprite_pressed.setSize( 64, 64 );
	difficultyStartSprite_pressed.setImage( difficultyStartImage_pressed );
	difficultyStartButton.setTouchSize( 64, 64 );
	difficultyStartButton.setUnpressedSprite( difficultyStartSprite );
	difficultyStartButton.setPressedSprite( difficultyStartSprite_pressed );

	difficultyEasyImage = Iw2DCreateImage("rotate.png");DisplayLoading();
	difficultyEasySprite.setUWidth( 64 );
	difficultyEasySprite.setUHeight( 64 );
	difficultyEasySprite.setSize( 64, 64 );
	difficultyEasySprite.setImage( difficultyEasyImage );
	difficultyEasyImage_pressed = Iw2DCreateImage("rotate_pressed.png");DisplayLoading();
	difficultyEasySprite_pressed.setUWidth( 64 );
	difficultyEasySprite_pressed.setUHeight( 64 );
	difficultyEasySprite_pressed.setSize( 64, 64 );
	difficultyEasySprite_pressed.setImage( difficultyEasyImage_pressed );
	difficultyEasyButton.setTouchSize( 64, 64 );
	difficultyEasyButton.setUnpressedSprite( difficultyEasySprite );
	difficultyEasyButton.setPressedSprite( difficultyEasySprite_pressed );

	difficultyMediumImage = Iw2DCreateImage("rotate.png");DisplayLoading();
	difficultyMediumSprite.setUWidth( 64 );
	difficultyMediumSprite.setUHeight( 64 );
	difficultyMediumSprite.setSize( 64, 64 );
	difficultyMediumSprite.setImage( difficultyMediumImage );
	difficultyMediumImage_pressed = Iw2DCreateImage("rotate_pressed.png");DisplayLoading();
	difficultyMediumSprite_pressed.setUWidth( 64 );
	difficultyMediumSprite_pressed.setUHeight( 64 );
	difficultyMediumSprite_pressed.setSize( 64, 64 );
	difficultyMediumSprite_pressed.setImage( difficultyMediumImage_pressed );
	difficultyMediumButton.setTouchSize( 64, 64 );
	difficultyMediumButton.setUnpressedSprite( difficultyMediumSprite );
	difficultyMediumButton.setPressedSprite( difficultyMediumSprite_pressed );

	difficultyHardImage = Iw2DCreateImage("rotate.png");DisplayLoading();
	difficultyHardSprite.setUWidth( 64 );
	difficultyHardSprite.setUHeight( 64 );
	difficultyHardSprite.setSize( 64, 64 );
	difficultyHardSprite.setImage( difficultyHardImage );
	difficultyHardImage_pressed = Iw2DCreateImage("rotate_pressed.png");DisplayLoading();
	difficultyHardSprite_pressed.setUWidth( 64 );
	difficultyHardSprite_pressed.setUHeight( 64 );
	difficultyHardSprite_pressed.setSize( 64, 64 );
	difficultyHardSprite_pressed.setImage( difficultyHardImage_pressed );
	difficultyHardButton.setTouchSize( 64, 64 );
	difficultyHardButton.setUnpressedSprite( difficultyHardSprite );
	difficultyHardButton.setPressedSprite( difficultyHardSprite_pressed );
	*/

	// Test Button

	testButtonImage = Iw2DCreateImage("Rotate.png");DisplayLoading();
	testButtonSprite.setImage( testButtonImage );
	testButtonSprite.setUWidth( 64 );
	testButtonSprite.setUHeight( 64 );
	testButtonSprite.setSize( 64, 64 );
	testButtonImage_pressed = Iw2DCreateImage("RotatePressed.png");DisplayLoading();
	testButtonSprite_pressed.setImage( testButtonImage_pressed );
	testButtonSprite_pressed.setUWidth( 64 );
	testButtonSprite_pressed.setUHeight( 64 );
	testButtonSprite_pressed.setSize( 64, 64 );
	testButton.setTouchSize( 64, 64 );
	testButton.setUnpressedSprite( testButtonSprite );
	testButton.setPressedSprite( testButtonSprite_pressed );	


	//scoreScreenImage = Iw2DCreateImage("scoreScreen.png");DisplayLoading();
	scoreScreenImage = Iw2DCreateImage("scorescreen(HD).png");DisplayLoading();
	scoreScreenSprite.setImage( scoreScreenImage );
	//scoreScreenSprite.setUWidth( 480 );
	//scoreScreenSprite.setUHeight( 320 );
	scoreScreenSprite.setUWidth( 1024 );
	scoreScreenSprite.setUHeight( 768 );
	//scoreScreenSprite.setSize( 480, 320 );
	scoreScreenSprite.setSize( width, height );
	scoreScreenSprite.setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );

	pausedBackgroundImage = Iw2DCreateImage("pausedBackground.png");DisplayLoading();
	pausedBackgroundSprite.setImage( pausedBackgroundImage );
	pausedBackgroundSprite.setUWidth( 480 );
	pausedBackgroundSprite.setUHeight( 320 );
	//pausedBackgroundSprite.setSize( 480, 320 );
	pausedBackgroundSprite.setSize( width, height );
	pausedBackgroundSprite.setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 );

	//pauseButtonImage = Iw2DCreateImage("pause.png");
	pauseButtonImage = Iw2DCreateImage("Pause(HD).png");
	//pauseButtonSprite.setUWidth( 64 );
	//pauseButtonSprite.setUHeight( 64 );
	pauseButtonSprite.setUWidth( 256 );
	pauseButtonSprite.setUHeight( 256 );
	//pauseButtonSprite.setSize( 50, 50 );
	pauseButtonSprite.setSize( width * .104, width * .104 );
	pauseButtonSprite.setImage( pauseButtonImage );
	//pauseButtonImage_pressed = Iw2DCreateImage("pause_pressed.png");DisplayLoading();
	pauseButtonImage_pressed = Iw2DCreateImage("Pausepressed(HD).png");DisplayLoading();
	//pauseButtonSprite_pressed.setUWidth( 64 );
	//pauseButtonSprite_pressed.setUHeight( 64 );
	pauseButtonSprite_pressed.setUWidth( 256 );
	pauseButtonSprite_pressed.setUHeight( 256 );
	//pauseButtonSprite_pressed.setSize( 50, 50 );
	pauseButtonSprite_pressed.setSize( width * .104, width * .104 );
	pauseButtonSprite_pressed.setImage( pauseButtonImage_pressed );
	//pauseButton.setTouchSize( 64, 64 );
	pauseButton.setTouchSize( width * .133, width * .133 );
	pauseButton.setUnpressedSprite( pauseButtonSprite );
	pauseButton.setPressedSprite( pauseButtonSprite_pressed );	

	//resumeButtonImage = Iw2DCreateImage("resume.png");DisplayLoading();
	resumeButtonImage = Iw2DCreateImage("Resume(HD).png");DisplayLoading();
	//resumeButtonSprite.setUWidth( 128 );
	//resumeButtonSprite.setUHeight( 128 );
	resumeButtonSprite.setUWidth( 256 );
	resumeButtonSprite.setUHeight( 256 );
	//resumeButtonSprite.setSize( 128, 128 );
	resumeButtonSprite.setSize( width * .267, width * .267 );
	resumeButtonSprite.setImage( resumeButtonImage );
	//resumeButtonImage_pressed = Iw2DCreateImage("resume_pressed.png");
	resumeButtonImage_pressed = Iw2DCreateImage("ResumePressed(HD).png");
	//resumeButtonSprite_pressed.setUWidth( 128 );
	//resumeButtonSprite_pressed.setUHeight( 128 );
	resumeButtonSprite_pressed.setUWidth( 256 );
	resumeButtonSprite_pressed.setUHeight( 256 );
	//resumeButtonSprite_pressed.setSize( 128, 128 );
	resumeButtonSprite_pressed.setSize( width * .267, width * .267 );
	resumeButtonSprite_pressed.setImage( resumeButtonImage_pressed );
	//resumeButton.setTouchSize( 128, 128 );
	resumeButton.setTouchSize( width * .267, width * .267 );
	resumeButton.setUnpressedSprite( resumeButtonSprite );
	resumeButton.setPressedSprite( resumeButtonSprite_pressed );	

	//quitButtonImage = Iw2DCreateImage("quit.png");DisplayLoading();
	//quitButtonSprite.setUWidth( 128 );
	//quitButtonSprite.setUHeight( 128 );
	quitButtonImage = Iw2DCreateImage("Quit(HD).png");DisplayLoading();
	quitButtonSprite.setUWidth( 256 );
	quitButtonSprite.setUHeight( 256 );
	//quitButtonSprite.setSize( 128, 128 );
	quitButtonSprite.setSize( width * .267, width * .267 );
	quitButtonSprite.setImage( quitButtonImage );
	//quitButtonImage_pressed = Iw2DCreateImage("quit_pressed.png");
	//quitButtonSprite_pressed.setUWidth( 128 );
	//quitButtonSprite_pressed.setUHeight( 128 );
	quitButtonImage_pressed = Iw2DCreateImage("Quitpressed(HD).png");
	quitButtonSprite_pressed.setUWidth( 256 );
	quitButtonSprite_pressed.setUHeight( 256 );
	//quitButtonSprite_pressed.setSize( 128, 128 );
	quitButtonSprite_pressed.setSize( width * .267, width * .267 );
	quitButtonSprite_pressed.setImage( quitButtonImage_pressed );
	//quitButton.setTouchSize( 128, 128 );
	quitButton.setTouchSize( width * .267, width * .267 );
	quitButton.setUnpressedSprite( quitButtonSprite );
	quitButton.setPressedSprite( quitButtonSprite_pressed );	

	//restartButtonImage = Iw2DCreateImage("restart.png");DisplayLoading();
	//restartButtonSprite.setUWidth( 128 );
	//restartButtonSprite.setUHeight( 128 );
	//restartButtonSprite.setSize( 128, 128 );
	restartButtonImage = Iw2DCreateImage("Restart(HD).png");DisplayLoading();
	restartButtonSprite.setUWidth( 256 );
	restartButtonSprite.setUHeight( 256 );
	restartButtonSprite.setSize( width * .267, width * .267 );
	restartButtonSprite.setImage( restartButtonImage );
	//restartButtonImage_pressed = Iw2DCreateImage("restart_pressed.png");
	//restartButtonSprite_pressed.setUWidth( 128 );
	//restartButtonSprite_pressed.setUHeight( 128 );
	//restartButtonSprite_pressed.setSize( 128, 128 );
	restartButtonImage_pressed = Iw2DCreateImage("Restartpressed(HD).png");
	restartButtonSprite_pressed.setUWidth( 256 );
	restartButtonSprite_pressed.setUHeight( 256 );
	restartButtonSprite_pressed.setSize( width * .267, width * .267 );
	restartButtonSprite_pressed.setImage( restartButtonImage_pressed );
	//restartButton.setTouchSize( 128, 128 );
	restartButton.setTouchSize( width * .267, width * .267 );
	restartButton.setUnpressedSprite( restartButtonSprite );
	restartButton.setPressedSprite( restartButtonSprite_pressed );	

	//nextButtonImage = Iw2DCreateImage("next.png");DisplayLoading();
	//nextButtonSprite.setUWidth( 128 );
	//nextButtonSprite.setUHeight( 128 );
	//nextButtonSprite.setSize( 128, 128 );
	nextButtonImage = Iw2DCreateImage("Next(HD).png");DisplayLoading();
	nextButtonSprite.setUWidth( 256 );
	nextButtonSprite.setUHeight( 256 );
	nextButtonSprite.setSize( width * .267, width * .267 );
	nextButtonSprite.setImage( nextButtonImage );
	//nextButtonImage_pressed = Iw2DCreateImage("next_pressed.png");
	//nextButtonSprite_pressed.setUWidth( 128 );
	//nextButtonSprite_pressed.setUHeight( 128 );
	//nextButtonSprite_pressed.setSize( 128, 128 );
	nextButtonImage_pressed = Iw2DCreateImage("Nextpressed(HD).png");
	nextButtonSprite_pressed.setUWidth( 256 );
	nextButtonSprite_pressed.setUHeight( 256 );
	nextButtonSprite_pressed.setSize( width * .267, width * .267 );
	nextButtonSprite_pressed.setImage( nextButtonImage_pressed );
	//nextButton.setTouchSize( 128, 128 );
	nextButton.setTouchSize( width * .267, width * .267 );
	nextButton.setUnpressedSprite( nextButtonSprite );
	nextButton.setPressedSprite( nextButtonSprite_pressed );

	//rotateButtonImage = Iw2DCreateImage("rotate.png");DisplayLoading();
	//rotateButtonSprite.setUWidth( 64 );
	//rotateButtonSprite.setUHeight( 64 );
	//rotateButtonSprite.setSize( 64, 64 );
	rotateButtonImage = Iw2DCreateImage("Rotate.png");DisplayLoading();
	rotateButtonSprite.setUWidth( 512 );
	rotateButtonSprite.setUHeight( 512 );
	//rotateButtonSprite.setSize( width * .133, width * .133 );
	rotateButtonSprite.setSize( height * .2, height * .2 );
	rotateButtonSprite.setImage( rotateButtonImage );
	//rotateButtonImage_pressed = Iw2DCreateImage("rotate_pressed.png");
	//rotateButtonSprite_pressed.setUWidth( 64 );
	//rotateButtonSprite_pressed.setUHeight( 64 );
	rotateButtonImage_pressed = Iw2DCreateImage("RotatePressed.png");
	rotateButtonSprite_pressed.setUWidth( 512 );
	rotateButtonSprite_pressed.setUHeight( 512 );
	//rotateButtonSprite_pressed.setSize( 64, 64 );
	//rotateButtonSprite_pressed.setSize( width * .133, width * .133 );
	rotateButtonSprite_pressed.setSize( height * .2, height * .2 );
	rotateButtonSprite_pressed.setImage( rotateButtonImage_pressed );
	//rotateButton.setTouchSize( 64, 64 );
	//rotateButton.setTouchSize( width * .133, width * .133 );
	rotateButton.setTouchSize( height * .2, height * .2 );
	rotateButton.setUnpressedSprite( rotateButtonSprite );
	rotateButton.setPressedSprite( rotateButtonSprite_pressed );	

	//rightButtonImage = Iw2DCreateImage("FuzzyControlButton.png");DisplayLoading();
	//rightButtonSprite.setUWidth( 50 );
	//rightButtonSprite.setUHeight( 50 );
	rightButtonImage = Iw2DCreateImage("fuzzyControlbutton(HD).png");DisplayLoading();
	rightButtonSprite.setUWidth( 128 );
	rightButtonSprite.setUHeight( 128 );
	//rightButtonSprite.setSize( 50, 50 );
	//rightButtonSprite.setSize( width * .104, width * .104 );
	rightButtonSprite.setSize( height * .156, height * .156 );
	rightButtonSprite.setImage( rightButtonImage );
	//rightButtonImage_pressed = Iw2DCreateImage("FuzzyControlButton2.png");
	//rightButtonSprite_pressed.setUWidth( 50 );
	//rightButtonSprite_pressed.setUHeight( 50 );
	rightButtonImage_pressed = Iw2DCreateImage("fuzzyControlbutton-green(HD).png");
	rightButtonSprite_pressed.setUWidth( 128 );
	rightButtonSprite_pressed.setUHeight( 128 );
	//rightButtonSprite_pressed.setSize( 50, 50 );
	//rightButtonSprite_pressed.setSize( width * .104, width * .104 );
	rightButtonSprite_pressed.setSize( height * .12, height * .12 );
	rightButtonSprite_pressed.setImage( rightButtonImage_pressed );
	//rightButton.setTouchSize( 50, 50 );
	//rightButton.setTouchSize( width * .104, width * .104 );
	rightButton.setTouchSize( height * .156, height * .156 );
	rightButton.setUnpressedSprite( rightButtonSprite );
	rightButton.setPressedSprite( rightButtonSprite_pressed );	

	//leftButtonImage = Iw2DCreateImage("FuzzyControlButton.png");DisplayLoading();
	//leftButtonSprite.setUWidth( 50 );
	//leftButtonSprite.setUHeight( 50 );
	leftButtonImage = Iw2DCreateImage("fuzzyControlbutton(HD).png");DisplayLoading();
	leftButtonSprite.setUWidth( 128 );
	leftButtonSprite.setUHeight( 128 );
	//leftButtonSprite.setSize( 50, 50 );
	//leftButtonSprite.setSize( width * .104, width * .104 );
	leftButtonSprite.setSize( height * .156, height * .156 );
	leftButtonSprite.setImage( leftButtonImage );
	//leftButtonImage_pressed = Iw2DCreateImage("FuzzyControlButton2.png");
	//leftButtonSprite_pressed.setUWidth( 50 );
	//leftButtonSprite_pressed.setUHeight( 50 );
	leftButtonImage_pressed = Iw2DCreateImage("fuzzyControlbutton-green(HD).png");
	leftButtonSprite_pressed.setUWidth( 128 );
	leftButtonSprite_pressed.setUHeight( 128 );
	//leftButtonSprite_pressed.setSize( 50, 50 );
	//leftButtonSprite_pressed.setSize( width * .104, width * .104 );
	leftButtonSprite_pressed.setSize( height * .12, height * .12 );
	leftButtonSprite_pressed.setImage( leftButtonImage_pressed );
	//leftButton.setTouchSize( 50, 50 );
	//leftButton.setTouchSize( width * .104, width * .104 );
	leftButton.setTouchSize( height * .156, height * .156 );
	leftButton.setUnpressedSprite( leftButtonSprite );
	leftButton.setPressedSprite( leftButtonSprite_pressed );	

	//upButtonImage = Iw2DCreateImage("FuzzyControlButton.png");DisplayLoading();
	//upButtonSprite.setUWidth( 50 );
	//upButtonSprite.setUHeight( 50 );
	upButtonImage = Iw2DCreateImage("fuzzyControlbutton(HD).png");DisplayLoading();
	upButtonSprite.setUWidth( 128 );
	upButtonSprite.setUHeight( 128 );
	//upButtonSprite.setSize( 50, 50 );
	//upButtonSprite.setSize( width * .104, width * .104 );
	upButtonSprite.setSize( height * .156, height * .156 );
	upButtonSprite.setImage( upButtonImage );
	//upButtonImage_pressed = Iw2DCreateImage("FuzzyControlButton2.png");
	//upButtonSprite_pressed.setUWidth( 50 );
	//upButtonSprite_pressed.setUHeight( 50 );
	upButtonImage_pressed = Iw2DCreateImage("fuzzyControlbutton-green(HD).png");
	upButtonSprite_pressed.setUWidth( 128 );
	upButtonSprite_pressed.setUHeight( 128 );
	//upButtonSprite_pressed.setSize( 50, 50 );
	upButtonSprite_pressed.setSize( height * .12, height * .12 );
	upButtonSprite_pressed.setImage( upButtonImage_pressed );
	//upButton.setTouchSize( 50, 50 );
	//upButton.setTouchSize( width * .104, width * .104 );
	upButton.setTouchSize( height * .156, height * .156 );
	upButton.setUnpressedSprite( upButtonSprite );
	upButton.setPressedSprite( upButtonSprite_pressed );	

	//downButtonImage = Iw2DCreateImage("FuzzyControlButton.png");DisplayLoading();
	//downButtonSprite.setUWidth( 50 );
	//downButtonSprite.setUHeight( 50 );
	downButtonImage = Iw2DCreateImage("fuzzyControlbutton(HD).png");DisplayLoading();
	downButtonSprite.setUWidth( 128 );
	downButtonSprite.setUHeight( 128 );
	//downButtonSprite.setSize( 50, 50 );
	//downButtonSprite.setSize( width * .104, width * .104 );
	downButtonSprite.setSize( height * .156, height * .156 );
	downButtonSprite.setImage( downButtonImage );
	//downButtonImage_pressed = Iw2DCreateImage("FuzzyControlButton2.png");
	//downButtonSprite_pressed.setUWidth( 50 );
	//downButtonSprite_pressed.setUHeight( 50 );
	downButtonImage_pressed = Iw2DCreateImage("fuzzyControlbutton-green(HD).png");
	downButtonSprite_pressed.setUWidth( 128 );
	downButtonSprite_pressed.setUHeight( 128 );
	//downButtonSprite_pressed.setSize( 50, 50 );
	//downButtonSprite_pressed.setSize( width * .104, width * .104 );
	downButtonSprite_pressed.setSize( height * .12, height * .12 );
	downButtonSprite_pressed.setImage( downButtonImage_pressed );
	//downButton.setTouchSize( 50, 50 );
	//downButton.setTouchSize( width * .104, width * .104 );
	downButton.setTouchSize( height * .156, height * .156 );
	downButton.setUnpressedSprite( downButtonSprite );
	downButton.setPressedSprite( downButtonSprite_pressed );	

	DisplayLoading();
	
	

	for( int i = 0; i < 6; i++ )
	{
		warpingMaterial[i] = new CIwMaterial;
		explodingMaterial[i] = new CIwMaterial;		
	}

	

	// CUBE2 initialization
	// create base vertices
	for( int i = 0; i < numCubes * 24; i++ )
	{
		// starts copying vertices at every 24th position
		cubeVertices2[ i ] = cubeVertices[ i % 24 ];
		cubeTranslated2[ i ] = cubeVertices2[i % 24];
		cubeNormals2[ i ] = cubeNormals[ i % 24 ];
	}
	// Create the cubes and translate to offset to form rubix
	for( int k = 0; k < numCubesHeight; k++ ) // traversing through y axis, height
	{
		for( int i = 0; i < numCubesLength; i++ ) // traversing z axis, depth
		{
			for( int j = 0; j < numCubesWidth; j++ ) // traversing x axis, width
			{
				// Spawn the cubes
				// j + i*numCubesWidth + k*width*length traverses correctly through num cubes given that is not a 3-dim array
									// Cube( CIwSVec3 p ,	CIwSVec3 d, int16 s, int16 dl, int16 sp, int16 a, int16 m, int16 c, int16 ncr, int16 as, bool il );
				cubeArray[ j + i*numCubesWidth + k*numCubesWidth*numCubesLength ] = Cube( s );

				// translate the cubes
				// j + i*numCubesWidth + k*width*length traverses correctly through num cubes given that is not a 3-dim array
																									//adding the s/2 offsets the corner vertex spawn points to center of screen
																									// due to the nature of where the *first* cube is spawned
																									// so that when doing translation of entire cube, can be done evenly
																														/* z is negative b/c comes into the screen*/ 
				cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].position = CIwSVec3( (s*j + s/2) - s*numCubesWidth/2, 
																									  (s*k + s/2) - s*numCubesHeight/2, 
																									-(s*i + s/2) + s*numCubesLength/2);
				// store the vertices to be rendered
				// Basically Links the Cubes' positions to vertices to be rendered
				for( int v = 0; v < 24; v++ )
				{
					// j + i*numCubesWidth + k*width*length traverses correctly through num cubes given that is not a 3-dim array
					// Need to multiply by 24 to account for stacks of 24 vertices belonging to the same cube
					// The +v is for each individual vertex in array after correct cube*vertex location
					cubeTranslated2[(j + i*numCubesWidth + k*numCubesWidth*numCubesLength)*24 + v].x = cubeVertices2[(j + i*numCubesWidth + k*numCubesWidth*numCubesLength)*24 + v].x + cubeArray[(j + i*numCubesWidth + k*numCubesWidth*numCubesLength)].position.x;
					cubeTranslated2[(j + i*numCubesWidth + k*numCubesWidth*numCubesLength)*24 + v].y = cubeVertices2[(j + i*numCubesWidth + k*numCubesWidth*numCubesLength)*24 + v].y + cubeArray[(j + i*numCubesWidth + k*numCubesWidth*numCubesLength)].position.y;
					cubeTranslated2[(j + i*numCubesWidth + k*numCubesWidth*numCubesLength)*24 + v].z = cubeVertices2[(j + i*numCubesWidth + k*numCubesWidth*numCubesLength)*24 + v].z + cubeArray[(j + i*numCubesWidth + k*numCubesWidth*numCubesLength) ].position.z; 
				}
			}
		}
	}

	numStaticSides1Index = 0;
	numStaticSides2Index = 0;
	numStaticSides3Index = 0;
	numStaticSides4Index = 0;
	numStaticSides5Index = 0;
	numStaticSides6Index = 0;

	// create Static Sides
	for( int k = 0; k < numCubesHeight; k++ ) // traversing through y axis, height
	{
		for( int i = 0; i < numCubesLength; i++ ) // traversing z axis, depth
		{
			for( int j = 0; j < numCubesWidth; j++ ) // traversing x axis, width
			{
				// sets Side1 material and coordinates
				if( i == numCubesLength-1 ) // if faceSide is 1 on static cube plane
				{
					// set the side's material and coordinates
					// the cubeArray[].side1 are not really used except for within here
					cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side1 = new Shadow(1);
					cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side1->material = Cube::SOLID_BLUE;
					cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side1->position = cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].position;

					// create base vertices for static sides
					for( int h = 0; h < 4; h++ )
					{
						staticSide1Vertices[numStaticSides1Index*4 + h] = sideVerticesFaceSide1[h];
						staticSide1VerticesTranslated[numStaticSides1Index*4 + h] = staticSide1Vertices[numStaticSides1Index*4 + h] + cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side1->position;
						staticSide1Normals[numStaticSides1Index*4+h] = shadowNormalsFaceSide1[h];
					}

					numStaticSides1Index++;
				}

				// sets Side2 material and coordinates
				if( j == numCubesWidth-1 ) // if faceSide is 2 on static cube plane
				{
					// set the side's material and coordinates
					cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side2 = new Shadow(2);
					cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side2->material = Cube::SOLID_BLUE;
					cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side2->position = cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].position;

					// create base vertices for static sides
					for( int h = 0; h < 4; h++ )
					{
						staticSide2Vertices[numStaticSides2Index*4 + h] = sideVerticesFaceSide2[h];
						staticSide2VerticesTranslated[numStaticSides2Index*4 + h] = staticSide2Vertices[numStaticSides2Index*4 + h] + cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side2->position;
						staticSide2Normals[numStaticSides2Index*4+h] = shadowNormalsFaceSide2[h];
					}

					numStaticSides2Index++;
				}

				// sets Side3 material and coordinates
				if( i == 0 ) // if faceSide is 3 on static cube plane
				{
					// set the side's material and coordinates
					cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side3 = new Shadow(3);
					cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side3->material = Cube::SOLID_BLUE;
					cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side3->position = cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].position;

					// create base vertices for static sides
					for( int h = 0; h < 4; h++ )
					{
						staticSide3Vertices[numStaticSides3Index*4 + h] = sideVerticesFaceSide3[h];
						staticSide3VerticesTranslated[numStaticSides3Index*4 + h] = staticSide3Vertices[numStaticSides3Index*4 + h] + cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side3->position;
						staticSide3Normals[numStaticSides3Index*4+h] = shadowNormalsFaceSide3[h];
					}

					numStaticSides3Index++;
				}

				// sets Side4 material and coordinates
				if( j == 0 ) // if faceSide is 4 on static cube plane
				{
					// set the side's material and coordinates
					cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side4 = new Shadow(4);
					cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side4->material = Cube::SOLID_BLUE;
					cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side4->position = cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].position;

					// create base vertices for static sides
					for( int h = 0; h < 4; h++ )
					{
						staticSide4Vertices[numStaticSides4Index*4 + h] = sideVerticesFaceSide4[h];
						staticSide4VerticesTranslated[numStaticSides4Index*4 + h] = staticSide4Vertices[numStaticSides4Index*4 + h] + cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side4->position;
						staticSide4Normals[numStaticSides4Index*4+h] = shadowNormalsFaceSide4[h];
					}

					numStaticSides4Index++;
				}

				// sets Side5 material and coordinates
				if( k == 0 ) // if faceSide is 5 on static cube plane
				{
					// set the side's material and coordinates
					cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side5 = new Shadow(5);
					cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side5->material = Cube::SOLID_BLUE;
					cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side5->position = cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].position;

					// create base vertices for static sides
					for( int h = 0; h < 4; h++ )
					{
						staticSide5Vertices[numStaticSides5Index*4 + h] = sideVerticesFaceSide5[h];
						staticSide5VerticesTranslated[numStaticSides5Index*4 + h] = staticSide5Vertices[numStaticSides5Index*4 + h] + cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side5->position;
						staticSide5Normals[numStaticSides5Index*4+h] = shadowNormalsFaceSide5[h];
					}

					numStaticSides5Index++;
				}

				// sets Side6 material and coordinates
				if( k == numCubesHeight-1 ) // if faceSide is 6 on static cube plane
				{
					// set the side's material and coordinates
					cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side6 = new Shadow(6);
					cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side6->material = Cube::SOLID_BLUE;
					cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side6->position = cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].position;

					// create base vertices for static sides
					for( int h = 0; h < 4; h++ )
					{
						staticSide6Vertices[numStaticSides6Index*4 + h] = sideVerticesFaceSide6[h];
						staticSide6VerticesTranslated[numStaticSides6Index*4 + h] = staticSide6Vertices[numStaticSides6Index*4 + h] + cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side6->position;
						staticSide6Normals[numStaticSides6Index*4+h] = shadowNormalsFaceSide6[h];
					}

					numStaticSides6Index++;
				}
			} // end of inner most loop of creating the sides
		}
	}
	
	// create base vertices for Moving cubes
	for( int i = 0; i < numMovingCubes * 24; i++ )
	{
		// starts copying vertices at every 24th position
		cubeMovingVertices2[ i ] = cubeVertices[ i % 24 ];
		cubeMovingTranslated2[ i ] = cubeVertices2[i % 24];
		cubeMovingNormals2[ i ] = cubeNormals[ i % 24 ];
	}

	// Load FONT, FUZZYMATERIAL, FUZZYEXPLODEMATERIAL, Cube materials
	
	
	int32 heapUsed2 = s3eMemoryGetInt(S3E_MEMORY_USED); // Free memory minus heap size
	printf("Finished Loading Level data. Memory loaded was %d \n", heapUsed2 - heapUsed );

} // end of loadleveldata()

// not yet implemented. not sure if it's necessary
void TerminateLevelData()
{
	int32 heapUsed = s3eMemoryGetInt(S3E_MEMORY_USED); // Free memory minus heap size

	// stop iAd
	if( hasIAd == true )
	{
		if( s3eIOSIAdGetInt( S3E_IOSIAD_RUNNING ) )
		{
			s3eIOSIAdStop();
			showingIAd = false;
		}
	}

	// Remove current Static and moving cubes
	Reset();
		
	// terminate quit confirmation screen
	quitConfirmationScreen.Terminate();

	// terminate tutorial messages images
	if( episode == 1 )
	{
		for( int i = 0; i < NUM_OF_TUTORIAL_MESSAGES; i++ )
		{
			delete tutorialImages[i];
		}
	}


	// bomb defused
	delete bombDefusedImage;
	delete bombAlertImage;
	delete bombAlertImage_wtf;
	delete progressBarImage;
	delete progressBarFrameImage;

	// SCORE images
	delete pointImage50;
	delete pointImage500;
	delete pointImage5000;
	delete pointImage100;
	delete pointImage1000;
	delete pointImage10000;
	
	delete pixieImage;

	delete trophySpriteImage;

	delete congratsImageLevelUp;
	delete congratsImageNice;
	delete congratsImageComplete;
	delete congratsImageSuper;
	delete congratsImageGreat;
	delete minusOneFuzzyImage;
	delete plusOneFuzzyImage;

	delete gameOverImage;

	// load active square indicators
	blueSquare.Terminate();
	redSquare.Terminate();
	purpleSquare.Terminate();
	orangeSquare.Terminate();
	greenSquare.Terminate();
	yellowSquare.Terminate();

	/*
	// get font (first one is the .gxfont, second one is resource name
	CIwGxFont* font = (CIwGxFont*)IwGetResManager()->GetResNamed("font", "CIwGxFont");
	IwGxFontSetFont( font );
	*/

	// FUZZY material and textures
	for( int i = 0; i < numFuzzyMaterials; i++ )
	{
		delete fuzzyMaterial[i];
		delete fuzzyTexture[i];
	}

	// FUZZY EXPLODE materials and textures
	for( int i = 0; i < numFuzzyExplodeMaterials; i++ )
	{
		delete fuzzyExplodeMaterial[i];
		delete fuzzyExplodeTexture[i];
	}

	// load Bombs
	for( int i = 0; i < NUM_OF_BOMB_MATERIALS; i++ )
	{
		delete bombMaterial[i];
		delete bombTexture[i];
	}


	delete bombDefuseMaterial;
	delete bombDefuseTexture;

	delete bombExplodeMaterial;
	delete bombExplodeTexture;

	delete warpingTextureGolden;
	delete explodingTextureRed;

	
	// Material Textures
	delete cubeTextureBlue;
	delete cubeTextureRed;
	delete cubeTextureGreen;
	delete cubeTextureYellow;
	delete cubeTextureOrange;
	delete cubeTexturePurple;

	delete shadowTextureBlue;
	delete shadowTextureRed;
	delete shadowTextureGreen;
	delete shadowTextureYellow;
	delete shadowTextureOrange;
	delete shadowTexturePurple;

	
	delete livesImage;
	delete spacebusImage;
	delete progressBarGlowImage;

	

	/*
	delete difficultyStartImage;
	delete difficultyStartImage_pressed;
	delete difficultyEasyImage;
	delete difficultyEasyImage_pressed;
	delete difficultyMediumImage;
	delete difficultyMediumImage_pressed;
	delete difficultyHardImage;
	delete difficultyHardImage_pressed;
	delete testButtonImage;
	delete testButtonImage_pressed;
	*/
	

	delete scoreScreenImage;
	delete pausedBackgroundImage;
	delete pauseButtonImage;
	delete pauseButtonImage_pressed;
	delete resumeButtonImage;
	delete resumeButtonImage_pressed;
	delete quitButtonImage;
	delete quitButtonImage_pressed;
	delete restartButtonImage;
	delete restartButtonImage_pressed;
	delete nextButtonImage;
	delete nextButtonImage_pressed;
	delete rotateButtonImage;
	delete rotateButtonImage_pressed;
	delete rightButtonImage;
	delete rightButtonImage_pressed;
	delete leftButtonImage;
	delete leftButtonImage_pressed;
	delete upButtonImage;
	delete upButtonImage_pressed;
	delete downButtonImage;
	delete downButtonImage_pressed;

	/*
	delete sideBlueMaterial;
	delete sideRedMaterial;
	delete sideGreenMaterial;
	delete sideYellowMaterial;
	delete sidePurpleMaterial;
	delete sideOrangeMaterial;

	delete side1TempMaterial;
	delete side2TempMaterial;
	delete side3TempMaterial;
	delete side4TempMaterial;
	delete side5TempMaterial;
	delete side6TempMaterial;

	delete side1Material;
	delete side2Material;
	delete side3Material;
	delete side4Material;
	delete side5Material;
	delete side6Material;

	delete nullMaterial;

	delete blueSolidMaterial;
	delete greenSolidMaterial;
	delete redSolidMaterial;
	delete orangeSolidMaterial;
	delete yellowSolidMaterial;
	delete purpleSolidMaterial;

	delete blueTransMaterial;
	delete greenTransMaterial;
	delete redTransMaterial;
	delete orangeTransMaterial;
	delete yellowTransMaterial;
	delete purpleTransMaterial;
	
	delete blueSolidShadowMaterial;
	delete redSolidShadowMaterial;
	delete greenSolidShadowMaterial;
	delete yellowSolidShadowMaterial;
	delete purpleSolidShadowMaterial;
	delete orangeSolidShadowMaterial;

	delete blueTransShadowMaterial;
	delete redTransShadowMaterial;
	delete greenTransShadowMaterial;
	delete yellowTransShadowMaterial;
	delete purpleTransShadowMaterial;
	delete orangeTransShadowMaterial;
	*/

	
	for( int i = 0; i < 6; i++ )
	{
		delete warpingMaterial[i];
		delete explodingMaterial[i];		
	}


	// create Static Sides
	for( int k = 0; k < numCubesHeight; k++ ) // traversing through y axis, height
	{
		for( int i = 0; i < numCubesLength; i++ ) // traversing z axis, depth
		{
			for( int j = 0; j < numCubesWidth; j++ ) // traversing x axis, width
			{
				// sets Side1 material and coordinates
				if( i == numCubesLength-1 ) // if faceSide is 1 on static cube plane
				{
					// set the side's material and coordinates
					// the cubeArray[].side1 are not really used except for within here
					delete cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side1;
				}

				// sets Side2 material and coordinates
				if( j == numCubesWidth-1 ) // if faceSide is 2 on static cube plane
				{
					// set the side's material and coordinates
					delete cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side2;
				}

				// sets Side3 material and coordinates
				if( i == 0 ) // if faceSide is 3 on static cube plane
				{
					// set the side's material and coordinates
					delete cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side3;
				}

				// sets Side4 material and coordinates
				if( j == 0 ) // if faceSide is 4 on static cube plane
				{
					// set the side's material and coordinates
					delete cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side4;
				}

				// sets Side5 material and coordinates
				if( k == 0 ) // if faceSide is 5 on static cube plane
				{
					// set the side's material and coordinates
					delete cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side5;
				}

				// sets Side6 material and coordinates
				if( k == numCubesHeight-1 ) // if faceSide is 6 on static cube plane
				{
					// set the side's material and coordinates
					delete cubeArray[j + i*numCubesWidth + k*numCubesWidth*numCubesLength].side6;
				}
			} // end of inner most loop of creating the sides
		}
	}

	int32 heapUsed2 = s3eMemoryGetInt(S3E_MEMORY_USED); // Free memory minus heap size
	printf("Finished Terminating Level data. Memory Freed was %d \n", heapUsed2 - heapUsed );
	
} // end of TerminateLevelData

void LoadTutorialData()
{
	atTutorial = true;

	
	// ROTATE BUTTON HIGHLIGHT
	tutorialRotateButtonHighlightImage = Iw2DCreateImage("buttonHighlight.png");DisplayLoading();
	tutorialRotateButtonHighlightSprite.setImage( tutorialRotateButtonHighlightImage );
	tutorialRotateButtonHighlightSprite.setDelayTime( 25 ); // wait half a second
	tutorialRotateButtonHighlightSprite.setSize( 100, 100 );
	tutorialRotateButtonHighlightSprite.setUHeight( 100 );
	tutorialRotateButtonHighlightSprite.setUWidth( 100 );


	// RIGHT ARROW BUTTON HIGHLIGHT
	tutorialRightButtonHighlightImage = Iw2DCreateImage("tutorialRightButtonHighlight.png");DisplayLoading();
	tutorialRightButtonHighlightSprite.setImage( tutorialRightButtonHighlightImage );
	tutorialRightButtonHighlightSprite.setDelayTime( 25 ); // wait half a second
	tutorialRightButtonHighlightSprite.setSize( 80, 80 );
	tutorialRightButtonHighlightSprite.setUHeight( 100 );
	tutorialRightButtonHighlightSprite.setUWidth( 100 );

	// TUTORIAL SPRITES
	tutorialTouchDragImage = Iw2DCreateImage("tutorialTouchDrag.png");DisplayLoading();
	tutorialTouchDragSprite.setImage( tutorialTouchDragImage );
	tutorialTouchDragSprite.setDelayTime( 25 ); // wait half a second
	tutorialTouchDragSprite.setSize( 192, 128 );
	tutorialTouchDragSprite.setUWidth( 192 );
	tutorialTouchDragSprite.setUHeight( 128 );

	tutorialTapDropImage = Iw2DCreateImage("tutorialTapDrop.png");DisplayLoading();
	tutorialTapDropSprite.setImage( tutorialTapDropImage );
	tutorialTapDropSprite.setDelayTime( 15 ); // wait half a second
	tutorialTapDropSprite.setSize( 192, 128 );
	tutorialTapDropSprite.setUWidth( 192 );
	tutorialTapDropSprite.setUHeight( 128 );

	tutorialRotateCubeImage = Iw2DCreateImage("tutorialRotateCube.png");DisplayLoading();
	tutorialRotateCubeSprite.setImage( tutorialRotateCubeImage );
	tutorialRotateCubeSprite.setDelayTime( 25 ); 
	tutorialRotateCubeSprite.setSize( 192, 128 );
	tutorialRotateCubeSprite.setUWidth( 192 );
	tutorialRotateCubeSprite.setUHeight( 128 );

	tutorialCompleteSideImage = Iw2DCreateImage("tutorialCompleteSide.png");DisplayLoading();
	tutorialCompleteSideSprite.setImage( tutorialCompleteSideImage );
	tutorialCompleteSideSprite.setDelayTime( 30 ); 
	tutorialCompleteSideSprite.setSize( 192, 128 );
	tutorialCompleteSideSprite.setUWidth( 192 );
	tutorialCompleteSideSprite.setUHeight( 128 );
	tutorialCompleteSideSprite.setTotalFrames( 7 );

	tutorialRotateCameraImage = Iw2DCreateImage("tutorialRotateCamera.png");DisplayLoading();
	tutorialRotateCameraSprite.setImage( tutorialRotateCameraImage );
	tutorialRotateCameraSprite.setDelayTime( 30 ); 
	tutorialRotateCameraSprite.setSize( 192, 128 );
	tutorialRotateCameraSprite.setUWidth( 192 );
	tutorialRotateCameraSprite.setUHeight( 128 );

	tutorialFlipCubeImage = Iw2DCreateImage("tutorialFlipCube.png");DisplayLoading();
	tutorialFlipCubeSprite.setImage( tutorialFlipCubeImage );
	tutorialFlipCubeSprite.setDelayTime( 30 ); 
	tutorialFlipCubeSprite.setSize( 192, 128 );
	tutorialFlipCubeSprite.setUWidth( 192 );
	tutorialFlipCubeSprite.setUHeight( 128 );

	// Load the Next Page arrow buttons
	tutorialLeftButtonImage = Iw2DCreateImage("tutorialLeftButton.png");DisplayLoading();
	tutorialLeftButtonSprite.setUWidth( 30 );
	tutorialLeftButtonSprite.setUHeight( 30 );
	tutorialLeftButtonSprite.setSize( 30, 30 );
	tutorialLeftButtonSprite.setImage( tutorialLeftButtonImage );
	tutorialLeftButtonImage_pressed = Iw2DCreateImage("tutorialLeftButton_pressed.png");DisplayLoading();
	tutorialLeftButtonSprite_pressed.setUWidth( 30 );
	tutorialLeftButtonSprite_pressed.setUHeight( 30 );
	tutorialLeftButtonSprite_pressed.setSize( 30, 30 );
	tutorialLeftButtonSprite_pressed.setImage( tutorialLeftButtonImage_pressed );
	tutorialLeftButton.setTouchSize( 50, 50 );
	tutorialLeftButton.setUnpressedSprite( tutorialLeftButtonSprite );
	tutorialLeftButton.setPressedSprite( tutorialLeftButtonSprite_pressed );

	tutorialRightButtonImage = Iw2DCreateImage("tutorialRightButton.png");DisplayLoading();
	tutorialRightButtonSprite.setUWidth( 30 );
	tutorialRightButtonSprite.setUHeight( 30 );
	tutorialRightButtonSprite.setSize( 30, 30 );
	tutorialRightButtonSprite.setImage( tutorialRightButtonImage );
	tutorialRightButtonImage_pressed = Iw2DCreateImage("tutorialRightButton_pressed.png");DisplayLoading();
	tutorialRightButtonSprite_pressed.setUWidth( 30 );
	tutorialRightButtonSprite_pressed.setUHeight( 30 );
	tutorialRightButtonSprite_pressed.setSize( 30, 30 );
	tutorialRightButtonSprite_pressed.setImage( tutorialRightButtonImage_pressed );
	tutorialRightButton.setTouchSize( 50, 50 );
	tutorialRightButton.setUnpressedSprite( tutorialRightButtonSprite );
	tutorialRightButton.setPressedSprite( tutorialRightButtonSprite_pressed );	

	// REMOVE ALL CUBES
	Reset();

	if( tutorialNumber < 6 ) // FOR TUTORIAL LEVELS 1-5, Remove Cubes, Spawn Cubes
	{
		SpawnMovingSets(); // spawning should not spawn more cubes if already in play. Internal condition
	}

	if( musicOn )
	{
		// play music
		if( s3eAudioPlay("fuzzytheme.mp3", 0) == S3E_RESULT_ERROR )
		{
			printf("Error with playing background music.\n");
		}
	}

} // end of load tutorial data

void TerminateTutorialData()
{
	atTutorial = false;

	delete congratsImageNice;
	delete congratsImageComplete;

	delete tutorialTouchDragImage;
	delete tutorialRightButtonHighlightImage;
	delete tutorialRotateButtonHighlightImage;
	delete tutorialTapDropImage;
	delete tutorialRotateCubeImage;
	delete tutorialCompleteSideImage;
	delete tutorialRotateCameraImage;
	delete tutorialFlipCubeImage;
	delete tutorialLeftButtonImage;
	delete tutorialLeftButtonImage_pressed;
	delete tutorialRightButtonImage_pressed;
	delete tutorialRightButtonImage;

	// REMOVE ALL CUBES
	Reset();
}

int32 triggerTitle( void* systemData, void* userData ) // trigger title callback
{
	//GameState = AT_TITLE;

	TargetState = AT_TITLE;
	transition = true;
	transitionIsSet = false;

	return 0;
}

int32 triggerLoading( void* systemData, void* userData ) // trigger title callback
{
	TargetState = AT_LOADING_MENU;
	transition = true;
	transitionIsSet = false;
	/*
	//GameState = AT_DISPLAY_LOADING_MENU;
	if( playingStory == false )
	{
		TargetState = AT_LOADING_MENU;
		transition = true;
		transitionIsSet = false;
	}
	else if( playingStory == true )
	{
		TargetState = AT_LOADING_LEVEL;
		storyMode = true;

		transition = true;
		transitionIsSet = false;
	}
	*/

	return 0;
}

int32 loadingMenuCallback( void* systemData, void *userData )
{
	// load menu data after a couple seconds
	if( transition == false )
	{
		// display loading screen
		LoadMenuData();
		InitializeMenu();		

		menuCounter = 0;

		transition = true;
		transitionIsSet = false;
		TargetState = AT_MENU;
	}

	return 0;
}

int32 triggerShowTutorialTouchDrag( void *systemData, void *userData )
{
	tutorialSprites[0].setStartingAlpha( tutorialZeroAlpha );
	tutorialSprites[0].setEndingAlpha( tutorialMaxAlpha );
	tutorialSprites[0].setAlphaInterpolationTime( tutorialInterpolationTime );

	return 0;
}

int32 triggerHideTutorialTouchDrag( void *systemData, void *userData )
{
	tutorialSprites[0].setStartingAlpha( tutorialMaxAlpha );
	tutorialSprites[0].setEndingAlpha( tutorialZeroAlpha );
	tutorialSprites[0].setAlphaInterpolationTime( tutorialInterpolationTime );

	return 0;
}

int32 triggerShowTutorialTapDrop( void *systemData, void *userData )
{
	tutorialSprites[1].setStartingAlpha( tutorialZeroAlpha );
	tutorialSprites[1].setEndingAlpha( tutorialMaxAlpha );
	tutorialSprites[1].setAlphaInterpolationTime( tutorialInterpolationTime );

	return 0;
}

int32 triggerHideTutorialTapDrop( void *systemData, void *userData )
{
	tutorialSprites[1].setStartingAlpha( tutorialMaxAlpha );
	tutorialSprites[1].setEndingAlpha( tutorialZeroAlpha );
	tutorialSprites[1].setAlphaInterpolationTime( tutorialInterpolationTime );

	return 0;
}

int32 triggerShowTutorialRotate( void *systemData, void *userData )
{
	tutorialSprites[3].setStartingAlpha( tutorialZeroAlpha );
	tutorialSprites[3].setEndingAlpha( tutorialMaxAlpha );
	tutorialSprites[3].setAlphaInterpolationTime( tutorialInterpolationTime );

	return 0;
}

int32 triggerHideTutorialRotate( void *systemData, void *userData )
{
	tutorialSprites[3].setStartingAlpha( tutorialMaxAlpha );
	tutorialSprites[3].setEndingAlpha( tutorialZeroAlpha );
	tutorialSprites[3].setAlphaInterpolationTime( tutorialInterpolationTime );

	return 0;
}

int32 triggerShowTutorialShift( void *systemData, void *userData )
{
	tutorialSprites[4].setStartingAlpha( tutorialZeroAlpha );
	tutorialSprites[4].setEndingAlpha( 145 );
	tutorialSprites[4].setAlphaInterpolationTime( tutorialInterpolationTime );

	return 0;
}

int32 triggerHideTutorialShift( void *systemData, void *userData )
{
	tutorialSprites[4].setStartingAlpha( tutorialMaxAlpha );
	tutorialSprites[4].setEndingAlpha( tutorialZeroAlpha );
	tutorialSprites[4].setAlphaInterpolationTime( 500 );

	return 0;
}

int32 triggerTutorialShiftEnable( void *systemData, void *userData )
{
	tutorialShiftEnable = true;

	return 0;
}

int32 triggerShowTutorialDragSpace( void *systemData, void *userData )
{
	tutorialSprites[5].setStartingAlpha( tutorialZeroAlpha );
	tutorialSprites[5].setEndingAlpha( tutorialMaxAlpha );
	tutorialSprites[5].setAlphaInterpolationTime( 1000 );

	return 0;
}

int32 triggerHideTutorialDragSpace( void *systemData, void *userData )
{
	tutorialSprites[5].setStartingAlpha( tutorialMaxAlpha );
	tutorialSprites[5].setEndingAlpha( tutorialZeroAlpha );
	tutorialSprites[5].setAlphaInterpolationTime( 500 );

	return 0;
}

int32 triggerShowTutorialCompleteSide( void *systemData, void *userData )
{
	tutorialSprites[2].setStartingAlpha( tutorialZeroAlpha );
	tutorialSprites[2].setEndingAlpha( tutorialMaxAlpha );
	tutorialSprites[2].setAlphaInterpolationTime( tutorialInterpolationTime );

	return 0;
}

int32 triggerHideTutorialCompleteSide( void *systemData, void *userData )
{
	tutorialSprites[2].setStartingAlpha( tutorialMaxAlpha );
	tutorialSprites[2].setEndingAlpha( tutorialZeroAlpha );
	tutorialSprites[2].setAlphaInterpolationTime( tutorialInterpolationTime );

	return 0;
}

int32 triggerShowTutorialPerfectClear( void *systemData, void *userData )
{
	tutorialSprites[6].setStartingAlpha( tutorialZeroAlpha );
	tutorialSprites[6].setEndingAlpha( tutorialMaxAlpha );
	tutorialSprites[6].setAlphaInterpolationTime( tutorialInterpolationTime );

	return 0;
}
 

int32 triggerHideTutorialPerfectClear( void *systemData, void *userData )
{
	tutorialSprites[6].setStartingAlpha( tutorialMaxAlpha );
	tutorialSprites[6].setEndingAlpha( tutorialZeroAlpha );
	tutorialSprites[6].setAlphaInterpolationTime( tutorialInterpolationTime );

	return 0;
}

int32 triggerTutorialPerfectClearEnable( void *systemData, void *userData )
{
	enableTutorialPerfectClear = true;

	return 0;
}

int32 triggerShowTutorialDefuseBomb1( void *systemData, void *userData )
{
	tutorialSprites[7].setStartingAlpha( tutorialZeroAlpha );
	tutorialSprites[7].setEndingAlpha( tutorialMaxAlpha );
	tutorialSprites[7].setAlphaInterpolationTime( 500 );

	return 0;
}

int32 triggerHideTutorialDefuseBomb1( void *systemData, void *userData )
{
	tutorialSprites[7].setStartingAlpha( tutorialMaxAlpha );
	tutorialSprites[7].setEndingAlpha( tutorialZeroAlpha );
	tutorialSprites[7].setAlphaInterpolationTime( tutorialInterpolationTime );

	return 0;
}

int32 triggerShowTutorialDefuseBomb2( void *systemData, void *userData )
{
	tutorialSprites[8].setStartingAlpha( tutorialZeroAlpha );
	tutorialSprites[8].setEndingAlpha( tutorialMaxAlpha );
	tutorialSprites[8].setAlphaInterpolationTime( 500 );

	return 0;
}

int32 triggerHideTutorialDefuseBomb2( void *systemData, void *userData )
{
	tutorialSprites[8].setStartingAlpha( tutorialMaxAlpha );
	tutorialSprites[8].setEndingAlpha( tutorialZeroAlpha );
	tutorialSprites[8].setAlphaInterpolationTime( tutorialInterpolationTime );

	return 0;
}

int32 triggerShowTutorialDoNotDie( void *systemData, void *userData )
{
	tutorialSprites[9].setStartingAlpha( tutorialZeroAlpha );
	tutorialSprites[9].setEndingAlpha( tutorialMaxAlpha );
	tutorialSprites[9].setAlphaInterpolationTime( 500 );

	return 0;
}

int32 triggerHideTutorialDoNotDie( void *systemData, void *userData )
{
	tutorialSprites[9].setStartingAlpha( tutorialMaxAlpha );
	tutorialSprites[9].setEndingAlpha( tutorialZeroAlpha );
	tutorialSprites[9].setAlphaInterpolationTime( 500 );

	return 0;
}

int32 triggerShowTutorialMatchColors( void *systemData, void *userData )
{
	tutorialSprites[10].setStartingAlpha( tutorialZeroAlpha );
	tutorialSprites[10].setEndingAlpha( tutorialMaxAlpha );
	tutorialSprites[10].setAlphaInterpolationTime( 500 );

	return 0;
}

int32 triggerHideTutorialMatchColors( void *systemData, void *userData )
{
	tutorialSprites[10].setStartingAlpha( tutorialMaxAlpha );
	tutorialSprites[10].setEndingAlpha( tutorialZeroAlpha );
	tutorialSprites[10].setAlphaInterpolationTime( tutorialInterpolationTime );

	// allows cubes to start spawning in episode 1 of tutorial when message starts to fade out
	enableFirstSpawning = true;

	return 0;
}

int32 triggerShowTutorialDoNotStack( void *systemData, void *userData )
{
	tutorialSprites[11].setStartingAlpha( tutorialZeroAlpha );
	tutorialSprites[11].setEndingAlpha( tutorialMaxAlpha );
	tutorialSprites[11].setAlphaInterpolationTime( 300 );

	return 0;
}

int32 triggerHideTutorialDoNotStack( void *systemData, void *userData )
{
	tutorialSprites[11].setStartingAlpha( tutorialMaxAlpha );
	tutorialSprites[11].setEndingAlpha( tutorialZeroAlpha );
	tutorialSprites[11].setAlphaInterpolationTime( 300 );

	return 0;
}

// convert int to cstring
char* intToChar( int n )
{
	std::ostringstream ostream;
	ostream << n;
	char c[20];
	strcpy( c, (ostream.str()).c_str() );

	return c;
}

char* levelToCstring( int ep, int lvl )
{
	std::ostringstream ostream;
	ostream << ep << "-" << lvl;
	char c[10];
	strcpy( c, (ostream.str()).c_str() );

	return c;
}

void LoadBigImages()
{
	Sprite bigSprite1;
	//CIw2DImage* bigImage1[15];

	CIwTexture* bigImage1[5];

	for( int i = 0; i < 5; i++ )
	{
		//bigImage1[i] = Iw2DCreateImage("fuzzy_Bubbly.png");		
		bigImage1[i] = new CIwTexture();
		//bigImage1[i]->LoadFromFile( "fuzzy_Bubbly.png" );
		//bigImage1[i]->Upload();
	}

	for( int i = 0; i < 5; i++ )
	{
		delete bigImage1[i];
	}
}

void LoadSmallImages()
{
	CIw2DImage* smallImage1[20];

	for( int i = 0; i < 20; i++ )
	{
		smallImage1[i] = Iw2DCreateImage("fuzzy_Bubbly_small.png");
	}

	for( int i = 0; i < 20; i++ )
	{
		delete smallImage1[i];
	}
}

void CheckAndWarpCubes()
{
	// CHECK CUBES FOR WARPING
	// set the perfect warped to false if it is supposed to be checked. turns on to true during a perfect clear
	if( checkPerfectWarped == true )
	{
		perfectWarped = false;
	}

	// adjust already-warping planes first before creating new ones
	for( int i = 0; i < 6; i++ )
	{
		if( plane[i].beganWarping == true ) // if warping limit of plane is reached, count reaches 9
		{
			if( plane[i].active == true ) // warp a single layer
			{
				// if the limit is reached, remove the cubes first
					// since it's 40 updates per second, 80 updates = 2 seconds
				if( plane[i].warpingDelayTime == 1 ) // no delay right now, b/c takes a long time anyway
				{
					// reset plane variables
					plane[i].beganWarping = false;
					plane[i].warpingDelayTime = 0;
					plane[i].count = 0;		
					bool playLandSoundHere = false;

					// remove the finished-warping cubes
					for( int j = numOriginalCubes; j < numStaticCubes; j++ ) // check all the cubes
					{
						// remove cube if it was same side as plane and is touching it
						if( cubeArray[j].touchingSide == true && cubeArray[j].direction == plane[i].direction )
						{
							removeStaticCube( j );
							j--; // we decrement j because after a cube is removed, numStaticCubes also decreases
						}
					}
					
					// move stacked cubes on that plane down to check for warping and exploding
					for( int j = numOriginalCubes; j < numStaticCubes; j++ )
					{
						// if the cube is in same direction as plane, move cubes one unit down depending on direction
						// and then check if this cube is touching the plane
						// Then shake camera
						if( cubeArray[j].direction == plane[i].direction )
						{
							playLandSoundHere = true;
							switch( cubeArray[j].direction )
							{
							case 1:
								cubeArray[j].position.z += s;
								break;
							case 2:
								cubeArray[j].position.x -= s;
								break;
							case 3:
								cubeArray[j].position.z -= s;
								break;
							case 4:
								cubeArray[j].position.x += s;
								break;
							case 5:
								cubeArray[j].position.y += s;
								break;
							case 6:
								cubeArray[j].position.y -= s;
								break;
							} // end of switch statement re-adjusting cube position

							// decrement its layer level after moving it one layer inward
							cubeArray[j].layerLevel -= 1;

							// if its layer level is 1, that means it's touching the side/plane, and also if it's got same color
							if( cubeArray[j].layerLevel == 1 && cubeArray[j].color == plane[i].color)
							{
								cubeArray[j].touchingSide = true;
								plane[i].count++; // add to plane's count
							}
							else // else, it's not the same color and should be exploding
							{
								// problem is, how can it find the cube underneath it?
								// need to run closest cube algorithm
								// too many problems. 
							}

							// shake camera
							// every time the camera shakes, it needs to start from beginning, so reset shakeCounter
							shakeCounter = 0;
							shakeCamera = true;

						} // end of re-adjusting cube if statement
					} // end of for looping through all cubes

					// PLAY LAND SOUND just once
					if( playLandSoundHere == true )
					{
						playLandSound(); // only play land sound if there were cubes that dropped
					}

					// this should not happen b/c not under perfect warp, but it does I think
					// GameOver, and/or level up
					// Show score if Game is over
					if( storyMode == true )
					{
						// Show Score Screen if game over
						if( episode == 1 || episode == 2 || episode == 3 )
						{
							/*
							if( levelNumber == 4 )
							{
								transition = true;
								transitionIsSet = false;
								TargetState = AT_SCORE_SCREEN;

								advanceToNextLevel = true;
								showCongratsSpriteComplete = true;

								playLevelCompleteSound();
							}
							else if( levelNumber == 7 )
							{
								transition = true;
								transitionIsSet = false;
								TargetState = AT_SCORE_SCREEN;

								advanceToNextLevel = true;
								showCongratsSpriteComplete = true;

								playLevelCompleteSound();
							}
							else */if( levelNumber == 10 )
							{
								transition = true;
								transitionIsSet = false;
								TargetState = AT_SCORE_SCREEN;

								advanceToNextLevel = true;
								showCongratsSpriteComplete = true;

								playLevelCompleteSound();
							}						
						}
						else if( episode == 4 || episode == 5 || episode == 6 )
						{
							if( levelNumber == 6 )
							{
								transition = true;
								transitionIsSet = false;
								TargetState = AT_SCORE_SCREEN;

								advanceToNextLevel = true;
								showCongratsSpriteComplete = true;

								playLevelCompleteSound();

								if( episode == 6 )
								{
									// override target state
									transition = true;
									transitionIsSet = false;
									TargetState = PLAY_CINEMATIC;

									if( trophies[4] == false && score > 1000000 )
									{
										showTrophySprite = true;

										trophies[4] = true;
									}

									SaveHighStats();
								}
							}
						}
					}
					else if( challengeMode == true )
					{
						if( cmSpeedLevel >= 6 && totalDrops >= cmNumOfRequiredDrops[cmDifficultyLevel]*5 )
						{
							setYellowFadeOut( 1000 );
							TransitionState = END_GAME_WIN;
						}
					}
					else if( developerLevels == true )
					{
						if( totalDrops >= 50 ) // about 5 min -> 300 sec -> 8sec/side -> 9cubes/side -> 337 drops
						{
							setYellowFadeOut( 1000 );
							TransitionState = END_GAME_WIN;
						}
					}
				} // end of plane warping but still active
				else // if warping limit is not reached, but plane is warping
				{
					if( plane[i].warpingUp == true )
						plane[i].warpingMaterialIntensity += 40; // increase the intensity
					else
						plane[i].warpingMaterialIntensity -= 20;


					if( plane[i].warpingMaterialIntensity >= 255 ) // clamp the intensity
					{
						plane[i].warpingMaterialIntensity = 255; // start the fading of warping
						plane[i].warpingUp = false;						
					}
					else if( plane[i].warpingMaterialIntensity <= 0 )
					{
						plane[i].warpingMaterialIntensity = 0;
						plane[i].warpingUp = true;
					}

					// set alpha to be transparent
					alphaValue_warpingMaterial = CIwMaterial::ALPHA_ADD;

					// increase the warping delay time. 
					// The Delay time is how long the cubes stay at maximum energy after getting there
					if( plane[i].warpingMaterialIntensity == 0 ) // if intensity has reached maximum
					{
						// increase wait time before removing
						plane[i].warpingDelayTime += 1;
					}
				}
			} // end of checking if this was active plane
			// PERFECT WARP GOES HERE
			else if( plane[i].active == false ) // this is if plane got deactivated and every cube warps out. handles warping out of every cube
			{									// but as implemented, should only happen when there are exactly 9 cubes
				// if the limit is reached, remove the cubes first
					// since it's 40 updates per second, 80 updates = 2 seconds
				if( plane[i].warpingDelayTime == 1 ) // no delay right now, b/c takes a long time anyway
				{
					// reset plane variables
					plane[i].beganWarping = false;
					plane[i].warpingDelayTime = 0;
					plane[i].count = 0;					

					// remove the finished-warping cubes
					for( int j = numOriginalCubes; j < numStaticCubes; j++ ) // check all the cubes
					{
						// remove cube if it was same side as plane
						if( cubeArray[j].direction == plane[i].direction )
						{
							removeStaticCube( j );
							j--; // we decrement j because after a cube is removed, numStaticCubes also decreases
						}
					}

					if( storyMode == true )
					{
						// Show Score Screen if game over
						if( episode == 1 || episode == 2 || episode == 3 )
						{
							/*if( levelNumber == 4 )
							{
								transition = true;
								transitionIsSet = false;
								TargetState = AT_SCORE_SCREEN;

								advanceToNextLevel = true;
								showCongratsSpriteComplete = true;

								playLevelCompleteSound();
							}
							else if( levelNumber == 7 )
							{
								transition = true;
								transitionIsSet = false;
								TargetState = AT_SCORE_SCREEN;

								advanceToNextLevel = true;
								showCongratsSpriteComplete = true;

								playLevelCompleteSound();
							}
							else */if( levelNumber == 10 )
							{
								transition = true;
								transitionIsSet = false;
								TargetState = AT_SCORE_SCREEN;

								advanceToNextLevel = true;
								showCongratsSpriteComplete = true;

								playLevelCompleteSound();
							}						
						}
						else if( episode == 4 || episode == 5 || episode == 6 )
						{
							if( levelNumber == 6 )
							{
								transition = true;
								transitionIsSet = false;
								TargetState = AT_SCORE_SCREEN;

								advanceToNextLevel = true;
								showCongratsSpriteComplete = true;

								playLevelCompleteSound();

								if( episode == 6 )
								{
									// override target state
									transition = true;
									transitionIsSet = false;
									TargetState = PLAY_CINEMATIC;

									if( trophies[4] == false )
									{
										showTrophySprite = true;										
									}

									trophies[4] = true;
									SaveHighStats();
								}
							}
						}
						// Show Score Screen if game over
						/*if( totalDrops >= storyLevelNumOfCompletionDrops ) // about 5 min -> 300 sec -> 8sec/side -> 9cubes/side -> 337 drops
						{
							setYellowFadeOut( 1000 );
							advanceToNextLevel = true;
							TransitionState = END_GAME_WIN;
						}*/
					}
					else if( challengeMode == true )
					{
						if( cmSpeedLevel >= 6 && totalDrops >= cmNumOfRequiredDrops[cmDifficultyLevel]*5 )
						{
							setYellowFadeOut( 1000 );
							TransitionState = END_GAME_WIN;
						}
					}
					else if( developerLevels == true )
					{
						if( totalDrops >= 50 ) // about 5 min -> 300 sec -> 8sec/side -> 9cubes/side -> 337 drops
						{
							setYellowFadeOut( 1000 );
							TransitionState = END_GAME_WIN;
						}
					}
				} // end of plane finish warping perfect clear
				else // if warping limit is not reached, but plane is warping
				{
					if( plane[i].warpingUp == true )
						plane[i].warpingMaterialIntensity += 40; // increase the intensity
					else
						plane[i].warpingMaterialIntensity -= 20;


					if( plane[i].warpingMaterialIntensity >= 255 ) // clamp the intensity
					{
						plane[i].warpingMaterialIntensity = 255; // start the fading of warping
						plane[i].warpingUp = false;						
					}
					else if( plane[i].warpingMaterialIntensity <= 0 )
					{
						plane[i].warpingMaterialIntensity = 0;
						plane[i].warpingUp = true;
					}

					// set alpha to be transparent
					alphaValue_warpingMaterial = CIwMaterial::ALPHA_ADD;

					// increase the warping delay time. 
					// The Delay time is how long the cubes stay at maximum energy after getting there
					if( plane[i].warpingMaterialIntensity == 0 ) // if intensity has reached maximum
					{
						// increase wait time before removing
						plane[i].warpingDelayTime += 1;
					}
				}
			} // end of plane warping perfect clear
		}
	}
	// Check if plane is filled and begin warping
	for( int i = 0; i < 6; i++ )
	{
		// checks if a bomb is on that plane side that prevents from warping
		for( int j = 0; j < 6; j++ )
		{
			// reset bomb existance
			bombExistsOnPlane[j] = false;
		}
		bombsLanded = false;
		
		// check bomb existance
		for( int j = numOriginalCubes; j < numStaticCubes; j++ )
		{
			if( cubeArray[j].hasBomb == true )
			{
				// set existance of bomb on direction to be true
				bombExistsOnPlane[ cubeArray[j].direction - 1 ] = true;
				bombsLanded = true;
			}
		}
		
		// checks of plane is filled with same color cubes
		// IF A PLANE IS FILLED
		if( plane[i].count == (numCubesWidth * numCubesWidth) && plane[i].beganWarping == false && bombExistsOnPlane[plane[i].direction - 1] == false )
		{
			plane[i].beganWarping = true;
			plane[i].warpingMaterialIntensity = 0;
			plane[i].winCount++; // increments wincount every time plane is filled
			plane[i].allowSingleCubeSpawn = true;
			plane[i].highestLayerLevel--; // subtract the plane's layer level

			// set level up to be false unless otherwise true
			levelUp = false;

			// hide tutorial complete side
			if( triggeredShowTutorialCompleteSide == true && triggeredHideTutorialCompleteSide == false )
			{
				// trigger showing of perfect clear when complete side is done
				s3eTimerSetTimer( 8000, triggerTutorialPerfectClearEnable, 0 );

				s3eTimerSetTimer( 0, triggerHideTutorialCompleteSide, 0 );
				s3eTimerCancelTimer( triggerShowTutorialCompleteSide, 0 ); // on perfect clear, it goes away faster than it comes in.
				triggeredHideTutorialCompleteSide = true;
			}

			// reset tutorial drops
			numOfTutorialDropsCurrent = 0;

			// Combo Perk check
			if( plane[i].highestLayerLevel == 0 )
			{
				perfectWarpCount++;
				perfectWarped = true;

				// reset the check for perfect warp so that perfectWarped does not get reset
				checkPerfectWarped = false;				

				// hide tutorial perfect clear
				if( triggeredShowTutorialPerfectClear == true && triggeredHideTutorialPerfectClear == false )
				{
					s3eTimerSetTimer( 5000, triggerTutorialPerfectClearEnable, 0 );

					s3eTimerSetTimer( 0, triggerHideTutorialPerfectClear, 0 );
					s3eTimerCancelTimer( triggerShowTutorialPerfectClear, 0 );
					triggeredHideTutorialPerfectClear = true;
					triggeredShowTutorialPerfectClear = false;
				}
			}

			// LEVEL UP
			if( storyMode == true )
			{
				// ADD totalDrops to INCREASE PROGRESS BAR
				if( plane[i].highestLayerLevel == 0 ) // PERFECT WARP
				{
					// Add total drops based on combo
					switch( perfectWarpCount )
					{
					// if it was a perfect warp, add a lot
					case 1:
						storyModeTotalDropsCurrent += 6;
						break;
					case 2:
						storyModeTotalDropsCurrent += 9;
						break;
					default:
						storyModeTotalDropsCurrent += 18;
						break;
					}
				}
				else // NOT perfect warp
				{
					storyModeTotalDropsCurrent += 3;
				}

				// level up sound if not perfect cleare
				if( plane[i].highestLayerLevel != 0 )
				{
					playCelebration1();
				}

				// LEVEL UP conditions. Bombs don't spawn on first level of every episode. This actually works well.
				if( storyModeTotalDropsCurrent >= storyModeRequiredDrops[levelNumber] && plane[i].highestLayerLevel == 0 )
				{
					storyModeTotalDropsCurrent = 0;					
					levelNumber++;					

					// level up, begin interim cinematics
					if( episode >= 1 && episode <= 3 )
					{
						// Transition into interim cinematic
						if( levelNumber == 4 && playedFirstInterimCinematic == false )
						{
							TargetState = AT_SCORE_SCREEN;

							// hide tutorial sprites
							for( int i = 0; i < NUM_OF_TUTORIAL_MESSAGES - 2; i++ )
							{
								showTutorialSprites[i] = false;
							}

							/* set at end of congrats level up sprite
							transition = true;
							transitionIsSet = false;				
							*/

							// if the shadow landing is the one that is being touched
							if( selectedShadow != NULL )
							{
								selectedShadow->shadowGroup->dropCubes = true;// this prevents the shadows and cubes from being moved
								selectedShadow = NULL;

								shadowIsTouched = false;
							}

							// remove all moving cubes
							for( int k = 0; k < numMovingCubesIndex; k++ )
							{
								removeMovingCubeAndTerminate( k );
								removeShadow( k );
								k--;
							}

							playedFirstInterimCinematic = true;
							advanceToNextLevel = true;
						}

						if( levelNumber == 7 && playedSecondInterimCinematic == false )
						{
							TargetState = AT_SCORE_SCREEN;
							/* Set at congratslevelupsprite
							transition = true;
							transitionIsSet = false;
							*/

							// if the shadow landing is the one that is being touched
							if( selectedShadow != NULL )
							{
								selectedShadow->shadowGroup->dropCubes = true;// this prevents the shadows and cubes from being moved
								selectedShadow = NULL;

								shadowIsTouched = false;
							}

							// remove all moving cubes
							for( int k = 0; k < numMovingCubesIndex; k++ )
							{
								removeMovingCubeAndTerminate( k );
								removeShadow( k );
								k--;
							}

							playedSecondInterimCinematic = true;
							advanceToNextLevel = true;
						}
					} // end of if episode is between 1 and 3 for interim cinematics
					else if( episode >= 4 && episode <= 6 ) // no interim cinematics for 4-6
					{
						if( levelNumber == 6 )
						{

						}
					}

					// reset the ep3 seconds on level up
					if( levelNumber == 7 )
					{
						ep3Seconds = 170; // old value was 150
					}
					else if( levelNumber == 8 )
					{
						ep3Seconds = 190; // old value was 170
					}
					else if( levelNumber == 9 )
					{
						ep3Seconds = 210; // old value was 190
					}

					/*
					// interim cinematic
					if( episode >= 1 && episode <= 3 )
					{
						if( levelNumber == 4 && playedFirstInterimCinematic == false )
						{
							TargetState = PLAY_CINEMATIC; // this turns of spawning of bomb for first one
						}

						if( levelNumber == 7 && playedSecondInterimCinematic == false )
						{
							TargetState = PLAY_CINEMATIC;
						}
					}
					*/
					
					if( showCongratsSpriteComplete == false ) // Level completion has priority over level up perk
					{
						levelUp = true;
					}
					else
					{
						levelUp = false;
					}

					// bombs spawn levels 1-9 on episode2+ but frequency varies
					if( episode >= 2 && episode <= 6 )
					{
						spawnBombMode = true;
						spawnBomb = true;

						// bomb frequencies for each episode
						if( episode == 2 )
						{
							// bomb frequency = 1 for ep2 levels 1-3
							if( levelNumber >= 1 && levelNumber <= 3 )
							{
								bombFrequency = 1;
							}
							else // bomb frequency = 2 for ep2 levels 4-9
							{
								bombFrequency = 2;
							}
						}
						else if( episode == 3 )
						{
							// bomb frequency = 1 for ep3 levels 1-3
							if( levelNumber >= 4 && levelNumber <= 9 )
							{
								bombFrequency = 2;
							}
							else
							{
								bombFrequency = 1;
							}
						}
						else if( episode == 4 )
						{
							// bomb frequency = 1 for ep4 levels 1-3
							if( levelNumber >= 2 && levelNumber <= 3 )
							{
								bombFrequency = 1;
							}
							else if( levelNumber >= 4 && levelNumber <= 5 )
							{
								bombFrequency = 2;
							}
						}
						else if( episode == 5 )
						{
							// bomb frequency = 1 for ep4 levels 1-3
							if( levelNumber >= 2 && levelNumber <= 3 )
							{
								bombFrequency = 2;
							}
							else if( levelNumber >= 4 && levelNumber <= 5 )
							{
								bombFrequency = 3;
							}
						}
						else if( episode == 6 )
						{
							// bomb frequency = 1 for ep4 levels 1-3
							if( levelNumber >= 2 && levelNumber <= 3 )
							{
								bombFrequency = 3;
							}
							else if( levelNumber >= 4 && levelNumber <= 5 )
							{
								bombFrequency = 3;
							}
						}
					}
					else if( episode == 1 ) // episode 1 bomb spawning
					{
						// Bomb spawning conditions
						if( levelNumber >= 4 && levelNumber <= 9 )
						{
							// bombs spawn levels 4-9 on episode1
							spawnBombMode = true;
							spawnBomb = true;

							bombFrequency = 1;
							printf("Bombs SHOULD be spawning...\n");
						}
						else
						{
							spawnBombMode = false;

							printf("Bombs did NOT spawn...\n");
						}
					}

					if( episode >= 1 && episode <= 3 )
					{
						// speed conditions
						if( levelNumber >= 1 && levelNumber <= 3 )
						{
							INITIAL_SPEED = 400; // this is the default speed. Make it change on certain levels
						}
						else if( levelNumber >= 4 && levelNumber <= 6 )
						{
							INITIAL_SPEED = 600;
						}
						if( levelNumber >= 7 && levelNumber <= 9 )
						{
							INITIAL_SPEED = 700;
						}
					}
					else if( episode >= 4 && episode <= 6 )
					{
						if( episode == 4 )
						{
							if( levelNumber == 1 )
							{
								INITIAL_SPEED = 600;
							}
							else if( levelNumber == 2 )
							{
								INITIAL_SPEED = 650;
							}
							else if( levelNumber == 3 )
							{
								INITIAL_SPEED = 700;
							}
							else if( levelNumber >= 4 && levelNumber <= 5 )
							{
								INITIAL_SPEED = 800;
							}
						}
						else if( episode == 5 )
						{
							if( levelNumber >= 1 && levelNumber <= 3 )
							{
								INITIAL_SPEED = 800;
							}
							else if( levelNumber >= 4 && levelNumber <= 5 )
							{
								INITIAL_SPEED = 850;
							}
						}
						else if( episode == 6 )
						{
							if( levelNumber >= 1 && levelNumber <= 3 )
							{
								INITIAL_SPEED = 800;
							}
							else if( levelNumber >= 4 && levelNumber <= 5 )
							{
								INITIAL_SPEED = 850;
							}
						}
					}


					switch( levelNumber )
					{
					case 2:
						if( episode == 1 )
						{
							// stay on QFI, increase difficulty cap
							// no changes to qfi. it should be turned on.
							qfiDifficultyCap = 3;
						}
						else if( episode == 2 )
						{
							planeSpawning = TRIPLE_RANDOM;
							cubeSpawning = TRIPLE_INCOLOR;

							// no sides increase
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 3 )
						{
							planeSpawning = QUADRUPLE_RANDOM;
							cubeSpawning = QUADRUPLE_INCOLOR;

							// no sides increase
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 4 )
						{
							planeSpawning = QUINTUPLE_RANDOM;
							cubeSpawning = QUADRUPLE_RANDOM;

							// no sides increase
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 5 )
						{
							planeSpawning = QUINTUPLE_RANDOM;
							cubeSpawning = QUINTUPLE_RANDOM;

							// no sides increase
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 6 )
						{
							planeSpawning = SEXTUPLE;
							cubeSpawning = SEXTUPLE_RANDOM;

							// no change
						}
						break;

					case 3:
						if( episode == 1 )
						{
							// level 3 changes depending on qfi state from level 2
							// also turn off qfi
							qfiMode = false;
							planeSpawning = QUADRUPLE_RANDOM;
							cubeSpawning = DOUBLE_RANDOM;
						
						
							// if qfi is at level 1
							if( difficulty == 1 )
							{
								// increase 2 sides
								ActivateTwoSides();
								// remove 1 side
								DeactivateSide( i );
							}
							// if qfi is at level 2, 3, or 4
							else
							{
								// increase 1 side
								ActivateOneSide();
								// remove 1 side
								DeactivateSide( i );
							}
						}
						else if( episode == 2 )
						{
							planeSpawning = TRIPLE_RANDOM;
							cubeSpawning = TRIPLE_RANDOM;

							// no increase							
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 3 )
						{
							planeSpawning = QUADRUPLE_RANDOM;
							cubeSpawning = QUADRUPLE_RANDOM;

							// no sides increase
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 4 )
						{
							planeSpawning = QUINTUPLE_RANDOM;
							cubeSpawning = QUINTUPLE_RANDOM;

							// no sides increase
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 5 )
						{
							planeSpawning = QUINTUPLE_RANDOM;
							cubeSpawning = QUINTUPLE_RANDOM;

							// no sides increase
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 6 )
						{
							planeSpawning = SEXTUPLE;
							cubeSpawning = SEXTUPLE_RANDOM;

							// no change
						}
						break;

					case 4:
						if( episode == 1 )
						{
							planeSpawning = TRIPLE_RANDOM;
							cubeSpawning = DOUBLE_RANDOM;

							// increase by 1 side total
							ActivateTwoSides();
							DeactivateSide( i );
						}
						else if( episode == 2 )
						{
							planeSpawning = TRIPLE_RANDOM;
							cubeSpawning = TRIPLE_RANDOM;

							// no side change
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 3 )
						{
							planeSpawning = QUADRUPLE_RANDOM;
							cubeSpawning = QUADRUPLE_RANDOM;

							// no sides increase
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 4 )
						{
							planeSpawning = QUINTUPLE_RANDOM;
							cubeSpawning = QUADRUPLE_RANDOM;

							// no sides increase
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 5 )
						{
							planeSpawning = SEXTUPLE;
							cubeSpawning = QUINTUPLE_RANDOM;

							// iNCREASE by 1
							ActivateOneSide();
						}
						else if( episode == 6 )
						{
							planeSpawning = SEXTUPLE;
							cubeSpawning = SEXTUPLE_RANDOM;

							// no sides increase
						}
						break;

					case 5:
						if( episode == 1 )
						{
							planeSpawning = TRIPLE_RANDOM;
							cubeSpawning = DOUBLE_INCOLOR;			

							// no sides increase
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 2 )
						{
							planeSpawning = QUADRUPLE_RANDOM;
							cubeSpawning = QUINTUPLE_RANDOM;

							// increase one side total
							ActivateTwoSides();
							DeactivateSide( i );
						}
						else if( episode == 3 )
						{
							planeSpawning = QUINTUPLE_RANDOM;
							cubeSpawning = QUINTUPLE_INCOLOR;

							// increase by 1 side total
							ActivateTwoSides();
							DeactivateSide( i );
						}
						else if( episode == 4 )
						{
							planeSpawning = SEXTUPLE;
							cubeSpawning = QUINTUPLE_RANDOM;

							// no sides increase
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 5 )
						{
							planeSpawning = SEXTUPLE;
							cubeSpawning = QUADRUPLE_RANDOM;

							// no sides increase
						}
						else if( episode == 6 )
						{
							planeSpawning = SEXTUPLE;
							cubeSpawning = SEXTUPLE_RANDOM;

							// no sides increase
						}
						break;

					case 6: 
						if( episode == 1 )
						{
							planeSpawning = QUADRUPLE_RANDOM;
							cubeSpawning = DOUBLE_RANDOM;	

							// increase by 1 side total
							ActivateTwoSides();
							DeactivateSide( i );
						}
						else if( episode == 2 )
						{
							planeSpawning = QUADRUPLE_RANDOM; 
							cubeSpawning = TRIPLE_RANDOM;

							// no side change
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 3 )
						{
							planeSpawning = QUINTUPLE_RANDOM;
							cubeSpawning = QUADRUPLE_RANDOM;

							// no sides increase
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 4 )
						{
							planeSpawning = SEXTUPLE;
							cubeSpawning = QUINTUPLE_RANDOM;

							// no increase or decrease. not even removal
						}
						break;

					case 7:
						if( episode == 1 )
						{
							planeSpawning = QUADRUPLE_RANDOM;
							cubeSpawning = DOUBLE_RANDOM;

							// no side increase
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 2 )
						{
							planeSpawning = QUADRUPLE_RANDOM; 
							cubeSpawning = QUADRUPLE_INCOLOR;

							// no side change
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 3 )
						{
							planeSpawning = QUINTUPLE_RANDOM;
							cubeSpawning = QUINTUPLE_INCOLOR;

							// no sides increase
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 4 )
						{
							planeSpawning = SEXTUPLE;
							cubeSpawning = SEXTUPLE_INCOLOR;

							// no increase or decrease
						}
						break;

					case 8:
						if( episode == 1 )
						{
							planeSpawning = TRIPLE_RANDOM;
							cubeSpawning = TRIPLE_INCOLOR;

							// no side change
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 2 )
						{
							planeSpawning = QUADRUPLE_RANDOM;
							cubeSpawning = TRIPLE_RANDOM;

							// increase one side total
							ActivateTwoSides();
							DeactivateSide( i );
						}
						else if( episode == 3 )
						{
							planeSpawning = QUINTUPLE_RANDOM;
							cubeSpawning = QUADRUPLE_RANDOM;

							// no sides increase
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 4 )
						{
							planeSpawning = SEXTUPLE;
							cubeSpawning = QUINTUPLE_RANDOM;

							// no increase or decrease
						}
						break;

					case 9:
						if( episode == 1 )
						{
							planeSpawning = TRIPLE_RANDOM;
							cubeSpawning = TRIPLE_RANDOM;

							// no side increase
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 2 )
						{
							planeSpawning = QUADRUPLE_RANDOM;
							cubeSpawning = QUADRUPLE_RANDOM;

							// no change in sides
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 3 )
						{
							planeSpawning = QUINTUPLE_RANDOM;
							cubeSpawning = QUINTUPLE_RANDOM;

							// no change in net sides
							ActivateOneSide();
							DeactivateSide( i );
						}
						else if( episode == 4 )
						{
							planeSpawning = SEXTUPLE;
							cubeSpawning = SEXTUPLE_RANDOM;

							// no change at all
						}
						break;

					case 10: 
						break;
					} // end of switch statement for level progression
				} // end of if highest layer == 0 to determine level progression
			} // end of if( storyMode == true ) for level progression

			// show congrats Great sprite
			if( plane[i].highestLayerLevel == 0 && GameState == PLAY_GAME )
			{				
				if( perfectWarpCount == 1 )
				{
					showCongratsSpriteNice = true;
					if( levelNumber != 10 ) // plays the celebration if it's not the end of episode. End of episode sound conflicts with "complete" voice
					{
						playCelebration2();
					}
				}
				else if( perfectWarpCount == 2 )
				{
					showCongratsSpriteGreat = true;
					if( levelNumber != 10 )
					{
						playCelebration2();
					}
				}
				else if( perfectWarpCount >= 3 )
				{
					showCongratsSpriteSuper = true;
					if( levelNumber != 10 )
					{
						playCelebration2();
					}
				}
			}

			// add five hundred points			
			if( plane[i].highestLayerLevel > 0 ) // add points only if not perfectly clearing side
			{
				if( percentComplete < 1.0 )
				{
					for( int j = 0; j < 4; j++ ) // find the free sprite 
					{
						if( pointSprites[i][j].type == PointSprite::NONE ) // means it's free
						{
							pointSprites[i][j].setType( PointSprite::FIVE_HUNDRED ); // it is one hundred points if it is a fuzzy	
							addScore( 500 );

							//scoredDrops += 1;
							//scoredDropsCurrent += 1;

							//pointSprites[i][j].setPosition( IwGxGetScreenWidth()/2 + 15, IwGxGetScreenHeight()/2 - 50);// set the location
							pointSprites[i][j].setPosition( IwGxGetScreenWidth()/2 + width*.031, IwGxGetScreenHeight()/2 - height*.156);// set the location

							break; // stop assigning and activating sprites once free one is found
						}
					}
				}
			}

			// add one thousand/five thousand/ten thousand points
			if( plane[i].highestLayerLevel == 0 )
			{
				for( int j = 0; j < 4; j++ ) // find the free sprite 
				{
					if( pointSprites[i][j].type == PointSprite::NONE ) // means it's free
					{
						// add the three tier points depending on how many perfect warps are cleared in a row
						if( perfectWarpCount == 1 )
						{
							pointSprites[i][j].setType( PointSprite::FIVE_THOUSAND ); // it is one hundred points if it is a fuzzy	
							addScore( 5000 );

							scoredDrops += 1;
							scoredDropsCurrent += 1;
						}
						else if( perfectWarpCount == 2 )
						{
							pointSprites[i][j].setType( PointSprite::TEN_THOUSAND ); // it is one hundred points if it is a fuzzy	
							addScore( 10000 );

							scoredDrops += 2;
							scoredDropsCurrent += 2;
						}
						else if( perfectWarpCount >= 3 )
						{
							pointSprites[i][j].setType( PointSprite::TEN_THOUSAND ); // it is one hundred points if it is a fuzzy	
							addScore( 10000 );

							scoredDrops += 3;
							scoredDropsCurrent += 3;

							numOfLives++;
							showPlusOneFuzzy = true;
						}

						//pointSprites[i][j].setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 - 125);// set the location
						pointSprites[i][j].setPosition( IwGxGetScreenWidth()/2, IwGxGetScreenHeight()/2 - height*.251);// set the location

						break; // stop assigning and activating sprites once free one is found
					}
				}
			}

			// gain one life
			// every time score goes over a 25k threshold, gain one life
			// keep track of how many lives have been gained. 
			// multiply lives gained by 25k. 
			// if score is greater than (livesgained+1)x25k, add a life			
			if( scoreLivesBonusBucket > 25000 )
			{
				scoreLivesBonusBucket %= 25000;
				numOfLives++;

				showPlusOneFuzzy = true;
			}

			// allows normal spawning of plane sides unless QFI specifies otherwise
			increasedASide = false;
			decreasedASide = false;

			// PLAY WARP SOUNDS
			if( plane[i].highestLayerLevel == 0 )
			{
				playWarpSound();
			}
			else
			{
				playNotSoGoodWarpSound();
			}

			// DETERMINE THE WINNING CONDITION FOR LEVEL INCREMENT
			// ADD AND SPAWN A PLANE 
			// if( GameState == PLAY_GAME )
			if( GameState == PLAY_GAME )
			{
				if( qfiMode == true )
				{
					if( targetDifficulty != difficulty ) // only perform these calculations if QFI is trying to change difficulty
					{
						// QFI ALGORITHM - SPAWNING
						// Match Spawning with Target Spawning
						if( planeSpawning == targetPlaneSpawning ) // if plane was matched with target already
						{
							// set the cube spawn
							cubeSpawning = targetCubeSpawning;
						}
						else if( targetDifficulty > difficulty  ) // if difficulty needs to increase
						{
							// if the planeSides are DECREASING due to increase in difficulty, 
							// do nothing. Let player warp cubes until planeSpawning = target planes
							if( targetDifficulty == 7 || 
								targetDifficulty == 12 || 
								targetDifficulty == 16 ) // these are the targetDifficulties where planes decrease
							{
								// do nothing
							}
							else // if the planeSides are INCREASING
							{
							
								/* Chart
								difficulty  planeSpawn  cubeSpawn		NumOfSides NumOfCubes
								1			SINGLE_RAN	SINGLE_RAN		1			1
								2			DOUBLE_ADJ	SINGLE_RAN		2			1
								3			DOUBLE_ADJ	DOUBLE_INC - 3	2			2
								4			DOUBLE_RAN	DOUBLE_RAN		2			2
								5			TRIPLE_RAN	DOUBLE_RAN		3			2
								6			QUAD_RAN	DOUBLE_RAN		4			2
								7			TRIPLE_RAN	TRIPLE_INC - 7	3			3
								8			TRIPLE_RAN	TRIPLE_RAN		3			
								9			QUAD_RAN	TRIPLE_RAN		4
								10			QUIN_RAN	TRIPLE_RAN		5
								11			SEXTUP_RAN	TRIPLE_RAN		6
								12			QUAD_RAN	QUAD_INC - 12	4
								13			QUAD_RAN	QUAD_RAN		4	
								14			QUIN_RAN	QUAD_RAN		5
								15			SEXTUP_RAN	QUAD_RAN		6	
								16			QUIN_RAN	QUIN_INC - 16	5
								17			QUIN_RAN	QUIN_RAN		5
								18			SEXTUP		QUIN_RAN		6
								19			SEXTUP		SEXTUP_INC - 19	6
								20			SEXTUP		SEXTUP_RAN		6
								*/
								if( targetDifficulty == 2 ) // increasing from 1 to 2 adj
								{			
									if( plane[i].highestLayerLevel == 0 ) // increase to ADJACENT on PERFECT CLEAR
									{
										// spawn two adjacent planes
										// Activate new Planes and deactivate old plane
										// activate 2 other sides at random that wasn't just already active. one of them must be adjacent
										IwRandSeed( (int32)s3eTimerGetMs() );
										int16 b = IwRandMinMax( 0, 5+1 );

										while( plane[b].active == true ) // b cannot be equal to a or i
										{
											b = IwRandMinMax( 0, 5+1 );
										}
										plane[b].active = true;

										// activate 1 other adjacent side
										IwRandSeed( (int32)s3eTimerGetMs() );
										int16 dir;
										int a;  // the indexes for planes datastructure

										do
										{
											dir = getAdjacentDirection( plane[b].direction );

											// find a, index of plane with the adjacent direction
											for( int j = 0; j < 6; j++ )
											{
												if( plane[j].direction == dir )
												{
													a = j;
													break;
												}
											}
										}
										while( plane[a].active == true );

										// activate the new plane
										plane[a].active = true;

										// deactivate old plane
										plane[i].active = false;
										plane[i].resetCounts();

										// tells the normal plane spawning algorithm to not activate if a side was spawned here
										increasedASide = true;
										decreasedASide = true;
									} // end of highest layer count == 0
									else if( plane[i].highestLayerLevel != 0 && totalDrops > 15 ) // also increases plane side if not a perfect clear on lvl 1
									{
										IwRandSeed( (int32)s3eTimerGetMs() );

										// activate 1 other adjacent side
										IwRandSeed( (int32)s3eTimerGetMs() );
										int16 dir;
										int a;  // the indexes for planes datastructure

										do
										{
											dir = getAdjacentDirection( plane[i].direction );

											// find a, index of plane with the adjacent direction
											for( int j = 0; j < 6; j++ )
											{
												if( plane[j].direction == dir )
												{
													a = j;
													break;
												}
											}
										}
										while( plane[a].active == true );

										// activate the new plane
										plane[a].active = true;

										// tells the normal plane spawning algorithm to not activate if a side was spawned here
										increasedASide = true;
										decreasedASide = true;
									}
								}// end of if targetDifficulty == 2
								else if( targetDifficulty == 5 ||
										targetDifficulty == 6 ||
										targetDifficulty == 9 ||
										targetDifficulty == 10 ||
										targetDifficulty == 11 || 
										targetDifficulty == 14 ||
										targetDifficulty == 15 ||
										targetDifficulty == 18 ) // increase a side on NON PERFECT CLEAR
								{
									if( plane[i].highestLayerLevel != 0 )
									{
										int16 a = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
										while( plane[a].active == true ) // 'a' side cannot be equal to plane just deactivated. i here is not direction of plane, just index for diff. planes
										{
											a = IwRandMinMax( 0, 5+1 );
										}
										// activate the new plane
										plane[a].active = true;

										increasedASide = true;
										decreasedASide = true;
									}
									else if( plane[i].highestLayerLevel == 0 && 
											(targetDifficulty == 11 ||
											targetDifficulty == 15 ||
											targetDifficulty == 18 ) ) // increase a side on PERFECT clear when increasing from quintuple to sextuple
									{
										int16 a = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
										while( plane[a].active == true ) // 'a' side cannot be equal to plane just deactivated. i here is not direction of plane, just index for diff. planes
										{
											a = IwRandMinMax( 0, 5+1 );
										}
										// activate the new plane
										plane[a].active = true;

										increasedASide = true;
										decreasedASide = true;
									}
									else if( plane[i].highestLayerLevel == 0 &&
											(targetDifficulty != 11 &&
											targetDifficulty != 15 && 
											targetDifficulty != 18 ) ) // increase a side on PERFECT CLEAR when NOT increasing from quintuple to sextuple
									{
										// Deactivate 1 side and Activate 2 sides
										// activate 2 other sides at random that wasn't just already active, and it cannot be another active side
										IwRandSeed( (int32)s3eTimerGetMs() );
										int16 b = IwRandMinMax( 0, 5+1 );
										while( plane[b].active == true )
										{
											b = IwRandMinMax( 0, 5+1 );
										}
										// activate the new plane
										plane[b].active = true;

										int16 a = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
										while( plane[a].active == true ) // 'a' side cannot be equal to plane just deactivated. i here is not direction of plane, just index for diff. planes
										{
											a = IwRandMinMax( 0, 5+1 );
										}
										// activate the new plane
										plane[a].active = true;

										// deactivate the old plane
										plane[i].active = false;
										plane[i].resetCounts();

										// tells the normal plane spawning algorithm to not activate if a side was spawned here
										increasedASide = true;
										decreasedASide = true;
									} // end of highest layer level == 0
								} // end of increasing by 1 side on perfect clear
							} // end of increasing plane sides
						}  // end of increasing target difficulty
						else if( targetDifficulty < difficulty ) // if difficulty needs to decrease
						{
							// if the planeSides are DECREASING due to DECREASE in difficulty, 
							// do nothing. Let player warp cubes until planeSpawning = target planes
						
						}

						// decreasing a side when increasing
						if( decreasedASide == false && targetDifficulty > difficulty && 
							(targetDifficulty == 7 ||
							targetDifficulty == 12 ||
							targetDifficulty == 16) )
						{
							if( plane[i].highestLayerLevel == 0 )
							{
								plane[i].active = false;
								plane[i].resetCounts();

								decreasedASide = true;
							}
						}
						// decreasing a side when reducing
						else if( decreasedASide == false && targetDifficulty < difficulty &&
							(targetDifficulty == 1 ||
							targetDifficulty == 4 ||
							targetDifficulty == 5 ||
							targetDifficulty == 8 ||
							targetDifficulty == 9 ||
							targetDifficulty == 10 ||
							targetDifficulty == 13 ||
							targetDifficulty == 14 ||
							targetDifficulty == 17)
							 ) // if difficulty is not at targetDifficulty, and could not spawn, then just deactivate the plane that just perfect-warped
						{
							if( plane[i].highestLayerLevel == 0 )
							{
								if( planeSpawning != targetPlaneSpawning )
								{
									plane[i].active = false;
									plane[i].resetCounts();

									decreasedASide = true;
								}
							}
						}
					
					} // end of if difficulty != targetDifficulty

					// MATCHING planeSpawning with targetPlaneSpawning
					int16 numActivePlanes = 0;
					for( int j = 0; j < 6; j++ )
					{
						if( plane[j].active == true )
						{
							numActivePlanes++;
						}
					}

					switch( targetPlaneSpawning )
					{
					case SINGLE_RANDOM:
						if( numActivePlanes == 1 )
						{
							planeSpawning = targetPlaneSpawning;
						}
						break;
					case DOUBLE_ADJACENT:
						if( numActivePlanes == 2 )
						{
							planeSpawning = targetPlaneSpawning;
						}
						break;
					case DOUBLE_RANDOM:
						if( numActivePlanes == 2 )
						{
							planeSpawning = targetPlaneSpawning;
						}
						break;
					case TRIPLE_RANDOM:
						if( numActivePlanes == 3 )
						{
							planeSpawning = targetPlaneSpawning;
						}
						break;
					case QUADRUPLE_RANDOM:
						if( numActivePlanes == 4 )
						{
							planeSpawning = targetPlaneSpawning;
						}
						break;
					case QUINTUPLE_RANDOM:
						if( numActivePlanes == 5 )
						{
							planeSpawning = targetPlaneSpawning;
						}
						break;
					case SEXTUPLE:
						if( numActivePlanes == 6 )
						{
							planeSpawning = targetPlaneSpawning;
						}
						break;
					}

					// TARGET PLANE SPAWNING REACHED
					// need to set again b/c cubeSpawning was tweaked in the ifstatement above for reducing difficulty
					if( planeSpawning == targetPlaneSpawning )
					{
						cubeSpawning = targetCubeSpawning;
					}

					// TARGET DIFFICULTY REACHED
					// set the difficulty to have it already increase if everything matches
					if( planeSpawning == targetPlaneSpawning && cubeSpawning == targetCubeSpawning )
					{
						// Debug
						//printf("\n---------LEVEL CHANGED. RESET QFI VARIABLES!------------\n\n");

						// RESET Statistics
						// only reset Statstics for checking if drops required is met when they complete a side and JUST changed diff.
						if( targetDifficulty > difficulty || targetDifficulty < difficulty )
						{
							// reset the variables for measuring performance
							ResetQFIVariablesCurrent();
						}

						difficulty = targetDifficulty;
						targetDifficultyReached = true;
					}

					// NORMAL PLANE SPAWNING
					if( planeSpawning == targetPlaneSpawning && increasedASide == false && decreasedASide == false )
					{
						if( planeSpawning == SINGLE_RANDOM || 
							planeSpawning == DOUBLE_RANDOM ||
							planeSpawning == TRIPLE_RANDOM ||
							planeSpawning == QUADRUPLE_RANDOM ||
							planeSpawning == QUINTUPLE_RANDOM )
						{
							if( plane[i].highestLayerLevel == 0 )
							{
								// activate 1 other side at random that wasn't just already active, and it cannot be another active side
								IwRandSeed( (int32)s3eTimerGetMs() );
								int16 a = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
								while( a == i || plane[a].active == true ) // 'a' side cannot be equal to plane just deactivated. i here is not direction of plane, just index for diff. planes
								{
									a = IwRandMinMax( 0, 5+1 );
								}

								// activate the new plane
								plane[a].active = true;

								// deactivate the old plane
								plane[i].active = false;
								plane[i].resetCounts();
							}
						}
						else if( planeSpawning == DOUBLE_ADJACENT )
						{
							if( plane[i].highestLayerLevel == 0 )
							{
								// Activate ADJACENT Side
								// activate 1 other side at random that wasn't just already active, and it cannot be another active side
								IwRandSeed( (int32)s3eTimerGetMs() );
								int16 dir;
								int a;  // the indexes for planes datastructure

								// Find Adjacent side
								do
								{
									// find the plane that is active that is not the one that just warped
									for( int j = 0; j < 6; j++ )
									{
										if( plane[j].active == true && j != i )
										{
											dir = getAdjacentDirection( plane[j].direction );
											break;
										}
									}							 

									// find a, index of plane with the adjacent direction
									for( int j = 0; j < 6; j++ )
									{
										if( plane[j].direction == dir )
										{
											a = j;
											break;
										}
									}
								}
								while( a == i || plane[a].active == true );

								// activate the new plane
								plane[a].active = true;

								// deactivate the old plane
								plane[i].active = false;
								plane[i].resetCounts();
							}
						}
					} // end of normal plane spawning
				} // end of if qfiMode == true
				else // this is for challenge mode
				{
					// THE FOLLOWING WAS USED FOR DEVELOPER LEVELS THAT DO NOT MOVE UP OR DOWN IN DIFF.
					if( challengeMode == true || levelUp == false ) // level up for story mode
					{
						if( planeSpawning == SINGLE_RANDOM || 
							planeSpawning == DOUBLE_RANDOM ||
							planeSpawning == TRIPLE_RANDOM ||
							planeSpawning == QUADRUPLE_RANDOM ||
							planeSpawning == QUINTUPLE_RANDOM )
						{
							if( plane[i].highestLayerLevel == 0 )
							{
								// activate 1 other side at random that wasn't just already active, and it cannot be another active side
								IwRandSeed( (int32)s3eTimerGetMs() );
								int16 a = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
								while( a == i || plane[a].active == true ) // 'a' side cannot be equal to plane just deactivated. i here is not direction of plane, just index for diff. planes
								{
									a = IwRandMinMax( 0, 5+1 );
								}

								// activate the new plane
								plane[a].active = true;

								// deactivate the old plane
								plane[i].active = false;
								plane[i].resetCounts();
							}
						}
						else if( planeSpawning == DOUBLE_ADJACENT )
						{
							if( plane[i].highestLayerLevel == 0 )
							{
								// Activate ADJACENT Side
								// activate 1 other side at random that wasn't just already active, and it cannot be another active side
								IwRandSeed( (int32)s3eTimerGetMs() );
								int16 dir;
								int a;  // the indexes for planes datastructure

								// Find Adjacent side
								do
								{
									// find the plane that is active that is not the one that just warped
									for( int j = 0; j < 6; j++ )
									{
										if( plane[j].active == true && j != i )
										{
											dir = getAdjacentDirection( plane[j].direction );
											break;
										}
									}							 

									// find a, index of plane with the adjacent direction
									for( int j = 0; j < 6; j++ )
									{
										if( plane[j].direction == dir )
										{
											a = j;
											break;
										}
									}
								}
								while( a == i || plane[a].active == true );

								// activate the new plane
								plane[a].active = true;

								// deactivate the old plane
								plane[i].active = false;
								plane[i].resetCounts();
							}
						}
					} // end of developer levels spawning
				} // end of DeveloperLevels == true
			}
			if( GameState == 100 ) // 100 means do not check. Will implement new level changing dynamics
			{
				// plane side activation algorithms
				if( levelNumber == 1 && plane[i].highestLayerLevel == 0 )
				{
					if( phaseNumber <= 2 )
					{
						// Activate New plane						

						// activate 1 other side at random that wasn't just already active, and it cannot be another active side
						IwRandSeed( (int32)s3eTimerGetMs() );
						int16 a = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
						while( a == i || plane[a].active == true ) // 'a' side cannot be equal to plane just deactivated. i here is not direction of plane, just index for diff. planes
						{
							a = IwRandMinMax( 0, 5+1 );
						}

						// activate the new plane
						plane[a].active = true;
						// deactivate the old plane
						plane[i].active = false;
						plane[i].resetCounts();

						// increase speed from 600 to 600
						INITIAL_SPEED = 600;
						phaseNumber++;
					}
					else if( phaseNumber == 3 ) // if current phase is the last phase, advance to next level
					{
						// Activate new Planes and deactivate old plane
						// activate 2 other sides at random that wasn't just already active. one of them must be adjacent
						IwRandSeed( (int32)s3eTimerGetMs() );
						int16 b = IwRandMinMax( 0, 5+1 );

						while( plane[b].active == true ) // b cannot be equal to a or i
						{
							b = IwRandMinMax( 0, 5+1 );
						}
						plane[b].active = true;

						// activate 1 other adjacent side
						IwRandSeed( (int32)s3eTimerGetMs() );
						int16 dir;
						int a;  // the indexes for planes datastructure

						do
						{
							dir = getAdjacentDirection( plane[b].direction );

							// find a, index of plane with the adjacent direction
							for( int j = 0; j < 6; j++ )
							{
								if( plane[j].direction == dir )
								{
									a = j;
									break;
								}
							}
						}
						while( a == i || plane[a].active == true );

						// activate the new plane
						plane[a].active = true;

						// deactivate old plane
						plane[i].active = false;
						plane[i].resetCounts();

						// advance level number and reset phase number for that level
						levelNumber++; // advance to level 2
						phaseNumber = 1;
					}

					
				} // end of if levelNumber == 1
				else if( levelNumber == 2 && plane[i].highestLayerLevel == 0 )
				{
					if( phaseNumber <= 1 )
					{
						// activate 1 other side at random that wasn't just already active, and it cannot be another active side
						IwRandSeed( (int32)s3eTimerGetMs() );
						int16 dir;
						int a;  // the indexes for planes datastructure

						do
						{
							// find the plane that is active that is not the one that just warped
							for( int j = 0; j < 6; j++ )
							{
								if( plane[j].active == true && j != i )
								{
									dir = getAdjacentDirection( plane[j].direction );
									break;
								}
							}							 

							// find a, index of plane with the adjacent direction
							for( int j = 0; j < 6; j++ )
							{
								if( plane[j].direction == dir )
								{
									a = j;
									break;
								}
							}
						}
						while( a == i || plane[a].active == true );

						// activate the new plane
						plane[a].active = true;

						// deactivate the old plane
						plane[i].active = false;
						plane[i].resetCounts();

						// increase speed from 600 to 600
						INITIAL_SPEED = 600;
						phaseNumber++;
					}
					else if( phaseNumber == 2 ) // if on last phase, do not advance level until all planes are deactivated
					{
						// deactivate the plane						
						plane[i].active = false;
						plane[i].resetCounts();

						// no plane activation
						bool advanceToNextLevel = true;

						for( int j = 0; j < 6; j++ )
						{
							if( plane[j].active == true ) // if there is a plane still active, do not advance
							{
								advanceToNextLevel = false;
								break;
							}
						}
						if( advanceToNextLevel == true )
						{
							// activate 2 other sides at random that wasn't just already active. one of them must be adjacent
							IwRandSeed( (int32)s3eTimerGetMs() );
							int16 b = IwRandMinMax( 0, 5+1 );

							while( plane[b].active == true ) // b cannot be equal to a or i
							{
								b = IwRandMinMax( 0, 5+1 );
							}
							plane[b].active = true;

							// activate 1 other adjacent side
							IwRandSeed( (int32)s3eTimerGetMs() );
							int16 dir;
							int a;  // the indexes for planes datastructure

							do
							{
								dir = getAdjacentDirection( plane[b].direction );

								// find a, index of plane with the adjacent direction
								for( int j = 0; j < 6; j++ )
								{
									if( plane[j].direction == dir )
									{
										a = j;
										break;
									}
								}
							}
							while( a == i || plane[a].active == true );

							// activate the new plane
							plane[a].active = true;
						
							levelNumber++;
							phaseNumber = 1;
						}
					}
				}
				else if( levelNumber == 3 && plane[i].highestLayerLevel == 0 )
				{
					if( phaseNumber <= 2 )
					{
						// activate 1 other side at random that wasn't just already active, and it cannot be another active side
						IwRandSeed( (int32)s3eTimerGetMs() );
						int16 dir;
						int a;  // the indexes for planes datastructure

						do
						{
							// find the plane that is active that is not the one that just warped
							for( int j = 0; j < 6; j++ )
							{
								if( plane[j].active == true && j != i )
								{
									dir = getAdjacentDirection( plane[j].direction );
									break;
								}
							}

							// find a, index of plane with the adjacent direction
							for( int j = 0; j < 6; j++ )
							{
								if( plane[j].direction == dir )
								{
									a = j;
									break;
								}
							}
						}
						while( a == i || plane[a].active == true );

						// activate the new plane
						plane[a].active = true;
						// deactivate the old plane
						plane[i].active = false;
						plane[i].resetCounts();

						phaseNumber++;
					}
					else if( phaseNumber == 3 )
					{
						// activate 1 other side at random that wasn't just already active
						IwRandSeed( (int32)s3eTimerGetMs() );
						int16 a = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure

						while( a == i || plane[a].active == true ) // 'a' side cannot be equal to plane just deactivated. i here is not direction of plane, just index for diff. planes
						{
							a = IwRandMinMax( 0, 5+1 );
						}
						plane[a].active = true;
						/*
						// activate 2 other sides at random that wasn't just already active
						IwRandSeed( (int32)s3eTimerGetMs() );
						int16 a = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
						int16 b = IwRandMinMax( 0, 5+1 );

						while( a == i || plane[a].active == true ) // 'a' side cannot be equal to plane just deactivated. i here is not direction of plane, just index for diff. planes
						{
							a = IwRandMinMax( 0, 5+1 );
						}
						plane[a].active = true;

						while( b == i || plane[b].active == true ) // b cannot be equal to a or i
						{
							b = IwRandMinMax( 0, 5+1 );
						}
						plane[b].active = true;
						*/

						// deactivate the old plane
						plane[i].active = false;
						plane[i].resetCounts();

						// move to level 4
						levelNumber++;
						phaseNumber = 1;
					}
				}
				else if( levelNumber == 4 && plane[i].highestLayerLevel == 0 )
				{
					if( phaseNumber <= 1 )
					{
						// activate 1 other side at random that wasn't just already active, and it cannot be another active side
						IwRandSeed( (int32)s3eTimerGetMs() );
						int16 a = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
						while( a == i || plane[a].active == true ) // 'a' side cannot be equal to plane just deactivated. i here is not direction of plane, just index for diff. planes
						{
							a = IwRandMinMax( 0, 5+1 );
						}

						// activate the new plane
						plane[a].active = true;
						// deactivate the old plane
						plane[i].active = false;
						plane[i].resetCounts();

						phaseNumber++;
					}
					else if( phaseNumber == 2 )
					{
						// deactivate the plane						
						plane[i].active = false;
						plane[i].resetCounts();

						// no plane activation
						bool advanceToNextLevel = true;

						for( int j = 0; j < 6; j++ )
						{
							if( plane[j].active == true ) // if there is a plane still active, do not advance
							{
								advanceToNextLevel = false;
								break;
							}
						}

						if( advanceToNextLevel == true )
						{
							// Activate level 5 planes
						
							levelNumber++; // advance to level 5
							phaseNumber = 1;
						}
					}
				}
				/* obsolete
				if( levelNumber == 1 )
				{
					if( plane[i].active == true && plane[i].highestLayerLevel == 0 )
					{
						// deactivate that side and reset win count
						//plane[i].active = false;
						plane[i].resetCounts();

						// activate 1 other side at random that wasn't just already active, and it cannot be another active side
						IwRandSeed( (int32)s3eTimerGetMs() );
						int16 a = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
						while( a == i || plane[a].active == true ) // 'a' side cannot be equal to plane just deactivated. i here is not direction of plane, just index for diff. planes
						{
							a = IwRandMinMax( 0, 5+1 );
						}

						// activate the two new planes
						plane[a].active = true;

						// increase speed from 200 to 600
						INITIAL_SPEED = 600;

						// increment level number from 1 to 2
						levelNumber = 2;
						plane[i].active = false;
					}
				}
				else if( levelNumber == 2 )
				{
					//if( plane[i].active == true && plane[i].winCount == 1 )
					if( plane[i].active == true && plane[i].highestLayerLevel == 0 )
					{
						// deactivate that side and reset win count
						plane[i].active = false;
						plane[i].resetCounts();

						// activate 2 other sides at random that wasn't just already active
						IwRandSeed( (int32)s3eTimerGetMs() );
						int16 a = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
						int16 b = IwRandMinMax( 0, 5+1 );
						while( plane[a].active == true ) // 'a' side cannot be equal to plane just deactivated. i here is not direction of plane, just index for diff. planes
						{
							a = IwRandMinMax( 0, 5+1 );
						}
						plane[a].active = true;

						while( plane[b].active == true ) // b cannot be equal to a or i
						{
							b = IwRandMinMax( 0, 5+1 );
						}
						plane[b].active = true;

						// maintain speed

						// increment level number from 2 to 3
						levelNumber = 3;
					}
				}
				else if( levelNumber == 3 )
				{
					if( plane[i].active == true && plane[i].highestLayerLevel == 0 )
					{
						// deactivate that side and reset win count
						//plane[i].active = false;
						plane[i].resetCounts();

						// activate 1 other sides at random that wasn't just already active
						IwRandSeed( (int32)s3eTimerGetMs() );
						int16 a = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
						int16 b = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
						int16 c = IwRandMinMax( 0, 5+1 ); // the indexes for planes datastructure
						while( plane[a].active == true ) // 'a' side cannot be equal to plane just deactivated. i here is not direction of plane, just index for diff. planes
						{
							a = IwRandMinMax( 0, 5+1 );
						}

						// activate the two new planes
						plane[a].active = true;

						while( plane[b].active == true ) // 'b' side cannot be equal to plane just deactivated. i here is not direction of plane, just index for diff. planes
						{
							b = IwRandMinMax( 0, 5+1 );
						}

						// activate the two new planes
						plane[b].active = true;

						while( plane[c].active == true ) // 'b' side cannot be equal to plane just deactivated. i here is not direction of plane, just index for diff. planes
						{
							c = IwRandMinMax( 0, 5+1 );
						}

						// activate the two new planes
						plane[c].active = true;

						// maintain speed

						// increment level number from 3 to 4
						levelNumber = 4;

						plane[i].active = false;
					}
				}
				else if( levelNumber == 4 )
				{
					if( plane[i].active == true && plane[i].highestLayerLevel == 0 )
					{
						// deactivate that side and reset win count
						//plane[i].active = false;
						plane[i].resetCounts();
					
						int counter = 0;
						// increment level number from 4 to 5 when last side is finished
						for( int j = 0; j < 6; j++ ) // check how many planes are active
						{
							if( plane[j].active == true )
							{
								counter++;
							}
						}

						if( counter >= 2 ) // if there are 2 or more planes, deactivate the plane
						{
							plane[i].active = false;
						}
						else if( counter == 1 ) // if there is one plane left, enable all other 5 sides
						{
							for( int j = 0; j < 6; j++ )
							{
								if( j != i ) // if the plane is not current one, activate it
								{
									plane[j].active = true;
								}
							}
							levelNumber = 5;
						}
					}
				}
				else if( levelNumber == 5 )
				{
					if( plane[i].active == true && plane[i].highestLayerLevel == 0 )
					{
						// deactivate that side and reset win count
						//plane[i].active = false;
						plane[i].resetCounts();
						plane[i].active = false;
					}
				}
				*/
			} // end of if GameState == PlayGame
			else if( GameState == PLAY_TUTORIAL ) // level progression condition for tutorial is completing one side
			{
				// changing tutorial phases is based on user manually pressing arrows when they want

				// grant completion for tutorial level 4, Completing a side
				if( tutorialNumber == 4 )
				{
					tutorialCompleteSidePassed = true;
				}

				if( tutorialNumber == 7 )
				{
					tutorialCompleteSide2Passed = true;
				}
			}

			// find all the cubes that are in same direction as plane and whose touchingSide = true
			for( int j = numOriginalCubes; j < numStaticCubes; j++ ) // only check cubes that have been landed, discluding original spawn cubes
			{
				// if it's the plane's last warping iteration of being active, warp ALL cubes on same direction
				if( cubeArray[j].direction == plane[i].direction && plane[i].active == false )
				{
					cubeArray[j].warping = true;
					cubeArray[j].material = Cube::WARPING_MATERIAL; // reset its material as a warping material
				}
				// if cube is touching plane, initiate its warping state
				else if( cubeArray[j].direction == plane[i].direction && cubeArray[j].touchingSide == true )
				{
					cubeArray[j].warping = true;
					cubeArray[j].material = Cube::WARPING_MATERIAL; // reset its material as a warping material
				}
			}
		}
	}
} // end of CheckAndWarpCubes

void CheckAndExplodeCubes()
{
	// CHECK CUBES FOR EXPLODING
	// check to initiate exploding cubes
	bool intensityAlreadySet[6] = {false, false, false, false, false, false};
	bool resetIntensity[6] = {false, false, false, false, false, false};
	
	for( int i = numOriginalCubes; i < numStaticCubes; i++ )
	{
		if( cubeArray[i].exploding == true )
		{
			// give it an exploding material
			cubeArray[i].material = Cube::EXPLODING_MATERIAL;

			int16 dir = cubeArray[i].direction;
			dir = dir - 1;

			// reset deathvoice sound
			playedDeathVoiceOnce = false;

			// start explode animation
			// set for bombs
			if( explodingMaterialIntensity[dir] == 255 && cubeArray[i].hasBomb == true )
			{
				// if the bomb is on a plane that is supposed to detonate, explode it instead of defuse.
				int tempDir = cubeArray[i].direction;

				printf("Bomb exploding 0. \n");

				if( bombDirectionIsExploding[tempDir - 1] == true ) 
				{
					if( cubeArray[i].bomb.state == Bomb::TICKING )
					{
						cubeArray[i].bomb.setState( Bomb::START_EXPLODING );
					}

					// reset bomb triggered
					bombTriggered[tempDir-1] = false;

					// reset allowing single cube spawn if that side exploded
					plane[i].allowSingleCubeSpawn = true;

					// Shake camera medium if exploding
					if( highestLayerLevel < 4 )
					{
						shakeCameraMedium = true;
					}
					else
					{
						shakeCameraGigantic = true;							
					}

					// Play Boom Sound
					playBoomSound();

					playGameOverVoice();

					scoredDrops -= 3;
					scoredDropsCurrent -= 3;

					// Hide tutorial defuse bomb
					if( triggeredShowTutorialDefuseBomb1 == true && triggeredHideTutorialDefuseBomb1 == false )
					{
						s3eTimerSetTimer( 0, triggerHideTutorialDefuseBomb1, 0 );
						//s3eTimerCancelTimer( triggerShowTutorialDefuseBomb1, 0 );
						triggeredHideTutorialDefuseBomb1 = true;
						triggeredShowTutorialDefuseBomb1 = false;// this resets the bomb tutorial message
					}

					if( triggeredShowTutorialDefuseBomb2 == true && triggeredHideTutorialDefuseBomb2 == false )
					{
						s3eTimerSetTimer( 0, triggerHideTutorialDefuseBomb2, 0 );
						//s3eTimerCancelTimer( triggerShowTutorialDefuseBomb2, 0 );
						triggeredHideTutorialDefuseBomb2 = true;
						triggeredShowTutorialDefuseBomb2 = false;// this resets the bomb tutorial message
					}

					printf("Bomb exploded 1. \n");
				}
				else // Defuse the bomb if it's defused
				{
					if( cubeArray[i].bomb.defused == true )
					{
						cubeArray[i].bomb.setState( Bomb::START_DEFUSING );
						showBombDefusedSprite = true;

						// play thankyou voice
						playDefusedVoice();

						// add one life to give back for defusing
						numOfLives++;

						// helps offset skill for not sacrificing fuzzy
						scoredDrops += 3;
						scoredDropsCurrent += 3;
												
						// add five hundred points						
						for( int j = 0; j < 4; j++ ) // find the free sprite 
						{
							if( pointSprites[6][j].type == PointSprite::NONE ) // means it's free
							{
								pointSprites[6][j].setType( PointSprite::FIVE_HUNDRED ); // it is one hundred points if it is a fuzzy	
								addScore( 500 );

								//pointSprites[6][j].setPosition( IwGxGetScreenWidth()/2 + 15, IwGxGetScreenHeight()/2 - 100);// set the location
								pointSprites[6][j].setPosition( IwGxGetScreenWidth()/2 + width*.031, IwGxGetScreenHeight()/2 - height*.313);// set the location

								break; // stop assigning and activating sprites once free one is found
							}
						}

						tutorialBombDefuseCount++;

						// Hide tutorial defuse bomb
						if( triggeredShowTutorialDefuseBomb1 == true && triggeredHideTutorialDefuseBomb1 == false )
						{
							s3eTimerSetTimer( 0, triggerHideTutorialDefuseBomb1, 0 );
							//s3eTimerCancelTimer( triggerShowTutorialDefuseBomb1, 0 );						
							triggeredHideTutorialDefuseBomb1 = true;
							triggeredShowTutorialDefuseBomb1 = false;// this resets the bomb tutorial message
						}

						if( triggeredShowTutorialDefuseBomb2 == true && triggeredHideTutorialDefuseBomb2 == false )
						{
							s3eTimerSetTimer( 0, triggerHideTutorialDefuseBomb2, 0 );
							//s3eTimerCancelTimer( triggerShowTutorialDefuseBomb2, 0 );
							triggeredHideTutorialDefuseBomb2 = true;
							triggeredShowTutorialDefuseBomb2 = false;// this resets the bomb tutorial message
						}
						
					}

					
					// Shake camera small if defusing
					if( highestLayerLevel < 4 )
					{
						shakeCamera = true;
					}
					else
					{
						shakeCameraGigantic = true;							
					}

					// Play Boom Sound
					playBoomSound();
				}

				

				/*
				cubeArray[i].fuzzyExplodeMaterial = new CIwMaterial;
				cubeArray[i].fuzzyExplodeMaterial->Copy( fuzzyExplodeMaterial[0] );
				cubeArray[i].fuzzyExplodeMaterial->SetTexture( fuzzyExplodeMaterial[0]->GetTexture() );

				
				// start animation
				cubeArray[i].fuzzyExplodeMaterial->CreateAnim();
				cubeArray[i].fuzzyExplodeMaterial->SetAnimCelW( 64 );
				cubeArray[i].fuzzyExplodeMaterial->SetAnimCelH( 64 );
				cubeArray[i].fuzzyExplodeMaterial->SetAnimCelPeriod( 1 );
				cubeArray[i].fuzzyExplodeMaterial->SetAnimCelNum( 28 );

				cubeArray[i].fuzzyExplodeMaterial->SetColAmbient( 255, 255, 255, 255 );
				cubeArray[i].fuzzyExplodeMaterial->SetColDiffuse( 255, 255, 255, 255 );	
				cubeArray[i].fuzzyExplodeMaterial->SetAlphaMode( alphaValue_fuzzyMaterial );
				*/
			}
			// set fuzzy explode texture
			// if at max glow limit, start the explosion animation for fuzzy		
			if( explodingMaterialIntensity[dir] == 255 && cubeArray[i].hasFuzzy == true )
			{
				numOfLives--;
				scoredDrops -= 1;
				scoredDropsCurrent -= 1;

				// check game over with timer, b/c getting life back from fuzzy defuse has time delay
				if( s3eTimerSetTimer( 100, checkOutOfLivesGameOver, 0 ) != S3E_RESULT_SUCCESS )
				{
					printf("Failed to register checking out of lives due to game over. \n");
				}

				// start animation
				// only create animation if it doesn't already exist 

				if( cubeArray[i].explosionLoaded == false )
				{
					cubeArray[i].explosionLoaded = true;
				}
				
				if( cubeArray[i].fuzzyExplodeMaterial->IsAnim() == false )
				{
					cubeArray[i].fuzzyExplodeMaterial->CreateAnim();
					cubeArray[i].fuzzyExplodeMaterial->SetAnimCelW( 64 );
					cubeArray[i].fuzzyExplodeMaterial->SetAnimCelH( 64 );
					cubeArray[i].fuzzyExplodeMaterial->SetAnimCelPeriod( 1 );
					cubeArray[i].fuzzyExplodeMaterial->SetAnimCelNum( 28 );

					cubeArray[i].fuzzyExplodeMaterial->SetColAmbient( 255, 255, 255, 255 );
					cubeArray[i].fuzzyExplodeMaterial->SetColDiffuse( 255, 255, 255, 255 );	
					cubeArray[i].fuzzyExplodeMaterial->SetAlphaMode( alphaValue_fuzzyMaterial );
				}
				
				// Play Boom Sound
				playBoomSound();

				// show tutorial donotdie
				if( episode == 1 && levelNumber >=1 && levelNumber <= 3 && triggeredShowTutorialDoNotDie == false )
				{
					s3eTimerSetTimer( 0, triggerShowTutorialDoNotDie, 0 );
					triggeredShowTutorialDoNotDie = true;
					triggeredHideTutorialDoNotDie = false;
					showTutorialSprites[9] = true;
				}
					
				if( highestLayerLevel < 4 )
				{
					shakeCamera = true;
				}
				else
				{
					shakeCameraGigantic = true;							
				}
			}

			// CHECK AND SET INTENSITY FOR EXPLODING CUBES
			// set the intensity for the group of cubes exploding if not already set
			// use direction of cube for array slot of materials, etc.
			if( intensityAlreadySet[dir] == false )
			{
				// increment intensity
				if( explodingUp[dir] == true )
					explodingMaterialIntensity[dir] += 5;
				else // if it's not exploding up
					explodingMaterialIntensity[dir] -= 10;

				intensityAlreadySet[dir] = true; // ensures that intensity is set only once for every group of exploding cubes (same direction)

				// CLAMP THE MAX INTENSITY
				if( explodingMaterialIntensity[dir] >= 255 ) // this is when the cube explodes down
				{
					explodingMaterialIntensity[dir] = 255;
					explodingUp[dir] = false;

					
					// decrease number if lives by 1 if it is a cube with a fuzzy on that side
					for( int j = numOriginalCubes; j < numStaticCubes; j++ )
					{
						// if the cube is exploding and is on the same side as current exploding cube
						if( cubeArray[j].exploding == true && cubeArray[j].direction == cubeArray[i].direction && cubeArray[j].hasFuzzy == true )	
						{
							/* trying to move this
							// REMOVE LIVES ONLY IF PLAYING GAME MODE
							if( GameState == PLAY_GAME )
							{
								numOfLives--;
							}		
							*/

							// activates rendering minus One Fuzzy
							bool breakOutOf1stLoop = false;
							for( int k = 0; k < 6; k++ )
							{
								for( int l = 0; l < 9; l++ )
								{
									if( minusOneFuzzy[k][l] == false )
									{
										minusOneFuzzy[k][l] = true;

										// set the location of the point sprite
										int32 x;
										int32 y;
										CIwVec3 p = modelMatrix1.TransformVec( (CIwVec3)cubeArray[j].position );

										IwGxWorldToScreenXY( x, y, p );

										//minusOneFuzzySprite[k][l].setPosition( x, y - 25);// set the location
										minusOneFuzzySprite[k][l].setPosition( x, y - height*.078);// set the location

										breakOutOf1stLoop = true; // breaks out of first loop
										break; // breaks out of inner loop
									}
								}
								if( breakOutOf1stLoop == true )
								{
									break;
								}
							}
						}
					}

					// trigger recalculation of planes' layer levels
					recalculateLayerLevels = true;
				}

				if( explodingMaterialIntensity[dir] <= 0 )
				{
					explodingMaterialIntensity[dir] = 0;
					explodingUp[dir] = true;
				}

			}

			// CHECK FOR MAXIMUM INTENSITY REACHED and REMOVE CUBE if reached
			if( explodingMaterialIntensity[dir] == 0 )
			{
				// if this cube was touching plane, decrement count if same color
				if( cubeArray[i].touchingSide == true )
				{
					for( int j = 0; j < 6; j++ )
					{
						if( plane[j].direction == cubeArray[i].direction && plane[j].color == cubeArray[i].color )
						{
							plane[j].count--;
						}
					}
				}

				// SET CUBE TO BE REMOVED AFTER FINISHED EXPLODING 
				cubeArray[i].exploded = true;
				cubeArray[i].exploding = false;

				// TRIGGER RESETTING INTENSITY
				resetIntensity[dir] = true;

				/* maybe no camera shake
				// shake camera
				// every time the camera shakes, it needs to start from beginning, so reset shakeCounter
				shakeCounter = 0;
				shakeCamera = true;
				*/
			}
		}
	}

	bool cubesExploded = false;
	// CHECK FOR RESETTING EXPLODING INTENSITY
	for( int i = 0; i < 6;  i++ )
	{
		if( resetIntensity[i] == true ) // checks if any cubes finished exploding
		{
			explodingMaterialIntensity[i] = 100;		
			cubesExploded = true;
		}
	}

}

void TouchShadow()
{
	// untouch all shadows
	for( int i = 0; i < numShadowsIndex; i++ )
	{
		shadowArray[i].touched = false;
		// set all initial positions
		shadowArray[i].initialPosition = shadowArray[i].position;
	}

	for( int i = 0; i < numShadowsIndex; i++ ) // checks to see if a shadow is touched
	{
		// sets model matrix before calculating to make sure no glitches
		shadowArray[i].setModelMatrix( modelMatrix1 );

		// check for closest shadow
		// only checks the shadow touch if its linked cube is not already dropped
		if( shadowArray[i].isTouched( x1, y1 ) && shadowArray[i].shadowGroup->dropCubes == false )
		{
			if( selectedShadow != NULL )
			{
				int16 zDistance = 0; //zDistance is the shadow's zDistance from the camera, finds closest shadow being touched
				int16 zDistanceOriginal = 0;
				CIwVec3 location = tt1.TransformVec(shadowArray[i].position);
				CIwVec3 locationOriginal = tt1.TransformVec( selectedShadow->position );
				zDistance = abs(view.t.z) - abs(location.z);
				zDistanceOriginal = abs(view.t.z) - abs(locationOriginal.z);

				if( zDistance < zDistanceOriginal )
				{
					selectedShadow->touched = false;
					selectedShadow = shadowArray + i;
					selectedShadow->touched = true;
				}
			}
			else
			{
				selectedShadow = shadowArray + i;
				selectedShadow->touched = true;
			}

			// enables possible tap action, for dropping down the cube				
			dropTap = true;
			initialTapMS = s3eTimerGetMs();

			//shadowArray[i].touched = true;
			rotateEnabled = false;
		} // end of checking for closest shadow
	} // end of for loop seeing of shadows are touched
}

void UpdateShadowBlinking()
{
	// BLUE BLINKING
	if( blueSolidIntensity == upperLimit ) // checks to see when intensity hits upper limit
		blueSolidIncreasing = false;
	else if( blueSolidIntensity == lowerLimit )
		blueSolidIncreasing = true;

	if( blueSolidIncreasing == true )
	{
		if( selectedShadow != NULL ) // if the shadow is touched, it blinks twice as fast
		{
			if( selectedShadow->cube->color == Cube::BLUE )
				blueSolidIntensity += blueSolidIntensityIncrement*2;
			else
				blueSolidIntensity += blueSolidIntensityIncrement;
		}
		else
			blueSolidIntensity += blueSolidIntensityIncrement;
	}
	else // if false, make intensity decrease
	{
		if( selectedShadow != NULL ) // if the shadow is touched, it blinks twice as fast
		{
			if( selectedShadow->cube->color == Cube::BLUE )
				blueSolidIntensity -= blueSolidIntensityIncrement*2;
			else
				blueSolidIntensity -= blueSolidIntensityIncrement;
		}
		else
			blueSolidIntensity -= blueSolidIntensityIncrement;
	}

	if( blueSolidIntensity >= upperLimit )
		blueSolidIntensity = upperLimit;
	else if( blueSolidIntensity <= lowerLimit )
		blueSolidIntensity = lowerLimit;

	// RED BLINKING
	if( redSolidIntensity == upperLimit ) // checks to see when intensity hits upper limit
		redSolidIncreasing = false;
	else if( redSolidIntensity == lowerLimit )
		redSolidIncreasing = true;

	if( redSolidIncreasing == true )
	{
		if( selectedShadow != NULL ) // if the shadow is touched, it blinks twice as fast
		{
			if( selectedShadow->cube->color == Cube::RED )
				redSolidIntensity += redSolidIntensityIncrement*2;
			else
				redSolidIntensity += redSolidIntensityIncrement;
		}
		else
			redSolidIntensity += redSolidIntensityIncrement;
	}
	else // if false, make intensity decrease
	{
		if( selectedShadow != NULL ) // if the shadow is touched, it blinks twice as fast
		{
			if( selectedShadow->cube->color == Cube::RED )
				redSolidIntensity -= redSolidIntensityIncrement*2;
			else
				redSolidIntensity -= redSolidIntensityIncrement;
		}
		else
			redSolidIntensity -= redSolidIntensityIncrement;
	}

	if( redSolidIntensity >= upperLimit )
		redSolidIntensity = upperLimit;
	else if( redSolidIntensity <= lowerLimit )
		redSolidIntensity = lowerLimit;

	// GREEN BLINKING
	if( greenSolidIntensity == upperLimit ) // checks to see when intensity hits upper limit
		greenSolidIncreasing = false;
	else if( greenSolidIntensity == lowerLimit )
		greenSolidIncreasing = true;

	if( greenSolidIncreasing == true )
	{
		if( selectedShadow != NULL ) // if the shadow is touched, it blinks twice as fast
		{
			if( selectedShadow->cube->color == Cube::GREEN )
				greenSolidIntensity += greenSolidIntensityIncrement*2;
			else
				greenSolidIntensity += greenSolidIntensityIncrement;
		}
		else
			greenSolidIntensity += greenSolidIntensityIncrement;
	}
	else // if false, make intensity decrease
	{
		if( selectedShadow != NULL ) // if the shadow is touched, it blinks twice as fast
		{
			if( selectedShadow->cube->color == Cube::GREEN )
				greenSolidIntensity -= greenSolidIntensityIncrement*2;
			else
				greenSolidIntensity -= greenSolidIntensityIncrement;
		}
		else
			greenSolidIntensity -= greenSolidIntensityIncrement;
	}

	if( greenSolidIntensity >= upperLimit )
		greenSolidIntensity = upperLimit;
	else if( greenSolidIntensity <= lowerLimit )
		greenSolidIntensity = lowerLimit;

	// PURPLE BLINKING
	if( purpleSolidIntensity == upperLimit ) // checks to see when intensity hits upper limit
		purpleSolidIncreasing = false;
	else if( purpleSolidIntensity == lowerLimit )
		purpleSolidIncreasing = true;

	if( purpleSolidIncreasing == true )
	{
		if( selectedShadow != NULL ) // if the shadow is touched, it blinks twice as fast
		{
			if( selectedShadow->cube->color == Cube::PURPLE )
				purpleSolidIntensity += purpleSolidIntensityIncrement*2;
			else
				purpleSolidIntensity += purpleSolidIntensityIncrement;
		}
		else
			purpleSolidIntensity += purpleSolidIntensityIncrement;
	}
	else // if false, make intensity decrease
	{
		if( selectedShadow != NULL ) // if the shadow is touched, it blinks twice as fast
		{
			if( selectedShadow->cube->color == Cube::PURPLE )
				purpleSolidIntensity -= purpleSolidIntensityIncrement*2;
			else
				purpleSolidIntensity -= purpleSolidIntensityIncrement;
		}
		else
			purpleSolidIntensity -= purpleSolidIntensityIncrement;
	}

	if( purpleSolidIntensity >= upperLimit )
		purpleSolidIntensity = upperLimit;
	else if( purpleSolidIntensity <= lowerLimit )
		purpleSolidIntensity = lowerLimit;

	// ORANGE BLINKING
	if( orangeSolidIntensity == upperLimit ) // checks to see when intensity hits upper limit
		orangeSolidIncreasing = false;
	else if( orangeSolidIntensity == lowerLimit )
		orangeSolidIncreasing = true;

	if( orangeSolidIncreasing == true )
	{
		if( selectedShadow != NULL ) // if the shadow is touched, it blinks twice as fast
		{
			if( selectedShadow->cube->color == Cube::ORANGE )
				orangeSolidIntensity += orangeSolidIntensityIncrement*2;
			else
				orangeSolidIntensity += orangeSolidIntensityIncrement;
		}
		else
			orangeSolidIntensity += orangeSolidIntensityIncrement;
	}
	else // if false, make intensity decrease
	{
		if( selectedShadow != NULL ) // if the shadow is touched, it blinks twice as fast
		{
			if( selectedShadow->cube->color == Cube::ORANGE )
				orangeSolidIntensity -= orangeSolidIntensityIncrement*2;
			else
				orangeSolidIntensity -= orangeSolidIntensityIncrement;
		}
		else
			orangeSolidIntensity -= orangeSolidIntensityIncrement;
	}

	if( orangeSolidIntensity >= upperLimit )
		orangeSolidIntensity = upperLimit;
	else if( orangeSolidIntensity <= lowerLimit )
		orangeSolidIntensity = lowerLimit;

	// YELLOW BLINKING
	if( yellowSolidIntensity == upperLimit ) // checks to see when intensity hits upper limit
		yellowSolidIncreasing = false;
	else if( yellowSolidIntensity == lowerLimit )
		yellowSolidIncreasing = true;

	if( yellowSolidIncreasing == true )
	{
		if( selectedShadow != NULL ) // if the shadow is touched, it blinks twice as fast
		{
			if( selectedShadow->cube->color == Cube::YELLOW )
				yellowSolidIntensity += yellowSolidIntensityIncrement*2;
			else
				yellowSolidIntensity += yellowSolidIntensityIncrement;
		}
		else
			yellowSolidIntensity += yellowSolidIntensityIncrement;
	}
	else // if false, make intensity decrease
	{
		if( selectedShadow != NULL ) // if the shadow is touched, it blinks twice as fast
		{
			if( selectedShadow->cube->color == Cube::YELLOW )
				yellowSolidIntensity -= yellowSolidIntensityIncrement*2;
			else
				yellowSolidIntensity -= yellowSolidIntensityIncrement;
		}
		else
			yellowSolidIntensity -= yellowSolidIntensityIncrement;
	}

	if( yellowSolidIntensity >= upperLimit )
		yellowSolidIntensity = upperLimit;
	else if( yellowSolidIntensity <= lowerLimit )
		yellowSolidIntensity = lowerLimit;
}

// update the score for printing
void UpdateScore()
{	
	// does not do anything
}

void addScore( int n )
{
	score += n;
	scoreLivesBonusBucket += n;
}

void showAndPlayScore()
{
	// show score	
	CIwGxFontPreparedData scoreData;
	char scoreChar[100] = "";
	std::ostringstream scoreStringStream;
	scoreStringStream << score;
	string scoreString = scoreStringStream.str();
	strcat( scoreChar, scoreString.c_str() );
	IwGxFontPrepareText( scoreData, scoreChar );

	// draw shadow
	//IwGxFontSetCol(0xffaaffff);
	IwGxFontSetCol(0xff990033);
	//IwGxFontSetRect( CIwRect( IwGxGetScreenWidth()/2 - 25, IwGxGetScreenHeight()/2 - 52, 480, 200 ) );
	IwGxFontSetRect( CIwRect( IwGxGetScreenWidth()/2 - width*.052, IwGxGetScreenHeight()/2 - height*.163, width, height ) );
	IwGxFontDrawText( scoreData );

	// draw text
	IwGxFontSetCol(0xffffffff);
	//IwGxFontSetRect( CIwRect( IwGxGetScreenWidth()/2 - 25 - 1, IwGxGetScreenHeight()/2 - 52 - 2, 480, 200 ) );
	IwGxFontSetRect( CIwRect( IwGxGetScreenWidth()/2 - width*.052 - width*.002, IwGxGetScreenHeight()/2 - height*.163 - height*.006, width, height ) );
	IwGxFontDrawText( scoreData );
}

void showAndPlayFuzziness()
{
	CIwGxFontPreparedData efficiencyData;
	char efficiencyChar[100] = "";
	std::ostringstream efficiencyStringStream;

	if( skillIndexRatio > 1.0 )
	{
		skillIndexRatio = 1.0;
	}
	else if( skillIndexRatio < 0.0 )
	{
		skillIndexRatio = 0.0;
	}

	if( efficiencyIndex > 1.0 )
	{
		efficiencyIndex = 1.0;
	}
	else if( efficiencyIndex < 0.0 )
	{
		efficiencyIndex = 0.0;
	}

	efficiencyStringStream << (int16)(efficiencyIndex * 100 ) << "%";

	string efficiencyString = efficiencyStringStream.str();
	strcat( efficiencyChar, efficiencyString.c_str() );
	IwGxFontPrepareText( efficiencyData, efficiencyChar );				

	// draw shadow
	//IwGxFontSetCol(0xff99ffff);
	IwGxFontSetCol(0xff990033);
	//IwGxFontSetRect( CIwRect( IwGxGetScreenWidth()/2 + 50, IwGxGetScreenHeight()/2 - 17, 480, 200 ) );
	IwGxFontSetRect( CIwRect( IwGxGetScreenWidth()/2 + width*.104, IwGxGetScreenHeight()/2 - height*.053, width, height ) );
	IwGxFontDrawText( efficiencyData );

	// draw text
	IwGxFontSetCol(0xffffffff);
	//IwGxFontSetRect( CIwRect( IwGxGetScreenWidth()/2 + 50 - 1, IwGxGetScreenHeight()/2 - 17 - 2, 480, 200 ) );
	IwGxFontSetRect( CIwRect( IwGxGetScreenWidth()/2 + width*.104 - width*.002, IwGxGetScreenHeight()/2 - height*.053 - height*.006, width, height ) );
	IwGxFontDrawText( efficiencyData );
}

void showAndPlaySkillTitle()
{
	CIwGxFontPreparedData skillData;
	char skillChar[100] = "";
	std::ostringstream skillStringStream;
	string skillName = "Unnamed";

	if( efficiencyIndex >= 0.9 )
	{
		skillName = "Fuzzy Supreme";		
	}
	else if( efficiencyIndex >= 0.8 && efficiencyIndex < 0.9 )
	{
		skillName = "Master Fuzzy";
	}
	else if( efficiencyIndex >= 0.7 && efficiencyIndex < 0.8 )
	{
		skillName = "Uber Fuzzy";
	}
	else if( efficiencyIndex >= 0.6 && efficiencyIndex < 0.7 )
	{
		skillName = "Nappy";
	}
	else if( efficiencyIndex >= 0.5 && efficiencyIndex < 0.6 )
	{
		skillName = "Hair Ball";
	}
	else if( efficiencyIndex >= 0.4 && efficiencyIndex < 0.5 )
	{
		skillName = "Buzzed Cut";
	}
	else if( efficiencyIndex >= 0.3 && efficiencyIndex < 0.4 )
	{
		skillName = "Navel Lint";
	}
	else // if efficiencyIndex is less than 0.3
	{
		skillName = "Baldy";
	}

	skillStringStream << skillName;
	string skillString = skillStringStream.str();
	strcat( skillChar, skillString.c_str() );
	IwGxFontPrepareText( skillData, skillChar );				

	// draw shadow
	//IwGxFontSetCol(0xff88ffff);
	IwGxFontSetCol(0xff990033);
	//IwGxFontSetRect( CIwRect( IwGxGetScreenWidth()/2 - 40, IwGxGetScreenHeight()/2 + 20, 480, 200 ) );
	IwGxFontSetRect( CIwRect( IwGxGetScreenWidth()/2 - width*.083, IwGxGetScreenHeight()/2 + height*.063, width, height ) );
	IwGxFontDrawText( skillData );

	// draw text
	IwGxFontSetCol(0xffffffff);
	//IwGxFontSetRect( CIwRect( IwGxGetScreenWidth()/2 - 40 - 1, IwGxGetScreenHeight()/2 + 20 - 2, 480, 200 ) );
	IwGxFontSetRect( CIwRect( IwGxGetScreenWidth()/2 - width*.083 - width*.002, IwGxGetScreenHeight()/2 + height*.063 - height*.006, width, height ) );
	IwGxFontDrawText( skillData );
}

// show score callback functions
int32 setShowScore( void* systemData, void* userData )
{
	//playCelebration1();
	showScore = true;
	
	return 0;
}

int32 setShowFuzziness( void* systemData, void* userData )
{
	//playCelebration1();
	showFuzziness = true;
	showPixieDust[1] = true;
	return 0;
}

int32 setShowSkillTitle( void* systemData, void* userData )
{
	//playCelebration1();
	showSkillTitle = true;
	showPixieDust[2] = true;

	string skillName = "Unnamed";
	char flurrySkill[50]="";

	if( efficiencyIndex >= 0.9 )
	{
		skillName = "Fuzzy Supreme";		
	}
	else if( efficiencyIndex >= 0.8 && efficiencyIndex < 0.9 )
	{
		skillName = "Master Fuzzy";
	}
	else if( efficiencyIndex >= 0.7 && efficiencyIndex < 0.8 )
	{
		skillName = "Uber Fuzzy";
	}
	else if( efficiencyIndex >= 0.6 && efficiencyIndex < 0.7 )
	{
		skillName = "Nappy";
	}
	else if( efficiencyIndex >= 0.5 && efficiencyIndex < 0.6 )
	{
		skillName = "Hair Ball";
	}
	else if( efficiencyIndex >= 0.4 && efficiencyIndex < 0.5 )
	{
		skillName = "Buzzed Cut";
	}
	else if( efficiencyIndex >= 0.3 && efficiencyIndex < 0.4 )
	{
		skillName = "Navel Lint";
	}
	else // if efficiencyIndex is less than 0.3
	{
		skillName = "Baldy";
	}

	// show game over image
	if( gameOver == true )
	{
		if( s3eTimerSetTimer( 1000, triggerGameOver, 0 ) != S3E_RESULT_SUCCESS )
		{
			printf("Set game over trigger failed.\n");
		}
	}

	/*
	// flurry log skill
	if( episode >= 1 && episode <= 3 )
	{
		if( levelNumber == 4 || levelNumber == 7 || levelNumber == 10 )
		{
			
			strcpy( flurrySkill, skillName.c_str() );
			char cstring[50] = "Episode ";
			strcat( cstring, levelToCstring(episode, levelNumber) );
			strcat( cstring, " skill: " );
			strcat( cstring, flurrySkill );
			s3eFlurryLogEvent( cstring, false );
		}
	}
	else
	{
		if( levelNumber == 6 )
		{
			
			strcpy( flurrySkill, skillName.c_str() );
			char cstring[50] = "Episode ";
			strcat( cstring, levelToCstring(episode, levelNumber) );
			strcat( cstring, " skill: " );
			strcat( cstring, flurrySkill );
			s3eFlurryLogEvent( cstring, false );
		}
	}
	*/

	return 0;
}

int32 triggerGameOver( void *systemData, void *userData )
{
	// play game over sound
	playGameOverSound();

	// trigger rendering of game over image
	showGameOver = true;

	return 0;
}

int32 setShowPixie1( void* systemData, void* userData )
{
	playCelebration1();
	showPixieDust[0] = true;
	//pixieSprite[0].setPosition( IwGxGetScreenWidth()/2 - 5, IwGxGetScreenHeight()/2 - 32 );	
	pixieSprite[0].setPosition( IwGxGetScreenWidth()/2 - width*.010, IwGxGetScreenHeight()/2 - height*.100 );
	return 0;
}

int32 setShowPixie2( void* systemData, void* userData )
{
	playCelebration1();
	showPixieDust[1] = true;
	//pixieSprite[1].setPosition( IwGxGetScreenWidth()/2 + 65, IwGxGetScreenHeight()/2 + 3 );
	pixieSprite[1].setPosition( IwGxGetScreenWidth()/2 + width*.135, IwGxGetScreenHeight()/2 + height*.009 );
	return 0;
}

int32 setShowPixie3( void* systemData, void* userData )
{
	playCelebration1();
	showPixieDust[2] = true;
	//pixieSprite[2].setPosition( IwGxGetScreenWidth()/2 - 10, IwGxGetScreenHeight()/2 + 42 );
	pixieSprite[2].setPosition( IwGxGetScreenWidth()/2 - width*.021, IwGxGetScreenHeight()/2 + height*.131 );
	return 0;
}

int32 PauseCallbackReceived( void* systemData, void* userData )
{
	// Start the game in Paused State
	if( GameState == PLAY_GAME )
	{
		GameState = PAUSED;
		//lowerVolume();
	}
	else if( GameState == PLAY_TUTORIAL )
	{
		GameState = PAUSED;
	}

	return 0;
}

int32 AllowCinemaSkip( void* systemData, void* userData )
{
	allowCinemaSkip = true;
	printf("Cinema can now be skipped.\n");
	return 0;
}